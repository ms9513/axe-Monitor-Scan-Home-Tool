(function () {
  const isDequeHost = location.hostname.endsWith('dequecloud.com');
  const isScansListPage = isDequeHost && location.pathname === '/monitor/scans';
  const isPagesListPage = isDequeHost && location.pathname === '/monitor/pages';
  const isIssuesQuickActionsPage =
    isDequeHost &&
    location.pathname === '/monitor/issues' &&
    /\bscanRun=/.test(location.search || '');
  if (!isScansListPage && !isIssuesQuickActionsPage && !isPagesListPage) {
    console.log(
      'A11y Scan Summary: Not on a supported Monitor page; widget not injected.'
    );
    return;
  }
  const pageContext = isScansListPage ? 'scans' : isPagesListPage ? 'pages' : 'issues';
  const scanRunParam = isIssuesQuickActionsPage
    ? new URLSearchParams(location.search || '').get('scanRun')
    : null;

  function openRunsInProgressDialog(contextLabel, runs, onClose) {
    if (!runs || !runs.length) return;

    const overlay = document.createElement('div');
    overlay.className = 'a11y-filter-overlay';
    const dialog = document.createElement('div');
    dialog.className = 'a11y-filter-dialog a11y-scans-dialog';
    dialog.setAttribute('role','dialog');
    dialog.setAttribute('aria-modal','true');

    const header = document.createElement('div');
    header.className = 'a11y-filter-header';
    const h2 = document.createElement('h2');
    h2.textContent = contextLabel;
    header.appendChild(h2);
    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'Dialog__close';
    closeBtn.innerHTML = '<span aria-hidden="true" class="Icon Icon--close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" height="24" width="24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" fill="currentColor"></path></svg></span><span class="Offscreen">Close</span>';
    header.appendChild(closeBtn);
    dialog.appendChild(header);

    const content = document.createElement('div');
    content.className = 'a11y-filter-content a11y-scans-dialog-content';

    const table = document.createElement('table');
    table.className = 'a11y-scan-report-table';
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    ['Scan Name','Started','Pages scanned in the last hour','Total pages scanned'].forEach(t => {
      const th = document.createElement('th');
      th.textContent = t;
      th.setAttribute('scope','col');
      hr.appendChild(th);
    });
    thead.appendChild(hr);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    runs.forEach(run => {
      const tr = document.createElement('tr');
      const nameCell = document.createElement('th');
      nameCell.setAttribute('scope','row');
      nameCell.appendChild(createScanLink({ name: run.name, url: run.url }));
      tr.appendChild(nameCell);

      const startedCell = document.createElement('td');
      startedCell.textContent = run.started || '';
      tr.appendChild(startedCell);

      const hourCell = document.createElement('td');
      hourCell.textContent = run.perHour || '';
      tr.appendChild(hourCell);

      const totalCell = document.createElement('td');
      totalCell.textContent = run.totalPages || '';
      tr.appendChild(totalCell);

      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    appendTableWithDownload(content, table, { filenameBase: 'runs-in-progress' });
    dialog.appendChild(content);

    const footer = document.createElement('div');
    footer.className = 'a11y-filter-footer';
    const okBtn = document.createElement('button');
    okBtn.type = 'button';
    okBtn.className = 'a11y-btn-primary';
    okBtn.textContent = 'Close';
    footer.appendChild(okBtn);
    dialog.appendChild(footer);

    overlay.appendChild(dialog);
    appendOverlayAfterFooter(overlay);

    const lastFocused = document.activeElement;
    function close() {
      document.removeEventListener('keydown', onKeydown, true);
      overlay.remove();
      if (typeof onClose === 'function') {
        try {
          const maybe = onClose();
          if (maybe && typeof maybe.catch === 'function') {
            maybe.catch(err => console.error(err));
          }
        } catch (err) {
          console.error(err);
        }
      }
      if (lastFocused && lastFocused.focus) lastFocused.focus();
    }

    function onKeydown(e) {
      if (e.key === 'Escape') {
        e.preventDefault();
        close();
      } else if (e.key === 'Tab') {
        const f = getFocusable(dialog);
        if (!f.length) return;
        const first = f[0];
        const last = f[f.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault(); last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault(); first.focus();
        }
      }
    }

    document.addEventListener('keydown', onKeydown, true);
    closeBtn.addEventListener('click', close);
    okBtn.addEventListener('click', close);
    overlay.addEventListener('click', e => { if (e.target === overlay) close(); });

    h2.setAttribute('tabindex','-1');
    h2.focus();
  }

  // Ensure single root
  const existingRoot = document.querySelector('.a11y-scan-report-root');
  if (existingRoot) existingRoot.remove();

  const msPerHour = 1000 * 60 * 60;
  const msPerDay = msPerHour * 24;
  const impactIssueBandOrder = ['0','1-25','26-50','51-100','101-250','251-500','>500'];
  const impactPageBandOrder = [
    '0 pages',
    '1 page',
    '2-5 pages',
    '6-10 pages',
    '11-25 pages',
    '26-50 pages',
    '51-100 pages',
    '101-250 pages',
    '251-500 pages',
    '501-1000 pages',
    '>1000 pages'
  ];
  const pageImpactFilterOptions = [
    { key: 'critical', label: 'Critical' },
    { key: 'serious', label: 'Serious' },
    { key: 'moderate', label: 'Moderate' },
    { key: 'minor', label: 'Minor' }
  ];
  const monitorApiOnlyImpactKeys = new Set(['moderate','minor']);
  const pagesTabImpactKeys = new Set(['critical','serious']);
  const monitorApiFootnoteText = '* Moderate and Minor counts require data from the axe Monitor API.';
  const defaultPageImpactSelection = pageImpactFilterOptions.map(option => option.key);
  const pageImpactFilterStorageKey = 'a11y-page-impact-filter';
  const defaultPageImpactSource = 'website';
  const pageImpactSourceOptions = [
    { key: 'website', label: 'axe Monitor website', shortLabel: 'Latest scan' },
    { key: 'api', label: 'axe Monitor API', shortLabel: 'Monitor API' }
  ];
  const pageImpactSourceAllowedKeys = {
    website: new Set(['critical','serious']),
    api: new Set(pageImpactFilterOptions.map(option => option.key))
  };
  const pageImpactApiState = {
    status: 'idle', // idle | loading | ready | error | stale
    data: new Map(), // scanId -> { critical, serious, moderate, minor, pages? }
    timestamp: null,
    error: null,
    progress: null
  };
  let lastApiFetchContext = null;
  let pageImpactApiAbortController = null;
  const pageImpactFilterIdBase = `a11y-page-impact-${Math.random().toString(36).slice(2)}`;
  const pageImpactFilterState = {
    selection: new Set(defaultPageImpactSelection),
    source: defaultPageImpactSource,
    idBase: pageImpactFilterIdBase,
    buttonId: `${pageImpactFilterIdBase}-button`,
    popoverId: `${pageImpactFilterIdBase}-popover`,
    titleId: `${pageImpactFilterIdBase}-title`,
    button: null,
    summaryEl: null,
    sourceSegment: null,
    sourceButtons: null,
    apiContainer: null,
    apiStatusEl: null,
    apiButton: null,
    apiChip: null,
    footerChipContainer: null,
    footerApiChip: null,
    footerInfoEl: null,
    footerBaseTimestamp: '',
    popover: null,
    workingSelection: null,
    workingSource: null,
    outsideClickHandler: null,
    keydownHandler: null,
    initialSourceEvaluated: false
  };
  loadStoredPageImpactFilters();
  const rankingCriteriaStorageKey = 'a11y-ranking-criteria';
  const rankingFieldOptions = [
    {
      value: 'score',
      label: 'Score (highest first)',
      shortLabel: 'Score',
      description: 'Prefers higher accessibility scores when ranking scans.',
      default: true
    },
    {
      value: 'totalCs',
      label: 'Critical + Serious issues (fewest first)',
      shortLabel: 'Critical + Serious',
      description: 'Counts combined Critical and Serious issues for tie-breaking.',
      default: true
    },
    {
      value: 'critical',
      label: 'Critical issues (fewest first)',
      shortLabel: 'Critical issues',
      description: 'Prefers scans with fewer Critical issues.',
      default: true
    },
    {
      value: 'serious',
      label: 'Serious issues (fewest first)',
      shortLabel: 'Serious issues',
      description: 'Prefers scans with fewer Serious issues.',
      default: true
    },
    {
      value: 'moderate',
      label: 'Moderate issues (fewest first)',
      shortLabel: 'Moderate issues',
      description: 'Requires Monitor API data to include Moderate issue counts.',
      default: false,
      requiresApi: true
    },
    {
      value: 'minor',
      label: 'Minor issues (fewest first)',
      shortLabel: 'Minor issues',
      description: 'Requires Monitor API data to include Minor issue counts.',
      default: false,
      requiresApi: true
    },
    {
      value: 'totalIssues',
      label: 'All issues (fewest first)',
      shortLabel: 'All issues',
      description: 'Uses the total of all available issue impacts. Moderate and Minor require the Monitor API.',
      default: true
    },
    {
      value: 'name',
      label: 'Scan name (A → Z)',
      shortLabel: 'Scan name',
      description: 'Alphabetical by scan name as a final tiebreaker.',
      default: true
    }
  ];
  const rankingFieldLookup = new Map(rankingFieldOptions.map(option => [option.value, option]));
  const rankingFallbackFields = ['name'];
  const rankingState = {
    criteria: null,
    buttonId: `a11y-ranking-button-${Math.random().toString(36).slice(2)}`,
    summaryId: `a11y-ranking-summary-${Math.random().toString(36).slice(2)}`,
    dialogTitleId: `a11y-ranking-dialog-title-${Math.random().toString(36).slice(2)}`,
    triggerButton: null,
    summaryEl: null,
    dialog: null,
    lastTrigger: null
  };
  const inertAttr = 'data-a11y-scan-report-inert';
  const issuesSectionHintSelector = '#main-content > div > div.ef72a1113bba > section > div.Panel__Content > section.bc6243444a96 > section';
  const pdfPanelHintSelector = '#main-content > div > div.ef72a1113bba > div';
  const issuesFilterButtonSelector = '#main-content > div > section > div.Panel__Content.a20db343af6f > div.a372afd8c655 > button';
  const issuesFilterModalSelector = 'body > div.Dialog.Modal.Dialog--show';
  const issuesFilterApplySelector = 'body > div.Dialog.Modal.Dialog--show > div > div.Dialog__footer > button.Button--primary';
  const issuesFilterCancelSelector = 'body > div.Dialog.Modal.Dialog--show > div > div.Dialog__footer > button.Button--secondary';
  const issuesUrlFieldSelector = '#Url_Search';
  const issuesUrlContainsRadioSelector = '#Contains';
  const issuesUrlEqualsRadioSelector = '#Equals';
  const issuesSelectAllSelector = '#select-all-checkbox';
  const issuesBulkActionsSelector = '#issues-bulk-actions';
  const issuesBulkAssignSelectSelector = '#bulkActions-assignTo';
  const issuesBulkApplyButtonSelector = '[aria-label="Apply bulk action Assign to"], #main-content button[aria-label="Apply bulk action Assign to"]';
  const assignConfirmModalSelector = 'body > div.Dialog.Alert.Dialog--show';
  const assignConfirmButtonSelector = 'body > div.Dialog.Alert.Dialog--show button.Button--primary';
  const toastSelector = '.Toast.Toast--info, .Toast.Toast--success';
  const quickAssignStoragePrefix = 'a11y-quick-assign-pages';
  const quickAssignRunStateStorageKey = 'a11y-quick-assign-run-state';
  const ignorePagesStoragePrefix = 'a11y-ignore-pages';
  const ignoreRunStateStorageKey = 'a11y-ignore-run-state';
  const markOpenPagesStoragePrefix = 'a11y-mark-open-pages';
  const markOpenRunStateStorageKey = 'a11y-mark-open-run-state';
  const quickActionsStepDelayMs = 1000;
  const wasApiBaseUrl = 'https://nyu-axemonitor.dequecloud.com/monitor-public-api/v1';
  const monitorApiKeyStorageKey = 'a11y-monitor-api-key';
  let cachedMonitorApiKey = null;
  let currentFilters = { types: new Set(), domains: new Set(), statuses: new Set() }; // empty = all
  let currentSortMeta = { index: 0, direction: 'asc', field: 'name', type: 'text', label: 'scan name' };
  let currentTabKey = pageContext === 'issues' ? 'quick' : 'status';
  function isPagesTabActive() {
    return pageContext === 'scans' && currentTabKey === 'pages';
  }
  const accordionStateByTab = {};
  const defaultWasReports = [
    { name: 'Abu Dhabi', desktop: 'Abu Dhabi - Desktop (23)', mobile: 'Abu Dhabi - Mobile (43)', pdf: 'Abu Dhabi - PDF (66)' },
    { name: 'CAS', desktop: 'A&S - CAS - Desktop (3)', mobile: 'A&S - CAS - Mobile (110)', pdf: 'A&S - CAS - PDF (68)' },
    { name: 'GSAS', desktop: 'A&S - GSAS - Desktop (4)', mobile: 'A&S - GSAS - Mobile (111)', pdf: 'A&S - GSAS - PDF (69)' },
    { name: 'Liberal Studies', desktop: 'A&S - Liberal Studies - Desktop (17)', mobile: 'A&S - Liberal Studies - Mobile (112)', pdf: 'A&S - Liberal Studies  - PDF (70)' },
    { name: 'A&S Main', desktop: 'A&S - Main - Desktop (2)', mobile: 'A&S - Main - Mobile (44)', pdf: 'A&S - Main - PDF (67)' },
    { name: 'CDS', desktop: 'CDS - Desktop (7)', mobile: 'CDS - Mobile (45)', pdf: 'CDS - PDF (90)' },
    { name: 'CAOS', desktop: 'Courant - CAOS - Desktop (6)', mobile: 'Courant - CAOS - Mobile (46)', pdf: 'Courant - CAOS - PDF (91)' },
    { name: 'CIMS', desktop: 'Courant - CIMS - Desktop (8)', mobile: 'Courant - CIMS - Mobile (113)', pdf: 'Courant - CIMS - PDF (92)' },
    { name: 'CS', desktop: 'Courant - CS - Desktop (107)', mobile: 'Courant - CS - Mobile (114)', pdf: 'Courant - CS - PDF (174)' },
    { name: 'Math', desktop: 'Courant - Math - Desktop (19)', mobile: 'Courant - Math - Mobile (115)', pdf: 'Courant - Math - PDF (167)' },
    { name: 'Dental', desktop: 'Dental - Desktop (10)', mobile: 'Dental - Mobile (117)', pdf: 'Dental - PDF (168)' },
    { name: 'Gallatin', desktop: 'Gallatin - Desktop (12)', mobile: 'Gallatin - Mobile (55)', pdf: 'Gallatin - PDF (170)' },
    { name: 'IFA', desktop: 'IFA - Desktop (15)', mobile: 'IFA - Mobile (48)', pdf: 'IFA - PDF (171)' },
    { name: 'ISAW', desktop: 'ISAW - Desktop (16)', mobile: 'ISAW - Mobile (47)', pdf: 'ISAW - PDF (172)' },
    { name: 'Law', desktop: 'Law - Desktop (30)', mobile: 'Law - Mobile (118)', pdf: 'Law - PDF (100)' },
    { name: 'Guides', desktop: 'Library - Guides - Desktop (13)', mobile: 'Library - Guides -  Mobile (119)', pdf: 'Library - Guides - PDF (173)' },
    { name: 'Main Library', desktop: 'Library - Main - Desktop (18)', mobile: 'Library - Main - Mobile (120)', pdf: 'Library - Main - PDF (102)' },
    { name: 'Neuroscience', desktop: 'Neuroscience - Desktop (20)', mobile: 'Neuroscience - Mobile (121)', pdf: 'Neuroscience - PDF (103)' },
    { name: 'Nursing', desktop: 'Nursing - Desktop (21)', mobile: 'Nursing - Mobile (56)', pdf: 'Nursing - PDF (104)' },
    { name: 'NYU - Main', desktop: 'NYU - Main - Desktop (22)', mobile: 'NYU - Main - Mobile (42)', pdf: 'NYU - Main - PDF (65)' },
    { name: 'Public Health', desktop: 'Public Health - Desktop (24)', mobile: 'Public Health - Mobile (122)', pdf: 'Public Health - PDF (166)' },
    { name: 'Shanghai', desktop: 'Shanghai - Desktop (25)', mobile: 'Shanghai - Mobile (49)', pdf: 'Shanghai - PDF (80)' },
    { name: 'Social Work', desktop: 'Social Work - Desktop (26)', mobile: 'Social Work - Mobile (54)', pdf: 'Social Work - PDF (79)' },
    { name: 'SPS', desktop: 'SPS - Desktop (31)', mobile: 'SPS - Mobile (123)', pdf: 'SPS - PDF (78)' },
    { name: 'Steinhardt', desktop: 'Steinhardt - Desktop (5)', mobile: 'Steinhardt - Mobile (128)', pdf: 'Steinhardt - PDF (73)' },
    { name: 'Stern', desktop: 'Stern - Desktop (27)', mobile: 'Stern - Mobile (124)', pdf: 'Stern - PDF (162)' },
    { name: 'Tandon', desktop: 'Tandon - Desktop (11)', mobile: 'Tandon - Mobile (125)', pdf: 'Tandon - PDF (163)' },
    { name: 'Tisch', desktop: 'Tisch - Desktop (28)', mobile: 'Tisch - Mobile (53)', pdf: 'Tisch - PDF (164)' },
    { name: 'Wagner', desktop: 'Wagner - Desktop (29)', mobile: 'Wagner - Mobile (50)', pdf: 'Wagner - PDF (165)' },
    { name: 'Journalism', desktop: 'Journalism - Desktop (72)', mobile: 'Journalism - Mobile (126)', pdf: 'Journalism - PDF (89)' },
    { name: 'ITP - Combined Sites', desktop: 'Tisch - ITP - Main - Desktop (137)', mobile: 'Tisch - ITP - Main - Mobile (140)', pdf: 'Tisch - ITP - Main - PDF (139)' }
  ];
  let wasConfig = defaultWasReports.map(entry => ({
    name: entry.name,
    desktop: entry.desktop,
    desktopId: null,
    mobile: entry.mobile,
    mobileId: null,
    pdf: entry.pdf,
    pdfId: null,
    enabled: true
  }));
  let wasDataCache = { status: 'idle', data: null, timestamp: null };
  let wasLoadAbortController = null;
  let wasRuntimeContext = { rowLookup: null };
  const logWidgetPrefix = '[ScanSummary]';
  const logWidget = (...args) => console.log(logWidgetPrefix, ...args);
  const wasLogPrefix = '[WAS Loader]';
  const logWas = (...args) => console.log(wasLogPrefix, ...args);
  const quickActionsLogPrefix = '[QuickActions]';
  const logQuickActions = (...args) => console.log(quickActionsLogPrefix, ...args);
  const copyPageUrlsLogPrefix = '[CopyPageUrls]';
  const logCopyPageUrls = (...args) => console.log(copyPageUrlsLogPrefix, ...args);
  const pdfInspectorLogPrefix = '[PdfInspector]';
  const logPdfInspector = (...args) => console.log(pdfInspectorLogPrefix, ...args);
  const impactApiLogPrefix = '[ImpactAPI]';
  const logImpactApi = (...args) => console.log(impactApiLogPrefix, ...args);
  let quickAssignOptionsCache = null;
  let quickAssignOptionsPromise = null;
  const pageHealthLogPrefix = '[PageHealth]';
  const logPageHealth = (...args) => console.log(pageHealthLogPrefix, ...args);
  const pageHealthFetchDelayMs = 650;
  const pageHealthPageSize = 50;
  const pageHealthMaxPagesPerScan = 400; // defensive cap so one scan cannot dominate a session
  const pageHealthSectionId = 'a11y-page-health-section';
  const pageHealthState = {
    availableScans: [],
    scanLookup: new Map(),
    selectedScanIds: new Set(),
    results: [],
    sort: { key: 'issueCountInc', direction: 'desc' },
    filterKey: 'completed',
    perScanStatus: new Map(),
    fetchStatus: 'idle',
    fetchMessage: '',
    progress: { total: 0, completed: 0, failed: 0 },
    discovery: { verified: false, sampleKeys: [], lastChecked: null, error: null },
    abortController: null,
    render: null,
    lastError: null
  };
  const pdfInspectorState = {
    status: 'idle',
    filter: { mode: 'before', start: null, end: null },
    urls: [],
    matches: [],
    failures: [],
    log: [],
    lastError: null,
    progress: { total: 0, completed: 0 },
    render: null,
    downloadPhase: 'idle',
    downloadErrorMessage: '',
    analysisFolderHandle: null,
    analysisFolderName: '',
    analysisError: '',
    analysisAbortController: null
  };
  const pdfMatchState = {
    status: 'idle',
    folderHandle: null,
    folderName: '',
    matches: [],
    unmatched: [],
    lastError: '',
    urlCount: 0,
    render: null
  };
  const pageHealthFilterOptions = [
    { key: 'completed', label: 'Completed scans' },
    { key: 'critical', label: 'Pages with Critical Issues' },
    { key: 'issues', label: 'Pages with Issues' },
    { key: 'failed', label: 'Failed Pages' }
  ];
  const pdfModifiedDateFields = [
    'ModDate',
    'CreationDate',
    'xmp:ModifyDate',
    'xmpMM:LastModifiedDate',
    'pdf:ModDate',
    'dc:date',
    'MetadataDate',
    'LastModified',
    'LastModifiedDate',
    'Modified',
    'ModifyDate',
    'ModifiedDate',
    'LastModDate',
    'LastSaveDate',
    'LastSaved',
    'LastUpdate',
    'Updated',
    'ChangeDate',
    'UpdatedDate',
    'ProducerTime',
    'TimeStamp',
    'UpdatedAt',
    'RevisionDate',
    'Modify Time',
    'Modified Time',
    'MTime',
    'UTCTime',
    'UpdateTime',
    'ChgTime',
    'FileModifyDate'
  ];

  const root = document.createElement('div');
  root.className = 'a11y-scan-report-root';

  function placeRootNearHeading() {
    const hostHeading = document.querySelector('h1');
    if (hostHeading && hostHeading.parentNode) {
      hostHeading.insertAdjacentElement('afterend', root);
      return true;
    }
    if (document.body && !root.parentNode) {
      document.body.appendChild(root);
    }
    return false;
  }

  if (!placeRootNearHeading()) {
    const onReady = () => {
      if (placeRootNearHeading()) {
        document.removeEventListener('DOMContentLoaded', onReady);
      }
    };
    document.addEventListener('DOMContentLoaded', onReady);
    const headingObserver = new MutationObserver(() => {
      if (placeRootNearHeading()) headingObserver.disconnect();
    });
    headingObserver.observe(document.documentElement || document.body, {
      childList: true,
      subtree: true
    });
  }

  // --- Styles (no helper functions!) ---
  const style = document.createElement('style');
  style.textContent = `
    :root {
      --accent-success: #a5db75;
      --accent-success-high-contrast: #4fa630;
      --accent-success-light: #d1ffa4;
      --accent-success-dark: #57a711;
      --accent-error: #d93251;
      --accent-error-active: #c92e40;
      --accent-danger-active: #fea7a6;
      --accent-danger: #fe6d6b;
      --accent-danger-light: #f7846c;
      --accent-warning: #ffdd75;
      --accent-warning-light: #ffa1a1;
      --accent-caution: #ffe69f;
      --accent-warning-dark: #b88a00;
      --accent-info: #6cdaf2;
      --accent-info-light: #83e4fa;
      --accent-info-active: #a7e9f7;
      --accent-primary: #3c7aae;
      --accent-primary-active: #316091;
      --gray-20: #e0e0e0;
      --gray-30: #c7c7c7;
      --gray-40: #adadad;
      --gray-60: #676767;
      --gray-80: #333333;
      --gray-90: #1a1a1a;
      --white: #ffffff;
      --background-light: #f0f2f5;
      --focus-light: #b51ad1;
      --metric-accent-low: var(--accent-danger-light);
      --metric-accent-mid: #8ba6c5;
      --metric-accent-full: var(--accent-success);
      --tab-focus-border: 2px;
    }

    .a11y-scan-report-root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .a11y-scan-report-root button:focus-visible,
    .a11y-scan-report-root summary:focus-visible,
    .a11y-scan-report-root [tabindex]:focus-visible {
      outline: 2px solid var(--focus-light);
      outline-offset: 3px;
      box-shadow: 0 0 0 2px rgba(215, 30, 247, .25);
    }

    .a11y-scan-report-button {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-left: 12px;
      padding: 7px 14px;
      background: var(--accent-primary);
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    .a11y-scan-report-button:hover {
      background: var(--accent-primary-active);
    }

    .a11y-scan-report-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.35);
      z-index: 2147483647;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 40px;
    }

    .a11y-scan-report-dialog {
      background: #ffffff;
      max-width: 1280px;
      width: min(96vw, 1280px);
      max-height: 88vh;
      padding: 18px 24px 14px;
      border-radius: 6px;
      box-shadow: 0 8px 28px rgba(0,0,0,0.25);
      display: flex;
      flex-direction: column;
      border: 1px solid #dcdcdc;
    }

    .a11y-scan-report-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #e5e5e5;
    }

    .a11y-scan-report-header-left {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
    }

    .a11y-header-filter-holder {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-start;
    }

    .a11y-scan-report-header h1 {
      font-size: 22px;
      font-weight: 600;
      margin: 0;
      color: #222;
    }

    .a11y-scan-report-header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .a11y-scan-report-close {
      padding: 5px 12px;
      font-size: 13px;
      cursor: pointer;
      border: 1px solid #c4c4c4;
      background: #f5f5f5;
      border-radius: 3px;
      color: #333;
    }
    .a11y-scan-report-close:hover {
      background: #e9e9e9;
    }

    .a11y-scan-report-minimize {
      padding: 5px 12px;
      font-size: 13px;
      cursor: pointer;
      border: 1px solid #c4c4c4;
      background: #ffffff;
      border-radius: 3px;
      color: #333;
    }
    .a11y-scan-report-minimize:hover {
      background: #f5f5f5;
    }

    .a11y-scan-report-settings {
      padding: 5px 12px;
      font-size: 13px;
      cursor: pointer;
      border: 1px solid #c4c4c4;
      background: #ffffff;
      border-radius: 3px;
      color: #333;
    }
    .a11y-scan-report-settings:hover {
      background: #f5f5f5;
    }

    .a11y-filter-button {
      padding: 5px 10px;
      font-size: 12px;
      border-radius: 3px;
      border: 1px solid var(--gray-30);
      background-color: #ffffff;
      color: #333;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }
    .a11y-filter-button:hover {
      background-color: #f5f5f5;
    }
    .a11y-filter-button:focus-visible,
    .a11y-table-download-btn:focus-visible,
    .a11y-filter-button:focus {
      outline: 2px solid var(--focus-light);
      outline-offset: 3px;
    }

    .a11y-page-impact-toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 8px;
    }

    .a11y-page-impact-source-toggle {
      display: inline-flex;
      flex-wrap: wrap;
      align-items: center;
      padding: 2px;
      border-radius: 999px;
      background: #f0f4f8;
      box-shadow: inset 0 0 0 1px rgba(15,23,42,0.08);
      gap: 4px;
    }

    .a11y-segment-button {
      border: none;
      border-radius: 999px;
      padding: 4px 12px;
      font-weight: 600;
      background: transparent;
      color: #475569;
      transition: background 0.12s ease, color 0.12s ease, box-shadow 0.12s ease;
    }

    .a11y-segment-button--active {
      background: #ffffff;
      color: #0f172a;
      box-shadow: 0 1px 2px rgba(15,23,42,0.18);
    }

    .a11y-scan-report-body {
      margin-top: 8px;
      padding: 2px 0 12px;
      overflow-y: auto;
      flex: 1;
      font-size: 14px;
      line-height: 1.6;
      color: #333;
    }
    .a11y-scan-report-body[tabindex="0"] {
      outline: none;
    }

    .a11y-tablist {
      display: flex;
      flex-wrap: nowrap;
      gap: 4px;
      margin-bottom: 6px;
      border-bottom: 1px solid #e0e0e0;
      padding-bottom: 4px;
      width: 100%;
      box-sizing: border-box;
      overflow-x: auto;
    }
    .a11y-tablist button {
      position: relative;
      flex: 1 1 auto;
      min-width: 120px;
      max-width: 200px;
      width: auto;
      white-space: nowrap;
      border: 1px solid #c4c4c4;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      background: #f7f7f7;
      color: #333;
      cursor: pointer;
      padding: 0;
      outline: none;
      transition: transform 0.12s ease, border-width 0.12s ease;
    }
    .a11y-tablist button[aria-selected="true"] {
      background: #fffefd;
      border-top-width: 4px;
      border-left-width: 2px;
      border-right-width: 2px;
      border-bottom: 2px solid #fffefd;
      transform: translateY(-4px);
      z-index: 2;
      color: #111;
      font-weight: 700;
      box-shadow: 0 -2px 0 var(--accent-primary) inset;
    }
    .a11y-tablist button[aria-selected="false"] {
      border-width: 1px 1px 0;
    }
    @media (max-width: 720px) {
      .a11y-tablist {
        flex-wrap: wrap;
        overflow-x: visible;
      }
    }
    .a11y-tablist button:focus-visible {
      outline: 2px solid var(--focus-light);
      outline-offset: 4px;
    }

    .a11y-tab-focus {
      display: block;
      margin: 2px;
      border: 0 solid var(--focus-light);
      border-radius: 3px;
      padding: calc(8px + var(--tab-focus-border)) 12px;
      transition: border-width 0.12s ease, padding 0.12s ease;
    }
    .a11y-tablist button:focus .a11y-tab-focus {
      border-width: var(--tab-focus-border);
      padding: 8px 12px;
    }
    .a11y-tab-label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      text-align: center;
      color: #222;
    }
    .a11y-tablist button[aria-selected="false"] .a11y-tab-label {
      font-weight: 500;
      color: #444;
    }

    .a11y-tabpanel {
      padding-top: 8px;
      width: 100%;
      box-sizing: border-box;
    }
    .a11y-tabpanel[hidden] {
      display: none;
    }

    .a11y-tabpanels {
      width: 100%;
      box-sizing: border-box;
      border-top: 1px solid #e0e0e0;
      margin-top: -1px;
    }

    .a11y-page-impact-filter-block {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }
    .a11y-page-impact-filter-block .TagButton {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .a11y-page-impact-filter-value {
      font-weight: 600;
    }
    .a11y-page-impact-options {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin: 0 16px 12px;
    }
    .a11y-page-impact-option {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 4px;
      cursor: pointer;
    }
    .a11y-page-impact-option:focus-within {
      outline: 2px solid var(--accent-primary);
      outline-offset: 2px;
      background: rgba(60, 122, 174, 0.08);
    }
    .a11y-page-impact-option input {
      width: 16px;
      height: 16px;
      margin: 0;
      flex-shrink: 0;
    }
    .a11y-page-impact-option-label {
      font-size: 14px;
      line-height: 1.2;
      color: #222;
    }

    .a11y-panel-controls {
      display: flex;
      justify-content: flex-end;
      gap: 6px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .a11y-impact-meta-chips {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      row-gap: 6px;
      margin-left: auto;
      padding-left: 8px;
      pointer-events: none;
    }

    .a11y-severity-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 10px;
      border-radius: 999px;
      line-height: 1.2;
      font-size: 12px;
      font-weight: 600;
    }

    .a11y-severity-chip .Icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .c2adf923ed89 {
      align-items: center;
      border: 1px solid #02101a;
      border-radius: 50%;
      color: #02101a;
      display: flex;
      font-size: 10px;
      font-weight: var(--font-weight-bold, 700);
      height: 22px;
      justify-content: center;
      width: 22px;
    }

    .e2de49808a35 {
      background: #ffa1a1;
    }

    .c1d7b29a41e0 {
      background: #ffe69f;
    }

    .a99bd1117bc5 {
      background: #d4dde0;
    }

    .f55e216514d1 {
      background: #f2f2f2;
    }

    .a11y-page-impact-api-chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 600;
      border: 1px solid rgba(15, 23, 42, 0.08);
      background: #f1f5f9;
      color: #475569;
      cursor: default;
      text-align: left;
    }

    .a11y-page-impact-api-chip--interactive {
      cursor: pointer;
    }

    .a11y-chip-label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .a11y-chip-indicator {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: 4px;
      width: 14px;
      height: 14px;
    }

    .a11y-chip-indicator svg {
      width: 100%;
      height: 100%;
    }

    .a11y-panel-toggle-btn {
      border: 1px solid #c4c4c4;
      background: #f5f5f5;
      color: #333;
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 12px;
      cursor: pointer;
    }
    .a11y-panel-toggle-btn:hover {
      background: #e9e9e9;
    }

    .a11y-table-sum-row th,
    .a11y-table-sum-row td {
      font-weight: 600;
      border-top: 2px solid #d0d0d0;
    }

    .a11y-link-button {
      background: none;
      border: none;
      padding: 0;
      color: var(--accent-primary);
      cursor: pointer;
      text-decoration: underline;
      font-size: 13px;
    }
    .a11y-link-button:hover {
      color: var(--accent-primary-active);
    }

    .a11y-was-actions {
      margin: 6px 0;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .a11y-was-results {
      margin-top: 6px;
    }
    .a11y-was-status {
      font-size: 12px;
      color: #555;
      margin-top: 4px;
    }
    .a11y-was-api-status {
      font-size: 12px;
      color: #444;
    }
    .a11y-was-status-note {
      font-size: 12px;
      margin-top: 2px;
      color: #5c2400;
    }

    .a11y-was-summary {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      font-weight: 600;
    }
    .a11y-was-summary strong {
      margin-right: 4px;
    }

    .a11y-quick-actions-container {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .a11y-quick-actions-intro {
      margin: 0;
      font-size: 0.95rem;
    }
    .a11y-quick-actions-note {
      font-size: 0.85rem;
      color: #4a4a4a;
      margin: 0;
    }
    .a11y-quick-actions-btn-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
    }
    .a11y-quick-actions-chip {
      background: #eef2f7;
      color: #2f3b4c;
      border-radius: 999px;
      padding: 0.2rem 0.75rem;
      font-size: 0.85rem;
    }
    .a11y-quick-actions-saved {
      margin: 0;
      padding-left: 1.25rem;
      font-size: 0.9rem;
    }
    .a11y-quick-actions-saved code {
      background: #f4f6f8;
      border-radius: 4px;
      padding: 0.1rem 0.35rem;
      display: inline-block;
      max-width: 100%;
      overflow-x: auto;
    }
    .a11y-quick-actions-select-wrap {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .a11y-quick-actions-select-wrap select {
      max-width: 320px;
    }
    .a11y-quick-actions-status {
      border: 1px solid #dfe7f3;
      border-radius: 8px;
      padding: 0.75rem;
      background: #f8fbff;
      min-height: 3rem;
    }
    .a11y-quick-actions-status ul {
      margin: 0;
      padding-left: 1.25rem;
      max-height: 220px;
      overflow-y: auto;
      font-size: 0.9rem;
    }
    .a11y-quick-actions-status li {
      margin-bottom: 0.3rem;
    }
    .a11y-quick-actions-status li[data-status="error"] {
      color: var(--accent-danger-active);
    }
    .a11y-quick-actions-status li[data-status="success"] {
      color: var(--accent-success-dark);
    }
    .a11y-copy-urls-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }
    .a11y-copy-urls-output {
      border: 1px solid #dfe7f3;
      border-radius: 6px;
      background: #fdfdff;
      padding: 0.5rem 0.65rem;
      max-height: 240px;
      overflow-y: auto;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
      font-size: 0.85rem;
      white-space: pre;
      margin-top: 0.5rem;
    }
    .a11y-copy-urls-output:focus-visible {
      outline: 2px solid var(--focus-light);
      outline-offset: 2px;
    }
    .a11y-pdf-section .a11y-quick-actions-note {
      margin-bottom: 0.25rem;
    }
    .a11y-pdf-step {
      border: 1px solid #e0e6f0;
      border-radius: 6px;
      padding: 0.6rem 0.75rem;
      margin: 0.5rem 0;
      background: #fff;
    }
    .a11y-pdf-filter {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: flex-end;
      margin: 0.5rem 0;
    }
    .a11y-pdf-filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      min-width: 180px;
    }
    .a11y-pdf-filter-group input[type="date"],
    .a11y-pdf-filter-group input[type="text"],
    .a11y-pdf-filter-group select {
      padding: 0.25rem 0.4rem;
      border: 1px solid #cfd5df;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    .a11y-pdf-status {
      border: 1px solid #e0e6f0;
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      background: #f8fbff;
      margin: 0.5rem 0;
      font-size: 0.9rem;
    }
    .a11y-pdf-progress {
      font-weight: 600;
    }
    .a11y-pdf-log {
      max-height: 160px;
      overflow-y: auto;
      margin: 0.5rem 0;
      padding-left: 1rem;
    }
    .a11y-pdf-log li[data-status="error"] {
      color: var(--accent-danger-active);
    }
    .a11y-pdf-log li[data-status="success"] {
      color: var(--accent-success-dark);
    }
    .a11y-pdf-results {
      margin-top: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }
    .a11y-pdf-results h3 {
      margin: 0 0 0.25rem;
      font-size: 1rem;
    }
    .a11y-pdf-results .a11y-pdf-table-wrap {
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 0.4rem;
      background: #fff;
      max-height: 240px;
      overflow-y: auto;
    }
    .a11y-pdf-table {
      width: 100%;
      border-collapse: collapse;
    }
    .a11y-pdf-table th,
    .a11y-pdf-table td {
      border: 1px solid #e0e0e0;
      padding: 4px 6px;
      text-align: left;
      font-size: 0.85rem;
      word-break: break-word;
    }
    .a11y-pdf-warning {
      color: #8c2f00;
      font-size: 0.85rem;
    }
    .a11y-quick-actions-summary {
      margin-top: 0.45rem;
      font-weight: 600;
      font-size: 0.9rem;
    }
    .a11y-quick-actions-log summary .a11y-quick-actions-summary {
      margin-top: 0;
    }
    .a11y-quick-actions-log {
      border: 1px solid #dfe7f3;
      border-radius: 8px;
      padding: 0.4rem 0.65rem;
      background: #ffffff;
    }
    .a11y-quick-actions-log summary {
      cursor: pointer;
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 0.75rem;
      list-style: none;
    }
    .a11y-quick-actions-log summary::-webkit-details-marker {
      display: none;
    }
    .a11y-quick-actions-confirm {
      border: 1px solid #f4c542;
      background: #fff8e5;
      border-radius: 8px;
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .a11y-quick-actions-confirm-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .a11y-quick-actions-confirm button {
      min-width: 120px;
    }
    .a11y-page-health-body {
      display: flex;
      flex-direction: column;
      gap: 0.85rem;
      margin-top: 0.5rem;
    }
    .a11y-page-health-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }
    .a11y-page-health-progress {
      font-size: 0.85rem;
      color: #4a4a4a;
    }
    .a11y-page-health-selection {
      border: 1px solid #dfe7f3;
      border-radius: 8px;
      padding: 0.65rem 0.9rem;
      background: #f9fbfe;
    }
    .a11y-page-health-selection ul {
      margin: 0.35rem 0 0;
      padding-left: 1.25rem;
    }
    .a11y-page-health-selection code {
      background: #eef2f7;
      border-radius: 4px;
      padding: 0.05rem 0.3rem;
      margin-right: 0.35rem;
    }
    .a11y-page-health-filter {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .a11y-page-health-filter select {
      min-width: 220px;
    }
    .a11y-page-health-status {
      border: 1px solid #e0e6f0;
      border-radius: 8px;
      padding: 0.75rem;
      background: #fff;
    }
    .a11y-page-health-status ul {
      margin: 0;
      padding-left: 1.25rem;
      max-height: 220px;
      overflow-y: auto;
    }
    .a11y-page-health-status li {
      margin-bottom: 0.35rem;
    }
    .a11y-page-health-status li[data-status="error"] {
      color: var(--accent-danger-active);
    }
    .a11y-page-health-status li[data-status="success"] {
      color: var(--accent-success-dark);
    }
    .a11y-page-health-results {
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      padding: 0.5rem;
      background: #fff;
    }
    .a11y-page-health-sort {
      border: none;
      background: none;
      padding: 0;
      font: inherit;
      color: var(--accent-primary);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .a11y-page-health-sort::after {
      content: '';
      border: 4px solid transparent;
      border-top-color: currentColor;
      opacity: 0.45;
      transform: translateY(2px);
    }
    .a11y-page-health-sort[data-sort-direction="asc"]::after {
      transform: rotate(180deg);
    }
    .a11y-page-health-sort:focus-visible {
      outline: 2px solid var(--focus-light);
      outline-offset: 2px;
    }
    .a11y-page-link-inline {
      font-size: 0.85rem;
      word-break: break-all;
    }
    .a11y-page-health-picker {
      max-width: 740px;
    }
    .a11y-page-health-picker-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    .a11y-page-health-picker-search {
      flex: 1 1 240px;
      padding: 0.35rem 0.5rem;
      border: 1px solid #cfd5df;
      border-radius: 4px;
    }
    .a11y-page-health-picker-counts {
      font-size: 0.85rem;
      color: #4a4a4a;
    }
    .a11y-page-health-picker-list {
      max-height: 360px;
      overflow-y: auto;
      border: 1px solid #dfe3ec;
      border-radius: 6px;
      padding: 0.4rem;
      background: #fff;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .a11y-page-health-picker-row {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 0.5rem;
      padding: 0.4rem;
      border-radius: 4px;
      border: 1px solid transparent;
      cursor: pointer;
    }
    .a11y-page-health-picker-row:hover {
      border-color: var(--accent-primary);
      background: #f5f9ff;
    }
    .a11y-page-health-picker-row input {
      margin-top: 0.3rem;
    }
    .a11y-page-health-picker-title {
      grid-column: 2 / -1;
      font-weight: 600;
    }
    .a11y-page-health-picker-meta {
      grid-column: 2 / -1;
      font-size: 0.8rem;
      color: #4a4a4a;
    }
    .a11y-page-health-picker-empty {
      margin: 0;
      font-size: 0.9rem;
      color: #555;
    }
    .a11y-pages-editor {
      display: flex;
      border: 1px solid var(--gray-30);
      border-radius: 8px;
      overflow: hidden;
      background: #fafbfd;
    }
    .a11y-pages-editor-gutter {
      background: #eff2f5;
      color: #555;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
      font-size: 0.8rem;
      padding: 0.65rem 0.6rem 0.65rem 0.75rem;
      text-align: right;
      user-select: none;
    }
    .a11y-pages-editor-input {
      flex: 1 1 auto;
      border: 0;
      padding: 0.65rem 0.75rem;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
      font-size: 0.85rem;
      min-height: 220px;
      resize: vertical;
      white-space: pre;
      background: transparent;
    }
    .a11y-pages-editor-input:focus {
      outline: 2px solid var(--accent-primary);
      outline-offset: -2px;
    }
    .a11y-quick-actions-error {
      color: var(--accent-danger);
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }
    .a11y-quick-actions-error ul {
      margin: 0.25rem 0 0;
      padding-left: 1.25rem;
    }
    .a11y-assign-pages-dialog {
      max-width: 640px;
    }

    .a11y-was-edit-btn {
      border: 1px solid #c4c4c4;
      background: #f5f5f5;
      border-radius: 4px;
      padding: 4px 8px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
    }
    .a11y-was-edit-btn:hover {
      background: #e9e9e9;
    }

    .a11y-was-config-dialog .a11y-scan-report-table th[scope='row'] {
      min-width: 280px;
    }

    .a11y-was-config-select-all {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 8px 0 4px;
      font-weight: 600;
    }

    .a11y-was-config-select {
      min-width: 180px;
    }

    .a11y-scan-report-body details {
      margin-bottom: 12px;
      padding: 12px 18px 14px;
      border-radius: 4px;
      border: 1px solid #e5e5e5;
      background-color: #fafafa;
    }

    .a11y-scan-report-body details > *:not(summary) {
      margin-left: 18px;
    }

    .a11y-scan-report-body summary {
      display: flex;
      align-items: center;
      cursor: pointer;
      list-style: none;
      padding: 4px 4px 4px;
    }
    .a11y-scan-report-body summary::-webkit-details-marker {
      display: none;
    }
    .a11y-scan-report-body summary::before {
      content: "▸";
      font-size: 16px;
      color: #555;
      margin-right: 8px;
    }
    .a11y-scan-report-body details[open] summary::before {
      content: "▾";
    }

    .a11y-scan-report-body summary h2 {
      margin: 0;
      font-size: 17px;
      font-weight: 600;
      color: var(--accent-primary);
    }

    .a11y-scan-report-body h3 {
      font-size: 15px;
      margin: 8px 0 4px;
      font-weight: 600;
      color: #333;
    }

    .a11y-scan-report-table {
      border-collapse: collapse;
      margin: 4px 0 6px;
      width: 100%;
      max-width: 100%;
      background-color: #fff;
      table-layout: auto;
    }
    .a11y-scan-report-table th,
    .a11y-scan-report-table td {
      border: 1px solid #e0e0e0;
      padding: 4px 7px;
      text-align: left;
      font-size: 13px;
      white-space: normal;
      word-break: break-word;
    }
    .a11y-scan-report-table th {
      background-color: #f2f2f2;
      font-weight: 600;
      color: #222;
    }

    .a11y-table-container {
      width: 100%;
      overflow-x: auto;
      margin: 4px 0 8px;
    }
    .a11y-table-toolbar {
      display: flex;
      justify-content: flex-end;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 4px;
    }
    .a11y-table-download-btn {
      padding: 3px 8px;
      font-size: 12px;
      border-radius: 3px;
      border: 1px solid #c4c4c4;
      background: #f5f5f5;
      color: #333;
      cursor: pointer;
    }
    .a11y-table-download-btn:hover {
      background: #e9e9e9;
    }

    .a11y-scan-report-restore {
      position: fixed;
      right: 18px;
      bottom: 18px;
      z-index: 2147483648;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      border-radius: 999px;
      border: 1px solid #c4c4c4;
      background: #ffffff;
      box-shadow: 0 6px 18px rgba(0,0,0,0.15);
      cursor: pointer;
      font-size: 13px;
      color: #222;
    }
    .a11y-scan-report-restore:hover {
      background: #f5f5f5;
    }
    .a11y-scan-report-restore:focus-visible {
      outline: 2px solid var(--focus-light);
      outline-offset: 3px;
    }

    .a11y-scan-link {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      color: var(--accent-primary);
    }
    .a11y-scan-link svg {
      width: 14px;
      height: 14px;
    }
    .a11y-scan-link .sr-only {
      position: absolute;
      left: -9999px;
    }

    .a11y-scan-report-footer {
      border-top: 1px solid #e5e5e5;
      padding: 8px 0 0;
      margin-top: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .a11y-scan-report-refresh-info {
      font-size: 12px;
      color: #444;
    }

    .a11y-refresh-status-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      min-height: 32px;
    }

    .a11y-footer-chip-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .a11y-scan-report-refresh-btn {
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 3px;
      border: 1px solid #c4c4c4;
      background: #f5f5f5;
      color: #333;
    }
    .a11y-scan-report-refresh-btn:hover {
      background: #e9e9e9;
    }

    .Dialog__close {
      border: none;
      background: transparent;
      cursor: pointer;
      padding: 2px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .Dialog__close .Offscreen {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0,0,0,0);
      white-space: nowrap;
      border: 0;
    }

    .a11y-impact-bar-wrap {
      position: relative;
      padding: 1px 4px;
      min-width: 80px;
      box-sizing: border-box;
    }
    .a11y-impact-bar {
      position: absolute;
      left: 0;
      top: 2px;
      bottom: 2px;
      border-radius: 2px;
      opacity: 0.35;
      pointer-events: none;
    }
    .a11y-impact-bar-wrap span {
      position: relative;
      z-index: 1;
      font-weight: 500;
      color: #222;
    }

    /* Filters dialog */
    .a11y-filter-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      z-index: 2147483649;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding-top: 80px;
    }

    .a11y-filter-dialog {
      background: #fff;
      width: 420px;
      max-width: 95%;
      max-height: 70vh;
      border-radius: 4px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.3);
      padding: 14px 16px 10px;
      display: flex;
      flex-direction: column;
      border: 1px solid #dcdcdc;
      box-sizing: border-box;
      color: #333;
      margin-left: 8px; /* nudge in from left */
    }
    .a11y-filter-dialog * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .a11y-filter-dialog.a11y-was-config-dialog {
      width: min(96vw, 1280px);
      max-width: 1280px;
      max-height: 88vh;
      padding: 18px 24px 14px;
    }

    .a11y-ranking-dialog {
      width: 640px;
      max-width: min(720px, 95vw);
      max-height: 80vh;
    }

    .a11y-ranking-content {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .a11y-ranking-chip-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .a11y-ranking-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 12px;
      border-radius: 999px;
      background: #f1f5f9;
      color: #0f172a;
      border: 1px solid rgba(15, 23, 42, 0.1);
      font-size: 12px;
      font-weight: 600;
    }

    .a11y-ranking-chip--alert {
      background: #fef2f2;
      border-color: #f87171;
      color: #b91c1c;
    }

    .a11y-ranking-chip-label {
      text-transform: uppercase;
      letter-spacing: 0.03em;
      font-size: 11px;
    }

    .a11y-ranking-chip-value {
      font-size: 13px;
    }

    .a11y-ranking-rows {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .a11y-ranking-row {
      border: 1px solid #dbe4f0;
      border-radius: 8px;
      padding: 10px;
      background: #fff;
    }

    .a11y-ranking-row--error {
      border-color: #f87171;
      box-shadow: 0 0 0 1px rgba(248, 113, 113, 0.4);
    }

    .a11y-ranking-row-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      gap: 8px;
    }

    .a11y-ranking-row-label {
      font-weight: 600;
      color: #0f172a;
    }

    .a11y-ranking-row-remove {
      border: none;
      background: transparent;
      color: #b91c1c;
      font-size: 12px;
      cursor: pointer;
    }
    .a11y-ranking-row-remove:disabled {
      color: #94a3b8;
      cursor: not-allowed;
    }

    .a11y-ranking-row-select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #cbd5f5;
      font-size: 13px;
      background: #fff;
    }

    .a11y-ranking-row-select:focus {
      outline: 2px solid var(--accent-primary);
      outline-offset: 2px;
    }

    .a11y-ranking-row-hint {
      font-size: 12px;
      color: #475569;
      margin-top: 4px;
    }

    .a11y-ranking-row-error {
      font-size: 12px;
      color: #b91c1c;
      margin-top: 4px;
      min-height: 16px;
    }

    .a11y-ranking-inline-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }

    .a11y-ranking-error-summary {
      font-size: 13px;
      color: #b91c1c;
    }

    .a11y-panel-controls > .a11y-ranking-control {
      margin-right: auto;
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: flex-start;
    }

    .a11y-ranking-trigger {
      font-size: 12px;
    }

    .a11y-ranking-summary {
      font-size: 12px;
      color: #475569;
    }

    .a11y-ranking-summary--warning {
      color: #b45309;
      font-weight: 600;
    }

    .a11y-scans-dialog {
      width: min(1024px, 96vw);
      max-width: 96vw;
      max-height: 80vh;
    }
    .a11y-scans-dialog-content {
      overflow: auto;
      padding-right: 0;
    }
    .a11y-scans-dialog .a11y-scan-report-table {
      width: 100%;
      max-width: none;
    }

    .a11y-filter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      padding-bottom: 6px;
      border-bottom: 1px solid #e5e5e5;
    }
    .a11y-filter-header h2 {
      font-size: 20px;
      margin: 0;
      font-weight: 600;
      color: #111;
    }

    .a11y-filter-close {
      border: none;
      background: transparent;
      cursor: pointer;
      padding: 2px 4px;
      font-size: 20px;
      line-height: 1;
      color: #333;
    }

    .a11y-filter-content {
      margin-top: 8px;
      overflow-y: auto;
      flex: 1;
      font-size: 13px;
      padding-right: 4px;
    }

    .a11y-filter-fieldset {
      border: none;
      padding: 0;
      margin: 0 0 10px;
    }

    .a11y-filter-legend {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 15px;
      color: #222;
    }

    .a11y-filter-checkbox-wrap {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 2px 0;
    }
    .a11y-filter-checkbox-wrap input[type="checkbox"] {
      margin: 0;
      width: 16px;
      height: 16px;
      flex: 0 0 auto;
    }
    .a11y-filter-checkbox-wrap label {
      flex: 1 1 auto;
      text-align: left;
      white-space: normal;
    }

    .a11y-filter-domain-details,
    .a11y-filter-type-details,
    .a11y-filter-status-details {
      border: 1px solid #e5e5e5;
      border-radius: 3px;
      padding: 4px 6px 6px;
      margin-bottom: 10px;
      background-color: #fafafa;
    }

    .a11y-filter-domain-details summary,
    .a11y-filter-type-details summary,
    .a11y-filter-status-details summary {
      list-style: none;
      cursor: pointer;
      padding: 2px 0;
      display: flex;
      align-items: center;
      font-weight: 600;
      font-size: 15px;
      color: #222;
    }
    .a11y-filter-domain-details summary::-webkit-details-marker,
    .a11y-filter-type-details summary::-webkit-details-marker,
    .a11y-filter-status-details summary::-webkit-details-marker {
      display: none;
    }
    .a11y-filter-domain-details summary::before,
    .a11y-filter-type-details summary::before,
    .a11y-filter-status-details summary::before {
      content: "▸";
      font-size: 11px;
      margin-right: 4px;
    }
    .a11y-filter-domain-details[open] summary::before,
    .a11y-filter-type-details[open] summary::before,
    .a11y-filter-status-details[open] summary::before {
      content: "▾";
    }

    .a11y-filter-domain-special {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px solid #e0e0e0;
    }

    .a11y-filter-domain-groups {
      margin-top: 8px;
    }

    .a11y-filter-domain-group {
      margin-bottom: 8px;
    }

    .a11y-filter-checkbox-parent {
      font-weight: 600;
    }

    .a11y-filter-domain-children {
      margin-left: 22px;
      padding-left: 10px;
      border-left: 1px solid #e0e0e0;
    }

    .a11y-filter-checkbox-parent input[type="checkbox"]:indeterminate {
      background-color: var(--accent-warning);
      border-color: var(--accent-warning-dark);
    }

    .a11y-btn-reset {
      padding: 3px 8px;
      border-radius: 3px;
      border: 1px solid #d0d0d0;
      background: #ffffff;
      color: #444;
      font-size: 11px;
      cursor: pointer;
      margin-top: 4px;
    }
    .a11y-btn-reset:hover {
      background: #f5f5f5;
    }

    .a11y-filter-footer {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      padding-top: 6px;
      border-top: 1px solid #e5e5e5;
      margin-top: 6px;
    }

    .a11y-btn-primary {
      padding: 4px 10px;
      border-radius: 3px;
      border: none;
      background: var(--accent-primary);
      color: #fff;
      font-size: 12px;
      cursor: pointer;
    }
    .a11y-btn-primary:hover {
      background: var(--accent-primary-active);
    }

    .a11y-btn-primary:disabled,
    .a11y-btn-secondary:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      background: #d7d7d7;
      color: #666;
      box-shadow: none;
    }

    .a11y-btn-secondary {
      padding: 4px 10px;
      border-radius: 3px;
      border: 1px solid #c4c4c4;
      background: #f5f5f5;
      color: #333;
      font-size: 12px;
      cursor: pointer;
    }
    .a11y-btn-secondary:hover {
      background: #e9e9e9;
    }

    .sr-only,
    .Offscreen {
      border: 0;
      clip: rect(0 0 0 0);
      height: 1px;
      margin: -1px;
      overflow: hidden;
      padding: 0;
      position: absolute;
      width: 1px;
    }
  `;
  document.head.appendChild(style);

  // --- Helpers ---

  function findScansTable() {
    const tables = Array.from(document.querySelectorAll('table'));
    for (const table of tables) {
      const caption = table.querySelector('caption');
      if (caption && /Scans, Accessibility Issues and Accessibility Scores/i.test(caption.textContent)) {
        return table;
      }
      const heads = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent.trim().toLowerCase());
      if (heads.includes('scan name') && heads.includes('score') && heads.includes('status')) {
        return table;
      }
    }
    return null;
  }

  function getColIndex(headers, label) {
    const lower = label.toLowerCase();
    return headers.findIndex(th =>
      th.textContent.trim().toLowerCase().startsWith(lower)
    );
  }

  function parseNum(text) {
    if (!text) return 0;
    const cleaned = String(text).replace(/,/g, '');
    const m = cleaned.match(/-?\d+/);
    return m ? parseInt(m[0], 10) : 0;
  }

  function coerceNumber(value, fallback = 0) {
    if (typeof value === 'number' && Number.isFinite(value)) return value;
    if (typeof value === 'string' && value.trim()) {
      const parsed = parseFloat(value.replace(/,/g, ''));
      if (!Number.isNaN(parsed)) return parsed;
    }
    return fallback;
  }

  function getStoredMonitorApiKey() {
    if (cachedMonitorApiKey != null) return cachedMonitorApiKey;
    try {
      cachedMonitorApiKey = localStorage?.getItem(monitorApiKeyStorageKey) || '';
    } catch (err) {
      cachedMonitorApiKey = '';
    }
    return cachedMonitorApiKey;
  }

  function setStoredMonitorApiKey(value) {
    cachedMonitorApiKey = (value || '').trim();
    try {
      const storage = localStorage;
      if (!storage) return;
      if (cachedMonitorApiKey) {
        storage.setItem(monitorApiKeyStorageKey, cachedMonitorApiKey);
      } else {
        storage.removeItem(monitorApiKeyStorageKey);
      }
    } catch (err) {
      // ignore storage errors
    }
    try {
      document.dispatchEvent(new CustomEvent('a11y-monitor-api-key-changed', {
        detail: { value: cachedMonitorApiKey }
      }));
    } catch (err) {
      // ignore event errors
    }
  }

  function ensureMonitorApiKey() {
    const key = getStoredMonitorApiKey();
    if (!key) throw new Error('Deque Monitor API key not set.');
    return key;
  }

  function extractScanIdFromUrl(url) {
    if (!url) return null;
    try {
      const u = new URL(url, location.origin);
      const match = u.pathname.match(/\/scans\/(\d+)/i);
      if (match) return match[1];
    } catch (err) {
      // ignore
    }
    const fallback = String(url).match(/scans\/(\d+)/i);
    return fallback ? fallback[1] : null;
  }

  async function fetchWasApi(path, { signal } = {}) {
    const apiKey = ensureMonitorApiKey();
    const url = `${wasApiBaseUrl}${path}`;
    const res = await fetch(url, {
      method: 'GET',
      headers: {
        'X-API-Key': apiKey,
        'Accept': 'application/json'
      },
      credentials: 'include',
      signal
    });
    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`API ${res.status}: ${text || res.statusText}`);
    }
    return res.json();
  }

  function getRunsArray(payload) {
    if (!payload) return [];
    if (Array.isArray(payload)) return payload;
    if (Array.isArray(payload?.runs)) return payload.runs;
    if (Array.isArray(payload?.scanRuns)) return payload.scanRuns;
    if (Array.isArray(payload?.data)) return payload.data;
    return [];
  }

  function selectLatestRun(runs) {
    if (!runs || !runs.length) return null;
    return runs.reduce((best, run) => {
      if (!best) return run;
      const bestNumber = coerceNumber(best.runNumber ?? best.run ?? best.id ?? 0, 0);
      const runNumber = coerceNumber(run.runNumber ?? run.run ?? run.id ?? 0, 0);
      if (runNumber > bestNumber) return run;
      return best;
    }, null);
  }

  function normalizeKeyFragment(value) {
    return String(value || '').toLowerCase().replace(/[^a-z0-9]+/g, '');
  }

  function getNumericCountValue(value) {
    const num = coerceNumber(value, Number.NaN);
    if (Number.isNaN(num)) return null;
    if (num < 0) return 0;
    return num;
  }

  function matchPageCountEntry(entry, severityKey) {
    if (!entry || typeof entry !== 'object') return null;
    const labelSource =
      entry.impact ??
      entry.severity ??
      entry.level ??
      entry.type ??
      entry.label ??
      entry.name ??
      entry.title ??
      null;
    if (!labelSource) return null;
    const normalizedLabel = normalizeKeyFragment(labelSource);
    if (!normalizedLabel.includes(severityKey)) return null;
    const value =
      entry.count ??
      entry.value ??
      entry.total ??
      entry.pages ??
      entry.number ??
      entry.quantity ??
      entry.pageCount ??
      null;
    return getNumericCountValue(value);
  }

  function findPageImpactCountInNode(node, severityKey, visited) {
    if (!node || typeof node !== 'object') return null;
    if (!visited) visited = new WeakSet();
    if (visited.has(node)) return null;
    visited.add(node);

    if (!Array.isArray(node)) {
      const directValue = getNumericCountValue(node[severityKey]);
      if (directValue != null) return directValue;
    }

    if (Array.isArray(node)) {
      for (const item of node) {
        const labeled = matchPageCountEntry(item, severityKey);
        if (labeled != null) return labeled;
        const nested = findPageImpactCountInNode(item, severityKey, visited);
        if (nested != null) return nested;
      }
      return null;
    }

    for (const [key, value] of Object.entries(node)) {
      const normalizedKey = normalizeKeyFragment(key);
      const numeric = getNumericCountValue(value);
      if (numeric != null) {
        if (
          normalizedKey === severityKey ||
          (normalizedKey.includes(severityKey) &&
            (normalizedKey.includes('page') ||
             normalizedKey.includes('issue') ||
             normalizedKey.includes('count') ||
             normalizedKey.includes('impact')))
        ) {
          return numeric;
        }
      }
    }

    for (const value of Object.values(node)) {
      if (!value || typeof value !== 'object') continue;
      const labeled = matchPageCountEntry(value, severityKey);
      if (labeled != null) return labeled;
      const nested = findPageImpactCountInNode(value, severityKey, visited);
      if (nested != null) return nested;
    }

    return null;
  }

  function extractPageImpactCountFromMetrics(pages, severity) {
    if (!severity) return null;
    if (!pages || typeof pages !== 'object') return null;
    const severityKey = normalizeKeyFragment(severity);
    if (!severityKey) return null;
    const count = findPageImpactCountInNode(pages, severityKey, new WeakSet());
    return Number.isFinite(count) ? count : null;
  }

  async function fetchRunMetricsForRow(row, { signal } = {}) {
    if (!row) throw new Error('Scan not found.');
    const scanId = extractScanIdFromUrl(row.url || row.scanUrl || '');
    if (!scanId) throw new Error('Unable to determine scan ID.');
    const payload = await fetchWasApi(`/scans/${scanId}/runs?needsReview=false`, { signal });
    const runs = getRunsArray(payload);
    if (!runs.length) {
      throw new Error('No runs found for scan.');
    }
    const latest = selectLatestRun(runs);
    if (!latest) throw new Error('Unable to select latest run.');
    const issues = latest.issues || {};
    const pages = latest.pages || {};
    return {
      critical: coerceNumber(issues.critical ?? issues['impactCritical'] ?? issues['impact3'], 0),
      serious: coerceNumber(issues.serious ?? issues['impactSerious'] ?? issues['impact2'], 0),
      moderate: coerceNumber(issues.moderate ?? issues['impactModerate'] ?? issues['impact1'], 0),
      minor: coerceNumber(issues.minor ?? issues['impactMinor'] ?? issues['impact0'], 0),
      needsReview: coerceNumber(issues.needsReview ?? issues['needs_review'] ?? issues['needs-review'], 0),
  pagesCritical: extractPageImpactCountFromMetrics(pages, 'critical'),
  pagesSerious: extractPageImpactCountFromMetrics(pages, 'serious'),
  pagesModerate: extractPageImpactCountFromMetrics(pages, 'moderate'),
  pagesMinor: extractPageImpactCountFromMetrics(pages, 'minor'),
      run: latest,
      runNumber: coerceNumber(latest.runNumber ?? latest.run ?? latest.id, null),
      status: typeof latest.status === 'string' ? latest.status : ''
    };
  }

  function detectSortMeta(headers, columnIndexes) {
    if (!headers || !headers.length) {
      return { index: 0, direction: 'asc', field: 'name', type: 'text', label: '' };
    }
    let sortIdx = headers.findIndex(th => {
      const ariaSort = (th.getAttribute('aria-sort') || '').toLowerCase();
      return ariaSort === 'ascending' || ariaSort === 'descending';
    });
    let direction = 'asc';
    if (sortIdx !== -1) {
      const ariaSort = (headers[sortIdx].getAttribute('aria-sort') || '').toLowerCase();
      direction = ariaSort === 'descending' ? 'desc' : 'asc';
    } else {
      sortIdx = 0;
    }
    if (sortIdx < 0) sortIdx = 0;
    if (sortIdx >= headers.length) sortIdx = headers.length - 1;

    const label = headers[sortIdx]?.textContent?.trim().toLowerCase() || '';
    const {
      nameIdx,
      scoreIdx,
      statusIdx,
      lastRunIdx,
      criticalIdx,
      seriousIdx,
      totalIdx
    } = columnIndexes;

    const field =
      sortIdx === nameIdx ? 'name' :
      sortIdx === scoreIdx ? 'scoreVal' :
      sortIdx === statusIdx ? 'statusText' :
      sortIdx === lastRunIdx ? 'lastRun' :
      sortIdx === criticalIdx ? 'crit' :
      sortIdx === seriousIdx ? 'serious' :
      sortIdx === totalIdx ? 'total' :
      null;

    let type = 'text';
    if (field === 'scoreVal' || field === 'crit' || field === 'serious' || field === 'total') {
      type = 'number';
    } else if (field === 'lastRun') {
      type = 'date';
    } else if (/score|critical|serious|total|issue|percent|impact|number|count/.test(label)) {
      type = 'number';
    } else if (/date|time|run/.test(label)) {
      type = 'date';
    }

    return { index: sortIdx, direction, field, type, label };
  }

  function getRowSortComparable(meta, rowData, cells) {
    if (!meta) return rowData.originalIndex;
    switch (meta.field) {
      case 'name':
        return (rowData.name || '').toLowerCase();
      case 'scoreVal':
        return Number.isFinite(rowData.scoreVal) ? rowData.scoreVal : null;
      case 'statusText':
        return (rowData.statusText || '').toLowerCase();
      case 'lastRun':
        return rowData.lastRun ? rowData.lastRun.getTime() : null;
      case 'crit':
        return typeof rowData.crit === 'number' ? rowData.crit : null;
      case 'serious':
        return typeof rowData.serious === 'number' ? rowData.serious : null;
      case 'total':
        return typeof rowData.total === 'number' ? rowData.total : null;
      default: {
        if (!cells || typeof meta.index !== 'number') return rowData.originalIndex;
        const cell = cells[meta.index];
        if (!cell) return rowData.originalIndex;
        const text = cell.textContent.trim();
        if (meta.type === 'number') {
          const num = parseFloat(text.replace(/[^0-9.+-]+/g, ''));
          return Number.isNaN(num) ? null : num;
        }
        if (meta.type === 'date') {
          const timeEl = cell.querySelector('time');
          const dtAttr = timeEl?.getAttribute('datetime');
          const raw = dtAttr || text;
          const ts = raw ? Date.parse(raw) : NaN;
          return Number.isNaN(ts) ? null : ts;
        }
        return text.toLowerCase();
      }
    }
  }

  function initImpactBuckets(order) {
    const bucket = {};
    order.forEach(label => { bucket[label] = 0; });
    return bucket;
  }

  function getImpactBandIssues(n) {
    if (n === 0) return '0';
    if (n <= 25) return '1-25';
    if (n <= 50) return '26-50';
    if (n <= 100) return '51-100';
    if (n <= 250) return '101-250';
    if (n <= 500) return '251-500';
    return '>500';
  }

  function getImpactBandPages(n) {
    if (n <= 0) return '0 pages';
    if (n === 1) return '1 page';
    if (n <= 5) return '2-5 pages';
    if (n <= 10) return '6-10 pages';
    if (n <= 25) return '11-25 pages';
    if (n <= 50) return '26-50 pages';
    if (n <= 100) return '51-100 pages';
    if (n <= 250) return '101-250 pages';
    if (n <= 500) return '251-500 pages';
    if (n <= 1000) return '501-1000 pages';
    return '>1000 pages';
  }

  function getActiveViewMode() {
    const checked = document.querySelector('.Radio--inline input[name="view"]:checked');
    const value = (checked?.value || '').toLowerCase();
    return value === 'pages' ? 'pages' : 'issues';
  }

  function getViewInputs() {
    return Array.from(document.querySelectorAll('.Radio--inline input[name="view"]'));
  }

  async function ensureViewMode(mode) {
    const normalized = mode === 'pages' ? 'pages' : 'issues';
    const current = getActiveViewMode();
    if (current === normalized) return;
    const inputs = getViewInputs();
    const target = inputs.find(input => (input.value || '').toLowerCase() === normalized);
    if (!target) return;
    await performTableUpdate(() => triggerClick(target));
  }

  function getActivePanelElement(container) {
    if (!container) return null;
    if (container.classList && container.classList.contains('a11y-tabpanel') && !container.hasAttribute('hidden')) {
      return container;
    }
    if (container.matches && container.matches('.a11y-tabpanel:not([hidden])')) {
      return container;
    }
    if (container.querySelector) {
      return container.querySelector('.a11y-tabpanel:not([hidden])');
    }
    return null;
  }

  function getRowCritical(row) {
    return Number.isFinite(row?.crit) ? row.crit : 0;
  }

  function getRowSerious(row) {
    return Number.isFinite(row?.serious) ? row.serious : 0;
  }

  function getRowTotalIssues(row) {
    if (getPageImpactSource() === 'api') {
      const counts = getIssueImpactCounts(row);
      let total = counts.critical + counts.serious;
      if (hasIssueImpactValue(row, 'moderate')) total += counts.moderate;
      if (hasIssueImpactValue(row, 'minor')) total += counts.minor;
      return total;
    }
    if (Number.isFinite(row?.total)) return row.total;
    return getRowCritical(row) + getRowSerious(row);
  }

  // Issue impact counts (per-scan issues, not pages)
  function getIssueImpactCounts(row) {
    const getValue = value => Math.max(0, coerceNumber(value, 0));
    const pick = (target, key) => (target && target[key] != null) ? target[key] : 0;
    if (getPageImpactSource() === 'api') {
      const record = getPageImpactApiRecord(row);
      if (record && record.issues) {
        return {
          critical: getValue(record.issues.critical),
          serious: getValue(record.issues.serious),
          moderate: getValue(record.issues.moderate),
          minor: getValue(record.issues.minor)
        };
      }
    }
    return {
      critical: getValue(pick(row, 'crit')),
      serious: getValue(pick(row, 'serious')),
      moderate: getValue(pick(row, 'moderate')),
      minor: getValue(pick(row, 'minor'))
    };
  }

  function requiresMonitorApiImpact(key) {
    return monitorApiOnlyImpactKeys.has(key);
  }

  function hasIssueImpactValue(row, key) {
    if (!requiresMonitorApiImpact(key)) return true;
    if (getPageImpactSource() !== 'api') return false;
    const record = getPageImpactApiRecord(row);
    if (!record || !record.issues) return false;
    return Number.isFinite(record.issues[key]);
  }

  function getFilteredIssueImpactCounts(row) {
    const counts = getIssueImpactCounts(row);
    const active = getActivePageImpactSet();
    return {
      critical: active.has('critical') ? counts.critical : 0,
      serious: active.has('serious') ? counts.serious : 0,
      moderate: active.has('moderate') ? counts.moderate : 0,
      minor: active.has('minor') ? counts.minor : 0
    };
  }

  function getIssueTotal(row) {
    const c = getFilteredIssueImpactCounts(row);
    return c.critical + c.serious + c.moderate + c.minor;
  }

  function getWebsitePageImpactCounts(row) {
    const getValue = value => Math.max(0, coerceNumber(value, 0));
    const pick = (target, keys) => {
      for (const key of keys) {
        if (target && target[key] != null) return target[key];
      }
      return 0;
    };
    return {
      critical: getValue(pick(row, ['pageCritical','criticalPages','crit','criticalIssues','critical'])),
      serious: getValue(pick(row, ['pageSerious','seriousPages','seriousIssues','serious'])),
      moderate: getValue(pick(row, ['pageModerate','moderatePages','moderateIssues','moderate'])),
      minor: getValue(pick(row, ['pageMinor','minorPages','minorIssues','minor']))
    };
  }

  function normalizePageImpactValue(value) {
    if (value == null) return null;
    const numeric = coerceNumber(value, Number.NaN);
    if (Number.isNaN(numeric)) return null;
    return Math.max(0, numeric);
  }

  function getPageImpactCounts(row) {
    const websiteCounts = getWebsitePageImpactCounts(row);
    if (getPageImpactSourceForView() === 'api') {
      const record = getPageImpactApiRecord(row);
      if (record && record.pages) {
        return {
          critical: normalizePageImpactValue(record.pages.critical) ?? websiteCounts.critical,
          serious: normalizePageImpactValue(record.pages.serious) ?? websiteCounts.serious,
          moderate: normalizePageImpactValue(record.pages.moderate) ?? websiteCounts.moderate,
          minor: normalizePageImpactValue(record.pages.minor) ?? websiteCounts.minor
        };
      }
    }
    return websiteCounts;
  }

  function getFilteredPageImpactCounts(row) {
    const counts = getPageImpactCounts(row);
    const active = getActivePageImpactSet();
    return {
      critical: active.has('critical') ? counts.critical : 0,
      serious: active.has('serious') ? counts.serious : 0,
      moderate: active.has('moderate') ? counts.moderate : 0,
      minor: active.has('minor') ? counts.minor : 0
    };
  }

  function getPageTotal(row) {
    const counts = getFilteredPageImpactCounts(row);
    return counts.critical + counts.serious + counts.moderate + counts.minor;
  }

  function getRankingFieldOption(value) {
    return rankingFieldLookup.get(value) || null;
  }

  function getDefaultRankingCriteria() {
    return rankingFieldOptions
      .filter(option => option.default !== false)
      .map(option => option.value);
  }

  function sanitizeRankingCriteria(values) {
    const seen = new Set();
    const order = [];
    if (Array.isArray(values)) {
      values.forEach(value => {
        if (!rankingFieldLookup.has(value) || seen.has(value)) return;
        order.push(value);
        seen.add(value);
      });
    }
    if (!order.length) {
      getDefaultRankingCriteria().forEach(value => {
        if (seen.has(value)) return;
        order.push(value);
        seen.add(value);
      });
    }
    return order;
  }

  function loadRankingCriteriaFromStorage() {
    if (typeof localStorage === 'undefined') {
      return getDefaultRankingCriteria();
    }
    try {
      const raw = localStorage.getItem(rankingCriteriaStorageKey);
      if (!raw) return getDefaultRankingCriteria();
      const parsed = JSON.parse(raw);
      return sanitizeRankingCriteria(parsed);
    } catch (err) {
      console.warn('Unable to parse ranking criteria from storage', err);
      return getDefaultRankingCriteria();
    }
  }

  function getRankingCriteria({ includeFallback = false } = {}) {
    if (!Array.isArray(rankingState.criteria)) {
      rankingState.criteria = loadRankingCriteriaFromStorage();
    }
    const criteria = rankingState.criteria.slice();
    if (!criteria.length) {
      criteria.push(...getDefaultRankingCriteria());
    }
    if (includeFallback) {
      const seen = new Set(criteria);
      rankingFallbackFields.forEach(value => {
        if (!rankingFieldLookup.has(value) || seen.has(value)) return;
        criteria.push(value);
        seen.add(value);
      });
    }
    return criteria;
  }

  function setRankingCriteria(values) {
    const sanitized = sanitizeRankingCriteria(values);
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.setItem(rankingCriteriaStorageKey, JSON.stringify(sanitized));
      } catch (err) {
        console.warn('Unable to persist ranking criteria', err);
      }
    }
    rankingState.criteria = sanitized;
    updateRankingSummaryUi();
    return sanitized;
  }

  function resetRankingCriteria() {
    return setRankingCriteria(getDefaultRankingCriteria());
  }

  function getRankingCriteriaCount() {
    return getRankingCriteria().length;
  }

  function rankingCriteriaUsesMonitorApi(criteria = getRankingCriteria()) {
    return criteria.some(value => Boolean(getRankingFieldOption(value)?.requiresApi));
  }

  function isMonitorApiReadyForRanking() {
    if (getPageImpactSource() !== 'api') return false;
    if (pageImpactApiState.status !== 'ready') return false;
    return pageImpactApiState.data.size > 0;
  }

  function isRankingFieldAvailable(value) {
    const option = getRankingFieldOption(value);
    if (!option) return false;
    if (!option.requiresApi) return true;
    return isMonitorApiReadyForRanking();
  }

  function getRankingScoreValue(row) {
    if (Number.isFinite(row?.scoreVal)) return row.scoreVal;
    if (Number.isFinite(row?.avgScore)) return row.avgScore;
    if (Number.isFinite(row?.score)) return row.score;
    return null;
  }

  function getRankingTotalCs(row) {
    return getRowCritical(row) + getRowSerious(row);
  }

  function getRankingTotalIssues(row) {
    if (Number.isFinite(row?.totalIssues)) return row.totalIssues;
    if (Number.isFinite(row?.total)) return row.total;
    return getRowTotalIssues(row);
  }

  function getRankingImpactCount(row, key) {
    if (Number.isFinite(row?.[key])) return row[key];
    if (!hasIssueImpactValue(row, key)) return null;
    const counts = getIssueImpactCounts(row);
    return Math.max(0, coerceNumber(counts[key], 0));
  }

  function getRankingNameValue(row) {
    return (row?.name || row?.label || row?.scan || '').trim();
  }

  function compareNumericDesc(aVal, bVal, missing = -Infinity) {
    const aNum = Number.isFinite(aVal) ? aVal : missing;
    const bNum = Number.isFinite(bVal) ? bVal : missing;
    if (bNum === aNum) return 0;
    return bNum - aNum;
  }

  function compareNumericAsc(aVal, bVal, missing = Infinity) {
    const aNum = Number.isFinite(aVal) ? aVal : missing;
    const bNum = Number.isFinite(bVal) ? bVal : missing;
    if (aNum === bNum) return 0;
    return aNum - bNum;
  }

  function compareRankingField(a, b, key) {
    switch (key) {
      case 'score':
        return compareNumericDesc(getRankingScoreValue(a), getRankingScoreValue(b));
      case 'totalCs':
        return compareNumericAsc(getRankingTotalCs(a), getRankingTotalCs(b));
      case 'critical':
        return compareNumericAsc(getRowCritical(a), getRowCritical(b));
      case 'serious':
        return compareNumericAsc(getRowSerious(a), getRowSerious(b));
      case 'moderate':
        return compareNumericAsc(getRankingImpactCount(a, 'moderate'), getRankingImpactCount(b, 'moderate'));
      case 'minor':
        return compareNumericAsc(getRankingImpactCount(a, 'minor'), getRankingImpactCount(b, 'minor'));
      case 'totalIssues':
        return compareNumericAsc(getRankingTotalIssues(a), getRankingTotalIssues(b));
      case 'name':
        return getRankingNameValue(a).localeCompare(getRankingNameValue(b), undefined, { sensitivity: 'base' });
      default:
        return 0;
    }
  }

  function compareByRankingCriteria(a, b, criteria = null) {
    const list = (criteria && criteria.length ? criteria : getRankingCriteria({ includeFallback: true }));
    for (let i = 0; i < list.length; i += 1) {
      const key = list[i];
      const result = compareRankingField(a, b, key);
      if (result !== 0) return result;
    }
    const nameResult = compareRankingField(a, b, 'name');
    if (nameResult !== 0) return nameResult;
    const labelA = (a?.label || '').toString();
    const labelB = (b?.label || '').toString();
    return labelA.localeCompare(labelB, undefined, { sensitivity: 'base' });
  }

  function getRankingSignatureValue(row, field) {
    switch (field) {
      case 'score': {
        const scoreValue = getRankingScoreValue(row);
        return Number.isFinite(scoreValue) ? scoreValue.toFixed(3) : 'na';
      }
      case 'totalCs': {
        const totalCsValue = getRankingTotalCs(row);
        return Number.isFinite(totalCsValue) ? String(totalCsValue) : 'na';
      }
      case 'critical': {
        const critValue = getRowCritical(row);
        return Number.isFinite(critValue) ? String(critValue) : 'na';
      }
      case 'serious': {
        const seriousValue = getRowSerious(row);
        return Number.isFinite(seriousValue) ? String(seriousValue) : 'na';
      }
      case 'moderate': {
        const moderateValue = getRankingImpactCount(row, 'moderate');
        return Number.isFinite(moderateValue) ? String(moderateValue) : 'na';
      }
      case 'minor': {
        const minorValue = getRankingImpactCount(row, 'minor');
        return Number.isFinite(minorValue) ? String(minorValue) : 'na';
      }
      case 'totalIssues': {
        const totalIssuesValue = getRankingTotalIssues(row);
        return Number.isFinite(totalIssuesValue) ? String(totalIssuesValue) : 'na';
      }
      case 'name':
        return getRankingNameValue(row).toLowerCase();
      default:
        return '';
    }
  }

  function buildRankingSignature(row, criteria = getRankingCriteria({ includeFallback: true })) {
    return criteria.map(field => getRankingSignatureValue(row, field)).join('|');
  }

  function buildRankingControlBlock() {
    if (pageContext !== 'scans') return null;
    const wrapper = document.createElement('div');
    wrapper.className = 'a11y-ranking-control';
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'a11y-btn-secondary a11y-ranking-trigger';
    button.id = rankingState.buttonId;
    button.setAttribute('aria-haspopup','dialog');
    button.addEventListener('click', () => openRankingDialog(button));
    const summary = document.createElement('span');
    summary.id = rankingState.summaryId;
    summary.className = 'a11y-ranking-summary';
    summary.setAttribute('aria-live','polite');
    wrapper.appendChild(button);
    wrapper.appendChild(summary);
    rankingState.triggerButton = button;
    rankingState.summaryEl = summary;
    updateRankingSummaryUi();
    return wrapper;
  }

  function updateRankingSummaryUi() {
    const criteria = getRankingCriteria();
    const button = rankingState.triggerButton;
    if (button) {
      button.textContent = `Ranking: ${criteria.length} applied`;
      button.setAttribute('aria-describedby', rankingState.summaryId);
    }
    const summary = rankingState.summaryEl;
    if (summary) {
      const labels = criteria.map(value => {
        const option = getRankingFieldOption(value);
        return option?.shortLabel || option?.label || value;
      });
      const needsApi = rankingCriteriaUsesMonitorApi(criteria);
      const showWarning = needsApi && !isMonitorApiReadyForRanking();
      let text = labels.length ? labels.join(' → ') : 'Using default ranking order.';
      if (showWarning) {
        text += ' • Monitor API data required';
      }
      summary.textContent = text;
      summary.classList.toggle('a11y-ranking-summary--warning', showWarning);
    }
  }

  function aggregateDomains(rows) {
    const map = new Map();
    rows
      .filter(row => row && row.statusKey === 'Complete')
      .forEach(row => {
        const key = row.domain || 'Other';
        let agg = map.get(key);
        if (!agg) {
          agg = { domain: key, crit: 0, serious: 0, total: 0, rows: [], pages: 0 };
          map.set(key, agg);
        }
        if (Number.isFinite(row.crit)) agg.crit += row.crit;
        if (Number.isFinite(row.serious)) agg.serious += row.serious;
        if (Number.isFinite(row.total)) {
          agg.total += row.total;
        } else {
          agg.total += getRowTotalIssues(row);
        }
        if (Number.isFinite(row.pages)) agg.pages += row.pages;
        agg.rows.push(row);
      });
    return map;
  }

  function aggregatePageDomains(rows) {
    const map = new Map();
    rows
      .filter(row => row && row.statusKey === 'Complete')
      .forEach(row => {
        const key = row.domain || 'Other';
        let agg = map.get(key);
        if (!agg) {
          agg = { domain: key, crit: 0, serious: 0, moderate: 0, minor: 0, rows: [] };
          map.set(key, agg);
        }
        const counts = getFilteredPageImpactCounts(row);
        agg.crit += counts.critical;
        agg.serious += counts.serious;
        agg.moderate += counts.moderate;
        agg.minor += counts.minor;
        agg.rows.push(row);
      });
    return map;
  }

  function getPageImpactFilterSummaryText() {
    const sourceLabel = getPageImpactSourceLabel(getPageImpactSourceForView());
    return `Impact filter (${sourceLabel}): ${formatPageImpactSelection(getActivePageImpactKeys())}`;
  }

  function updatePageImpactFilterSummary(summaryEl = pageImpactFilterState.summaryEl) {
    if (!summaryEl) return;
    summaryEl.textContent = getPageImpactFilterSummaryText();
  }

  function updatePageImpactFilterButton(button = pageImpactFilterState.button) {
    if (!button) return;
    const selectionText = formatPageImpactSelection(getActivePageImpactKeys());
    const sourceLabel = getPageImpactSourceLabel(getPageImpactSourceForView());
    const aria = `Edit filter Impact. ${sourceLabel} with ${selectionText} is current value.`;
    button.setAttribute('aria-label', aria);
    button.setAttribute('aria-expanded', pageImpactFilterState.popover ? 'true' : 'false');
    const valueEl = button.querySelector('.a11y-page-impact-filter-value');
    if (valueEl) valueEl.textContent = `${sourceLabel} - ${selectionText}`;
  }

  function updatePageImpactSourceControls() {
    const source = getPageImpactSource();
    const map = pageImpactFilterState.sourceButtons;
    if (map && map.size) {
      map.forEach((btn, key) => {
        const active = key === source;
        btn.classList.toggle('a11y-segment-button--active', active);
        btn.setAttribute('aria-pressed', active ? 'true' : 'false');
        btn.style.background = active ? '#ffffff' : 'transparent';
        btn.style.color = active ? '#0f172a' : '#475569';
        btn.style.boxShadow = active ? '0 1px 2px rgba(15,23,42,0.18)' : 'none';
      });
    }
    if (pageImpactFilterState.sourceSegment) {
      pageImpactFilterState.sourceSegment.setAttribute('data-active-source', source);
    }
    updateRankingSummaryUi();
  }

  function updatePageImpactApiControls() {
    const container = pageImpactFilterState.apiContainer;
    const statusEl = pageImpactFilterState.apiStatusEl;
    const button = pageImpactFilterState.apiButton;
    const chipTargets = [pageImpactFilterState.apiChip, pageImpactFilterState.footerApiChip].filter(Boolean);
    const source = getPageImpactSource();
    const defaultColor = '#4a5568';
    const setChipState = (label, bg = '#f1f5f9', color = defaultColor, opts = {}) => {
      const normalizedStatus = (label || '').toLowerCase().replace(/\s+/g, '-') || '';
      const interactive = !!opts.interactive;
      const text = `API data • ${label}`;
      chipTargets.forEach(target => {
        renderMonitorApiChipContent(target, text, { interactive });
        target.style.background = bg;
        target.style.color = color;
        target.dataset.status = normalizedStatus;
        target.dataset.chipAction = opts.action || '';
        if (opts.coverage) {
          target.dataset.missing = String(opts.coverage.missing ?? 0);
          target.dataset.total = String(opts.coverage.total ?? 0);
        } else {
          delete target.dataset.missing;
          delete target.dataset.total;
        }
        target.disabled = !interactive;
        target.classList.toggle('a11y-page-impact-api-chip--interactive', interactive);
        if (interactive) {
          const aria = opts.ariaLabel || `Monitor API status ${label}. Press to load missing data.`;
          target.setAttribute('aria-label', aria);
        } else {
          target.removeAttribute('aria-label');
        }
      });
    };
    if (container) container.hidden = false;
    if (statusEl) {
      statusEl.style.color = defaultColor;
    }
    if (button) {
      button.disabled = false;
      button.hidden = false;
    }
    let footerMessage = null;
    if (source !== 'api') {
      setChipState('off', '#e2e8f0', '#475569', { interactive: true, action: 'off', ariaLabel: 'Monitor API data is off. Press to load data.' });
      if (statusEl) {
        statusEl.textContent = 'Switch to the axe Monitor API to include Moderate and Minor counts.';
      }
      if (button) {
        button.disabled = true;
        button.hidden = true;
        button.dataset.apiFetchMode = 'none';
        button.textContent = 'Request data from API';
      }
      setFooterRefreshMessage(footerMessage);
      return;
    }
    const coverage = getPageImpactApiCoverage();
    const { status, error, timestamp, progress } = pageImpactApiState;
    const shouldAutoSwitchToWebsite =
      !pageImpactFilterState.initialSourceEvaluated &&
      source === 'api' &&
      coverage.total > 0 &&
      coverage.missing > 0;
    if (!pageImpactFilterState.initialSourceEvaluated) {
      pageImpactFilterState.initialSourceEvaluated = true;
    }
    if (shouldAutoSwitchToWebsite) {
      setPageImpactSource('website');
      handlePageImpactFilterChanged();
      return;
    }
    let message = '';
    let color = defaultColor;
    let buttonLabel = 'Request data from API';
    let fetchMode = 'missing';
    if (status === 'loading') {
      const total = progress?.total ?? (coverage.total || 0);
      const current = progress?.current ?? 0;
      const label = progress?.label ? ` (${progress.label})` : '';
      const displayTotal = Math.max(total, 1);
      const displayIndex = Math.min(current + 1, displayTotal);
      message = `Requesting data${label} (${displayIndex}/${displayTotal})...`;
      buttonLabel = 'Request in progress...';
      if (button) button.disabled = true;
      fetchMode = 'loading';
      setChipState('loading', '#fef3c7', '#92400e');
      footerMessage = 'Last data refresh: Loading Monitor API data...';
    } else if (status === 'error') {
      message = error || 'Unable to load data from the API.';
      color = '#a4000f';
      buttonLabel = 'Retry API request';
      fetchMode = 'retry';
      setChipState('error', '#fee2e2', '#9b1c1c');
      footerMessage = `Last data refresh: API data request failed. ${message}`;
    } else if (coverage.total === 0) {
      message = 'No completed scans are available in this view for API data.';
      if (button) button.disabled = true;
      fetchMode = 'none';
      setChipState('no scans', '#e2e8f0', '#475569');
      footerMessage = 'Last data refresh: No completed scans available for Monitor API data.';
    } else if (coverage.missing > 0) {
      message = `API data missing for ${coverage.missing} of ${coverage.total} scans. Request data to include all impacts.`;
      buttonLabel = 'Load missing data';
      fetchMode = 'missing';
      setChipState('missing', '#fff7ed', '#9a3412', { interactive: true, action: 'missing', coverage, ariaLabel: 'API data missing. Press to load missing data.' });
      footerMessage = `Last data refresh: API data missing for ${coverage.missing} of ${coverage.total} scans.`;
    } else {
      message = `API data loaded for ${coverage.total} scans.`;
      if (timestamp) {
        message += ` Last updated ${new Date(timestamp).toLocaleString()}.`;
      }
      color = '#1b5e20';
      buttonLabel = 'Request data from API';
      fetchMode = 'none';
      setChipState('ready', '#d1fae5', '#065f46');
      const updatedText = timestamp ? new Date(timestamp).toLocaleString() : pageImpactFilterState.footerBaseTimestamp;
      footerMessage = `Last data refresh: API data loaded for ${coverage.total} scans. Last updated ${updatedText || new Date().toLocaleString()}.`;
      if (button) {
        button.disabled = true;
        button.hidden = true;
        button.dataset.apiFetchMode = 'none';
      }
    }
    if (statusEl) {
      statusEl.textContent = message;
      statusEl.style.color = color;
    }
    if (button) {
      button.textContent = buttonLabel;
      button.dataset.apiFetchMode = fetchMode;
    }
    setFooterRefreshMessage(footerMessage);
    updateRankingSummaryUi();
  }

  async function handleMonitorApiChipClick(target = pageImpactFilterState.apiChip) {
    const chip = target;
    if (!chip || chip.disabled) return;
    const action = chip.dataset.chipAction;
    if (action === 'missing') {
      const missing = Number(chip.dataset.missing) || 0;
      const total = Number(chip.dataset.total) || 0;
      if (!missing) return;
      await openMonitorApiMissingDialog({ missing, total });
      return;
    }
    if (action === 'off') {
      const ok = await ensureMonitorApiDataAvailability({ reason: 'chip-off', selection: monitorApiOnlyImpactKeys });
      if (!ok) return;
      setPageImpactSource('api');
      handlePageImpactFilterChanged();
    }
  }

  function closePageImpactFilterPopover({ focusButton = false } = {}) {
    if (pageImpactFilterState.outsideClickHandler) {
      document.removeEventListener('mousedown', pageImpactFilterState.outsideClickHandler, true);
      document.removeEventListener('touchstart', pageImpactFilterState.outsideClickHandler, true);
      document.removeEventListener('focusin', pageImpactFilterState.outsideClickHandler, true);
      pageImpactFilterState.outsideClickHandler = null;
    }
    if (pageImpactFilterState.keydownHandler) {
      document.removeEventListener('keydown', pageImpactFilterState.keydownHandler, true);
      pageImpactFilterState.keydownHandler = null;
    }
    if (pageImpactFilterState.popover) {
      pageImpactFilterState.popover.remove();
      pageImpactFilterState.popover = null;
    }
    pageImpactFilterState.workingSelection = null;
    pageImpactFilterState.workingSource = null;
    if (pageImpactFilterState.button) {
      pageImpactFilterState.button.setAttribute('aria-expanded','false');
      if (focusButton && pageImpactFilterState.button.isConnected) {
        pageImpactFilterState.button.focus();
      }
    }
  }

  function positionPageImpactPopover(popover, anchor) {
    if (!popover || !anchor) return;
    const rect = anchor.getBoundingClientRect();
    const x = rect.left + (window.pageXOffset || document.documentElement.scrollLeft || 0);
    const y = rect.bottom + (window.pageYOffset || document.documentElement.scrollTop || 0) + 4;
    popover.style.position = 'absolute';
    popover.style.left = '0px';
    popover.style.top = '0px';
    popover.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
  }

  function buildImpactCheckbox(option, workingSelection, onToggle) {
    const wrap = document.createElement('label');
    wrap.className = 'a11y-page-impact-option';
    const input = document.createElement('input');
    input.type = 'checkbox';
    input.id = `${pageImpactFilterState.idBase}-${option.key}`;
    input.name = `${pageImpactFilterState.idBase}-impact`;
    input.value = option.key;
    input.className = 'a11y-page-impact-option-input';
    input.checked = workingSelection.has(option.key);
    input.addEventListener('change', () => {
      onToggle(option.key, input.checked);
    });
    wrap.appendChild(input);
    const label = document.createElement('span');
    label.className = 'a11y-page-impact-option-label';
    label.textContent = option.label;
    wrap.appendChild(label);
    return { wrap, input };
  }

  function openPageImpactFilterPopover(button) {
    if (!button) return;
    closePageImpactFilterPopover({ focusButton: false });
    const workingSelection = new Set(getActivePageImpactKeys());
    const workingSource = getPageImpactSource();
    const storedSelectionSnapshot = new Set(pageImpactFilterState.selection || []);
    const viewLimitedToPages = isPagesTabActive();
    pageImpactFilterState.workingSelection = workingSelection;
    pageImpactFilterState.workingSource = workingSource;
    const popover = document.createElement('div');
    popover.id = pageImpactFilterState.popoverId;
    popover.className = 'Popover Popover--left';
    popover.setAttribute('role','dialog');
    popover.setAttribute('aria-labelledby', pageImpactFilterState.titleId);
    popover.style.zIndex = '2147483650';
    pageImpactFilterState.popover = popover;
    const arrow = document.createElement('div');
    arrow.className = 'Popover__popoverArrow';
    popover.appendChild(arrow);
    const border = document.createElement('div');
    border.className = 'Popover__borderLeft';
    popover.appendChild(border);

    const panel = document.createElement('div');
    panel.className = 'Panel f318df3e62a6';
  const title = document.createElement('span');
    title.className = 'Offscreen';
    title.id = pageImpactFilterState.titleId;
  const popoverSourceKey = viewLimitedToPages ? getPageImpactSourceForView() : workingSource;
  const screenReaderSourceLabel = getPageImpactSourceLabel(popoverSourceKey);
    title.textContent = `Edit filter Impact. ${screenReaderSourceLabel} with ${formatPageImpactSelection(getActivePageImpactKeys())} is current value.`;
    panel.appendChild(title);

  const content = document.createElement('div');
  content.className = 'Panel__Content ce354eef3eec Panel__Content--no-padding';
  const checkboxMap = new Map();

    const syncWorkingSelectionToSource = source => {
      const allowed = getAllowedImpactKeysForSource(source, viewLimitedToPages ? { scopedToView: true } : undefined);
      let changed = false;
      Array.from(workingSelection).forEach(key => {
        if (!allowed.has(key)) {
          workingSelection.delete(key);
          changed = true;
        }
      });
      if (!workingSelection.size) {
        const defaults = viewLimitedToPages
          ? getDefaultImpactsForView(source)
          : getDefaultImpactsForSource(source);
        defaults.forEach(key => workingSelection.add(key));
        changed = true;
      }
      return changed;
    };

  const legend = document.createElement('h3');
  legend.id = `${pageImpactFilterState.idBase}-legend`;
  legend.className = 'd1a6281dccdb';
  legend.textContent = 'Impact';
  const requiredTag = document.createElement('span');
  requiredTag.className = 'ed12a719826a';
  requiredTag.textContent = 'Required';
  legend.appendChild(requiredTag);
    content.appendChild(legend);

    const sourceHint = document.createElement('p');
    sourceHint.className = 'a11y-page-impact-source-hint';
    sourceHint.style.margin = '0 16px 12px';
    sourceHint.style.fontSize = '12px';
    sourceHint.style.color = '#4a5568';
    content.appendChild(sourceHint);

    const group = document.createElement('div');
    group.className = 'a11y-page-impact-options';
    group.setAttribute('role','group');
    group.setAttribute('aria-labelledby', legend.id);
    const handleToggle = (key, checked) => {
      const allowed = getAllowedImpactKeysForSource(workingSource, viewLimitedToPages ? { scopedToView: true } : undefined);
      if (!allowed.has(key)) return;
      if (checked) {
        workingSelection.add(key);
      } else {
        workingSelection.delete(key);
      }
      updateApplyState();
    };
    pageImpactFilterOptions.forEach(option => {
      const { wrap, input } = buildImpactCheckbox(option, workingSelection, handleToggle);
      checkboxMap.set(option.key, input);
      group.appendChild(wrap);
    });
    content.appendChild(group);
    const error = document.createElement('p');
    error.className = 'a11y-page-impact-filter-error';
    error.style.fontSize = '12px';
    error.style.color = '#a4000f';
    error.style.margin = '0 16px 8px';
    error.textContent = 'Select at least one impact.';
    content.appendChild(error);
    panel.appendChild(content);

    const footer = document.createElement('div');
    footer.className = 'Panel__Content b83b5ad68e6a Panel__Content--no-padding';
    const applyBtn = document.createElement('button');
    applyBtn.type = 'button';
    applyBtn.className = 'Button--primary Button--thin';
    applyBtn.textContent = 'Apply';
    const cancelBtn = document.createElement('button');
    cancelBtn.type = 'button';
    cancelBtn.className = 'Button--secondary Button--thin';
    cancelBtn.textContent = 'Cancel';
    const resetBtn = document.createElement('button');
    resetBtn.type = 'button';
    resetBtn.className = 'Link';
    resetBtn.textContent = 'reset filter';
    footer.appendChild(applyBtn);
    footer.appendChild(cancelBtn);
    footer.appendChild(resetBtn);
    panel.appendChild(footer);
    popover.appendChild(panel);
    document.body.appendChild(popover);
    positionPageImpactPopover(popover, button);
    button.setAttribute('aria-expanded','true');

    syncWorkingSelectionToSource(workingSource);
  refreshCheckboxStates();
    updateSourceHintText();

    function updateApplyState() {
      const hasSelection = workingSelection.size > 0;
      applyBtn.disabled = !hasSelection;
      error.hidden = hasSelection;
    }
    updateApplyState();

    async function handleApply() {
      if (!workingSelection.size) {
        updateApplyState();
        return;
      }
      if (
        workingSource === 'api' &&
        selectionHasMonitorApiOnlyImpacts(workingSelection)
      ) {
        const ok = await ensureMonitorApiDataAvailability({
          reason: 'filter',
          selection: workingSelection
        });
        if (!ok) return;
      }
      const baseSelection = Array.from(workingSelection);
      if (viewLimitedToPages) {
        const allowed = getAllowedImpactKeysForSource(workingSource, { scopedToView: true });
        const preserved = Array.from(storedSelectionSnapshot).filter(key => !allowed.has(key));
        preserved.forEach(key => {
          if (!baseSelection.includes(key)) baseSelection.push(key);
        });
      }
      applyPageImpactFilter(baseSelection, workingSource);
      closePageImpactFilterPopover({ focusButton: false });
      handlePageImpactFilterChanged();
    }

    function handleReset() {
      workingSelection.clear();
      const defaults = viewLimitedToPages
        ? getDefaultImpactsForView(workingSource)
        : getDefaultImpactsForSource(workingSource);
      defaults.forEach(key => workingSelection.add(key));
      refreshCheckboxStates();
      updateSourceHintText();
      updateApplyState();
    }

    function refreshCheckboxStates() {
      const allowed = getAllowedImpactKeysForSource(workingSource, viewLimitedToPages ? { scopedToView: true } : undefined);
      checkboxMap.forEach((input, key) => {
        const isAllowed = allowed.has(key);
        input.disabled = !isAllowed;
        if (isAllowed) {
          input.removeAttribute('aria-disabled');
        } else {
          input.setAttribute('aria-disabled','true');
          input.checked = false;
        }
        input.checked = workingSelection.has(key);
        const wrap = input.parentElement;
        if (wrap) {
          wrap.classList.toggle('a11y-page-impact-option--disabled', !isAllowed);
          wrap.style.opacity = isAllowed ? '' : '0.5';
        }
      });
      updateSourceHintText();
    }

    function updateSourceHintText() {
      if (viewLimitedToPages) {
        sourceHint.textContent = 'Pages with Issues always uses the Latest scan source. Moderate and Minor impacts are unavailable on this tab.';
        return;
      }
      if (workingSource === 'api') {
        sourceHint.textContent = 'Moderate and Minor counts are included via the axe Monitor API.';
      } else {
        sourceHint.textContent = 'Moderate and Minor counts require the axe Monitor API. Use the toggle next to the Impact button to switch sources.';
      }
    }

    applyBtn.addEventListener('click', () => {
      handleApply().catch(err => {
        console.error(err);
        alert(err?.message || 'Unable to apply impact filter.');
      });
    });
    cancelBtn.addEventListener('click', () => closePageImpactFilterPopover({ focusButton: true }));
    resetBtn.addEventListener('click', handleReset);

    const outsideHandler = event => {
      if (!popover.contains(event.target) && !button.contains(event.target)) {
        closePageImpactFilterPopover({ focusButton: false });
      }
    };
    document.addEventListener('mousedown', outsideHandler, true);
    document.addEventListener('touchstart', outsideHandler, true);
    document.addEventListener('focusin', outsideHandler, true);
    pageImpactFilterState.outsideClickHandler = outsideHandler;

    const keydownHandler = event => {
      if (event.key === 'Escape') {
        event.preventDefault();
        closePageImpactFilterPopover({ focusButton: true });
      } else if (event.key === 'Tab') {
        const focusables = getFocusable(popover);
        if (!focusables.length) return;
        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        if (event.shiftKey && document.activeElement === first) {
          event.preventDefault();
          last.focus();
        } else if (!event.shiftKey && document.activeElement === last) {
          event.preventDefault();
          first.focus();
        }
      }
    };
    document.addEventListener('keydown', keydownHandler, true);
    pageImpactFilterState.keydownHandler = keydownHandler;

    const firstEnabledCheckbox = Array.from(checkboxMap.values()).find(input => !input.disabled);
    if (firstEnabledCheckbox) {
      firstEnabledCheckbox.focus();
    }
  }

  function buildPageImpactSourceToggleControl() {
    if (!Array.isArray(pageImpactSourceOptions) || !pageImpactSourceOptions.length) {
      return null;
    }
    const sourceSegment = document.createElement('div');
    sourceSegment.className = 'a11y-page-impact-source-toggle';
    sourceSegment.style.display = 'inline-flex';
    sourceSegment.style.flexWrap = 'wrap';
    sourceSegment.style.padding = '2px';
    sourceSegment.style.borderRadius = '999px';
    sourceSegment.style.background = '#f0f4f8';
    sourceSegment.style.boxShadow = 'inset 0 0 0 1px rgba(15,23,42,0.08)';
    sourceSegment.setAttribute('role','group');
    sourceSegment.setAttribute('aria-label','Impact data source');

    const sourceButtons = new Map();
    const currentSource = getPageImpactSource();
    const handleSourceSelection = async key => {
      if (getPageImpactSource() === key) return;
      if (key === 'api') {
        const ok = await ensureMonitorApiDataAvailability({ reason: 'toggle' });
        if (!ok) {
          updatePageImpactSourceControls();
          return;
        }
      }
      setPageImpactSource(key);
      handlePageImpactFilterChanged();
    };
    pageImpactSourceOptions.forEach(option => {
      const segBtn = document.createElement('button');
      segBtn.type = 'button';
      segBtn.className = 'Button--tertiary Button--thin a11y-segment-button';
      segBtn.textContent = option.shortLabel || option.label;
      segBtn.style.border = 'none';
      segBtn.style.borderRadius = '999px';
      segBtn.style.padding = '4px 12px';
      segBtn.style.fontWeight = '600';
      segBtn.dataset.sourceKey = option.key;
      segBtn.setAttribute('aria-pressed', option.key === currentSource ? 'true' : 'false');
      segBtn.addEventListener('click', () => {
        handleSourceSelection(option.key).catch(err => console.error(err));
      });
      sourceSegment.appendChild(segBtn);
      sourceButtons.set(option.key, segBtn);
    });

    pageImpactFilterState.sourceSegment = sourceSegment;
    pageImpactFilterState.sourceButtons = sourceButtons;
    updatePageImpactSourceControls();
    return sourceSegment;
  }

  function createMonitorApiChipElement() {
    const chip = document.createElement('button');
    chip.type = 'button';
    chip.className = 'a11y-page-impact-api-chip';
    chip.style.display = 'inline-flex';
    chip.style.alignItems = 'center';
    chip.style.gap = '4px';
    chip.style.padding = '2px 10px';
    chip.style.borderRadius = '999px';
    chip.style.fontSize = '12px';
    chip.style.fontWeight = '600';
    chip.style.background = '#f1f5f9';
    chip.style.color = '#475569';
    chip.style.border = '1px solid rgba(15,23,42,0.08)';
    chip.disabled = true;
    chip.dataset.chipAction = '';
    chip.addEventListener('click', () => {
      handleMonitorApiChipClick(chip).catch(err => console.error(err));
    });
    return chip;
  }

  const monitorApiChipIndicatorSvg = '<svg overflow="visible" preserveAspectRatio="none" viewBox="0 0 16 16" height="16" width="16"><path d="M8 1a.75.75 0 0 1 .75.75v4.5h4.5a.75.75 0 0 1 0 1.5h-5.25A.75.75 0 0 1 7.25 7V1.75A.75.75 0 0 1 8 1Zm-5 4a.75.75 0 0 0-.53 1.28l3.75 3.75v2.19a2.78 2.78 0 0 0 4.74 1.96l3.06-3.06a.75.75 0 1 0-1.06-1.06l-3.06 3.06a1.28 1.28 0 0 1-2.18-.9v-2.5a.75.75 0 0 0-.22-.53L4.53 5.28A.75.75 0 0 0 3 5Z" fill="currentColor" vector-effect="non-scaling-stroke"></path></svg>';

  function renderMonitorApiChipContent(target, text, { interactive = false } = {}) {
    if (!target) return;
    target.innerHTML = '';
    const labelSpan = document.createElement('span');
    labelSpan.className = 'a11y-chip-label';
    labelSpan.textContent = text;
    target.appendChild(labelSpan);
    if (interactive) {
      const indicator = document.createElement('span');
      indicator.className = 'a11y-chip-indicator';
      indicator.setAttribute('aria-hidden','true');
      indicator.innerHTML = monitorApiChipIndicatorSvg;
      target.appendChild(indicator);
    }
  }

  function buildPageImpactFilterControls() {
    const block = document.createElement('div');
    block.className = 'a11y-page-impact-filter-block';

    const toolbar = document.createElement('div');
    toolbar.className = 'a11y-page-impact-toolbar';
    toolbar.style.display = 'flex';
    toolbar.style.flexDirection = 'column';
    toolbar.style.alignItems = 'flex-start';
    toolbar.style.gap = '8px';
    block.appendChild(toolbar);

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'TagButton Tag Button--tag';
    button.id = pageImpactFilterState.buttonId;
    button.setAttribute('aria-haspopup','true');
    button.setAttribute('aria-expanded','false');
    button.setAttribute('aria-controls', pageImpactFilterState.popoverId);
    button.addEventListener('click', event => {
      event.preventDefault();
      if (pageImpactFilterState.popover) {
        closePageImpactFilterPopover({ focusButton: true });
        return;
      }
      openPageImpactFilterPopover(button);
    });
    const label = document.createElement('div');
    label.className = 'Tag__label';
    label.textContent = 'Impact:';
    button.appendChild(label);
    const valueSpan = document.createElement('span');
    valueSpan.className = 'a11y-page-impact-filter-value';
    button.appendChild(valueSpan);
    const icon = document.createElement('span');
    icon.className = 'Icon Icon--pencil TagButton__icon';
    icon.setAttribute('aria-hidden','true');
    icon.innerHTML = '<svg overflow="visible" preserveAspectRatio="none" viewBox="0 0 24 24" height="24" width="24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" vector-effect="non-scaling-stroke" fill="currentColor"></path></svg>';
    button.appendChild(icon);
    toolbar.appendChild(button);

    pageImpactFilterState.button = button;
    pageImpactFilterState.summaryEl = null;
    pageImpactFilterState.apiContainer = null;
    pageImpactFilterState.apiStatusEl = null;
    pageImpactFilterState.apiButton = null;
    pageImpactFilterState.apiChip = null;

    updatePageImpactFilterButton(button);
    updatePageImpactSourceControls();
    updatePageImpactApiControls();

    return block;
  }

  function handlePageImpactFilterChanged() {
    updatePageImpactFilterButton();
    updatePageImpactFilterSummary();
    updatePageImpactSourceControls();
    updatePageImpactApiControls();
    if (pageContext !== 'scans') return;
    if (!modalContext || !modalContext.body || !lastRenderedData) return;
    const { body, footer, updateFilterButtonLabel } = modalContext;
    const activePanel = getActivePanelElement(body);
    const prevState = captureAccordionState(activePanel || body) || getDefaultAccordionState(currentTabKey);
    renderBody(body, lastRenderedData, updateFilterButtonLabel, footer, prevState);
    const refreshedPanel = getActivePanelElement(body);
    accordionStateByTab[currentTabKey] = captureAccordionState(refreshedPanel || body) || {};
    if ((currentTabKey === 'pages' || currentTabKey === 'issues') && pageImpactFilterState.button) {
      requestAnimationFrame(() => {
        if (pageImpactFilterState.button) {
          pageImpactFilterState.button.focus();
        }
      });
    }
  }

  async function requestPageImpactApiData({ mode, includeAll = false } = {}) {
    if (pageContext !== 'scans') {
      alert('API data is only available from the scans summary view.');
      return;
    }
    if (pageImpactApiState.status === 'loading') {
      logImpactApi('Ignoring API request: another request is already running');
      return;
    }
    const desiredMode = mode || pageImpactFilterState.apiButton?.dataset?.apiFetchMode || 'missing';
    const fetchAll = includeAll || desiredMode === 'reload';
    if (!getStoredMonitorApiKey()) {
      try {
        const saved = await openSettingsDialog({ focusField: 'apiKey' });
        if (!saved && !getStoredMonitorApiKey()) {
          alert('Set the Deque Monitor API key before requesting data.');
          return;
        }
      } catch (err) {
        console.error(err);
        alert(err?.message || 'Unable to open settings.');
        return;
      }
    }
    if (!lastRenderedData) {
      alert('Scan data is still loading. Please try again in a moment.');
      return;
    }
    const scanRowsMap = getImpactScanRows();
    if (!scanRowsMap.size) {
      alert('No scans are currently available for API requests.');
      return;
    }
    const fallbackLookup = new Map();
    const allRows = Array.isArray(lastRenderedData?.rows) ? lastRenderedData.rows : [];
    allRows.forEach(row => {
      const id = getRowScanId(row);
      if (!id) return;
      if (!fallbackLookup.has(id) && row?.url) {
        fallbackLookup.set(id, row);
      }
    });
    const targets = [];
    scanRowsMap.forEach((primaryRow, id) => {
      if (primaryRow?.statusKey && primaryRow.statusKey !== 'Complete') return;
      const hasData = pageImpactApiState.data.has(id);
      if (!fetchAll && hasData) return;
      let candidate = primaryRow;
      if (!candidate?.url) {
        const fallback = fallbackLookup.get(id);
        if (fallback) {
          candidate = { ...fallback, ...candidate };
        }
      }
      if (!candidate?.url) {
        logImpactApi('Skipping scan', id, 'missing scan URL for API request');
        return;
      }
      targets.push([id, candidate]);
    });
    if (!targets.length) {
      logImpactApi('No scans require API refresh', { fetchAll });
      updatePageImpactApiControls();
      return;
    }

    logImpactApi('Starting API request for', targets.length, 'scans');
    pageImpactApiState.status = 'loading';
    pageImpactApiState.error = null;
    pageImpactApiState.progress = { current: 0, total: targets.length, label: '' };
    updatePageImpactApiControls();

    pageImpactApiAbortController?.abort();
    pageImpactApiAbortController = new AbortController();
    const progress = openProgressDialog({
      title: 'Requesting API data',
      initialMessage: `Fetching ${targets.length} scan${targets.length === 1 ? '' : 's'}...`
    });
    progress.onCancel(() => {
      pageImpactApiAbortController?.abort();
    });

    const errors = [];
    const successes = [];
    const signal = pageImpactApiAbortController.signal;
    try {
      for (let i = 0; i < targets.length; i++) {
        if (signal.aborted) {
          const abortErr = new Error('cancelled');
          abortErr.name = 'AbortError';
          throw abortErr;
        }
        const [id, row] = targets[i];
        const label = row?.name || row?.type || `Scan ${id}`;
        pageImpactApiState.progress = { current: i, total: targets.length, label };
        updatePageImpactApiControls();
        progress.update(`Loading ${label} (${i + 1}/${targets.length})...`);
        try {
          const metrics = await fetchRunMetricsForRow(row, { signal });
          const record = {
            issues: {
              critical: metrics.critical,
              serious: metrics.serious,
              moderate: metrics.moderate,
              minor: metrics.minor
            },
            pages: {
              critical: metrics.pagesCritical,
              serious: metrics.pagesSerious,
              moderate: metrics.pagesModerate,
              minor: metrics.pagesMinor
            },
            status: metrics.status || '',
            runNumber: metrics.runNumber ?? null,
            fetchedAt: Date.now(),
            name: row?.name || ''
          };
          pageImpactApiState.data.set(String(id), record);
          successes.push(id);
          logImpactApi('Loaded API data for', label, `(${id})`);
        } catch (err) {
          if (err?.name === 'AbortError') throw err;
          logImpactApi('API request failed for', id, err?.message || err);
          errors.push({ id, name: row?.name || '', message: err?.message || 'Request failed' });
        }
      }
    } catch (err) {
      if (err?.name !== 'AbortError') {
        console.error(err);
        pageImpactApiState.status = 'error';
        pageImpactApiState.error = err?.message || 'Unable to load data from the API.';
        logImpactApi('API request failed:', pageImpactApiState.error);
        updatePageImpactApiControls();
        alert(pageImpactApiState.error);
        return;
      }
      logImpactApi('API request cancelled by user');
      pageImpactApiState.status = pageImpactApiState.data.size ? 'ready' : 'idle';
  pageImpactApiState.error = null;
      pageImpactApiState.progress = null;
      pageImpactApiAbortController = null;
      updatePageImpactApiControls();
      alert('API request cancelled.');
      return;
    } finally {
      progress.close();
      pageImpactApiAbortController = null;
      pageImpactApiState.progress = null;
    }

    if (errors.length && !successes.length) {
      pageImpactApiState.status = 'error';
      const failedNames = errors.map(item => item.name || item.id).filter(Boolean);
      const listText = failedNames.slice(0, 3).join(', ');
      pageImpactApiState.error = failedNames.length > 3
        ? `${failedNames.length} scans failed (e.g., ${listText}).`
        : `Failed to load data for ${listText || 'the selected scans'}.`;
      logImpactApi('API request failed for all scans');
    } else {
      pageImpactApiState.status = errors.length ? 'error' : 'ready';
      pageImpactApiState.timestamp = Date.now();
      if (errors.length) {
        const failedNames = errors.map(item => item.name || item.id).filter(Boolean);
        const listText = failedNames.slice(0, 3).join(', ');
        pageImpactApiState.error = failedNames.length > 3
          ? `${failedNames.length} scans failed (e.g., ${listText}).`
          : `Failed to load data for ${listText || 'one or more scans'}.`;
      } else {
        pageImpactApiState.error = null;
      }
      lastApiFetchContext = {
        scanIds: new Set(getImpactScanIds()),
        timestamp: pageImpactApiState.timestamp
      };
    }

    logImpactApi('API request finished', { successCount: successes.length, errorCount: errors.length });
    updatePageImpactApiControls();
    if (pageImpactApiState.data.size) {
      await refreshMainView({ preserveState: true }).catch(err => {
        console.error(err);
        logImpactApi('Unable to refresh view after API load:', err?.message || err);
      });
    }
  }

  function formatScoreValue(value, fallback = '—') {
    return Number.isFinite(value) ? `${value.toFixed(1)}%` : fallback;
  }

  function extractScanIdFromLabel(label) {
    if (label == null) return null;
    const match = String(label).match(/\((\d+)\)\s*$/);
    return match ? match[1] : null;
  }

  function stripTrailingScanId(label) {
    if (label == null) return '';
    return String(label).replace(/\s*\(\d+\)\s*$/, '').trim();
  }

  function formatScanLabelWithId(label, id) {
    const safeLabel = label == null ? '' : String(label);
    if (!id) return safeLabel;
    const suffix = `(${id})`;
    if (safeLabel.includes(suffix)) return safeLabel;
    const spacer = safeLabel === '' || safeLabel.endsWith(' ') ? '' : ' ';
    return `${safeLabel}${spacer}${suffix}`;
  }

  function normalizeScanName(name) {
    return stripTrailingScanId(name).toLowerCase();
  }

  function buildRowLookup(rows) {
    const map = new Map();
    const idMap = new Map();
    rows.forEach(row => {
      const key = normalizeScanName(row.name);
      if (key && !map.has(key)) {
        map.set(key, row);
      }
      const rowId = getRowScanId(row);
      if (rowId && !idMap.has(rowId)) {
        idMap.set(rowId, row);
      }
    });
    map.idMap = idMap;
    return map;
  }

  function getRowByName(rowLookup, name) {
    if (!rowLookup || !name) return null;
    const id = extractScanIdFromLabel(name);
    if (id && rowLookup.idMap?.has(id)) {
      return rowLookup.idMap.get(id) || null;
    }
    return rowLookup.get(normalizeScanName(name)) || null;
  }

  function normalizeScanOptionKey(name) {
    return stripTrailingScanId(name)
      .replace(/\s+/g, ' ')
      .toLowerCase();
  }

  function getScanOptions(rowLookup) {
    const optionMap = new Map();
    const addOption = (input, idOverride = null) => {
      if (!input) return;
      const baseValue = typeof input === 'string'
        ? input
        : (input.value ?? input.label ?? '');
      if (!baseValue) return;
      const normalized = normalizeScanOptionKey(baseValue);
      if (!normalized) return;
      const baseLabel = typeof input === 'string'
        ? input
        : (input.label ?? baseValue);
      const explicitId = idOverride ?? (typeof input === 'object' ? input.id : null);
      const derivedId = explicitId
        ?? extractScanIdFromLabel(baseValue)
        ?? extractScanIdFromLabel(baseLabel);
      const formattedLabel = formatScanLabelWithId(baseLabel, derivedId);
      const formattedValue = formatScanLabelWithId(baseValue, derivedId);
      const existing = optionMap.get(normalized);
      if (existing) {
        if (!existing.id && derivedId) {
          existing.id = derivedId;
          existing.label = formatScanLabelWithId(existing.label, derivedId);
          existing.value = formatScanLabelWithId(existing.value, derivedId);
        }
        return;
      }
      optionMap.set(normalized, {
        label: formattedLabel,
        value: formattedValue,
        id: derivedId || null
      });
    };
    if (rowLookup) {
      rowLookup.forEach(row => {
        addOption(row?.name, getRowScanId(row));
      });
    }
    defaultWasReports.forEach(row => {
      addOption(row.desktop);
      addOption(row.mobile);
      addOption(row.pdf);
    });
    return Array.from(optionMap.values()).sort((a, b) => {
      const aLabel = a.label ?? a.value ?? '';
      const bLabel = b.label ?? b.value ?? '';
      return aLabel.localeCompare(bLabel, undefined, { sensitivity: 'base' });
    });
  }

  function ensureWasConfigDefaults() {
    const existingNames = new Set(wasConfig.map(row => row.name));
    defaultWasReports.forEach(defaultRow => {
      if (!existingNames.has(defaultRow.name)) {
        wasConfig.push({
          name: defaultRow.name,
          desktop: defaultRow.desktop,
          desktopId: null,
          mobile: defaultRow.mobile,
          mobileId: null,
          pdf: defaultRow.pdf,
          pdfId: null,
          enabled: true
        });
      }
    });
    wasConfig = wasConfig.map(row => {
      const fallback = defaultWasReports.find(def => def.name === row.name);
      return {
        name: row.name,
        desktop: row.desktop || fallback?.desktop || '',
        desktopId: row.desktopId ?? null,
        mobile: row.mobile || fallback?.mobile || '',
        mobileId: row.mobileId ?? null,
        pdf: row.pdf || fallback?.pdf || '',
        pdfId: row.pdfId ?? null,
        enabled: row.enabled !== false
      };
    });
  }

  function getEnabledWasRows() {
    return wasConfig.filter(row => row.enabled !== false);
  }

  function toAbsoluteUrl(url) {
    if (!url) return null;
    try {
      return new URL(url, location.origin).href;
    } catch (e) {
      return url;
    }
  }

  async function fetchWithRetry(task, attempts = 2) {
    let lastError;
    for (let i = 0; i < attempts; i++) {
      try {
        return await task(i);
      } catch (err) {
        lastError = err;
        logWas('Attempt', i + 1, 'failed:', err?.message || err);
      }
    }
    throw lastError;
  }

  function getNumericText(el) {
    if (!el) return null;
    const sources = [];
    const text = el.textContent;
    if (text) sources.push(text);
    const attrs = ['aria-label','title','data-count','data-total','data-value','data-number'];
    attrs.forEach(attr => {
      const val = el.getAttribute?.(attr);
      if (val) sources.push(val);
    });
    for (const source of sources) {
      const cleaned = source.replace(/,/g,'').trim();
      const match = cleaned.match(/-?\d+/);
      if (match) return parseInt(match[0], 10);
    }
    return null;
  }

  function anchorHref(anchor) {
    if (!anchor) return '';
    return anchor.getAttribute('href') || anchor.href || '';
  }

  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }

  function capitalize(word) {
    if (!word) return '';
    return word.charAt(0).toUpperCase() + word.slice(1);
  }

  function anchorMatchesImpact(anchor, impactValue) {
    const rawHref = anchorHref(anchor);
    const values = Array.isArray(impactValue) ? impactValue : [impactValue];
    const normalizedValues = values
      .map(v => String(v).trim())
      .filter(Boolean);
    if (!normalizedValues.length) return false;
    const lowercaseTargets = normalizedValues.map(v => v.toLowerCase());
    const dataAttrs = [
      anchor.getAttribute?.('data-impact'),
      anchor.getAttribute?.('data-impact-level'),
      anchor.getAttribute?.('data-severity'),
      anchor.dataset?.impact,
      anchor.dataset?.severity
    ].filter(Boolean);
    for (const attr of dataAttrs) {
      if (lowercaseTargets.includes(String(attr).toLowerCase())) return true;
    }
    if (!rawHref) return false;
    try {
      const url = new URL(rawHref, anchor.ownerDocument?.baseURI || location.origin);
      const keys = Array.from(url.searchParams.keys());
      for (const key of keys) {
        if (!/impact/i.test(key)) continue;
        const values = url.searchParams.getAll(key);
        for (const value of values) {
          const lower = String(value).toLowerCase();
          if (lowercaseTargets.includes(lower)) return true;
        }
      }
    } catch (err) {
      // ignore parse failures
    }
    const decoded = decodeURIComponent(rawHref).toLowerCase();
    return lowercaseTargets.some(target => {
      const pattern = new RegExp(`impact(?:\\[\\])?=${escapeRegExp(target)}`, 'i');
      return pattern.test(decoded);
    });
  }

  function anchorMatchesNeedsReview(anchor) {
    const rawHref = anchorHref(anchor);
    if (!rawHref) return false;
    try {
      const url = new URL(rawHref, anchor.ownerDocument?.baseURI || location.origin);
      for (const [key, value] of url.searchParams.entries()) {
        const pair = `${key}=${value}`.toLowerCase();
        if (pair.includes('needs') && pair.includes('review')) return true;
      }
    } catch (err) {
      // ignore parse failures
    }
    const decoded = decodeURIComponent(rawHref).toLowerCase();
    if (decoded.includes('needs') && decoded.includes('review')) return true;
    return anchorMatchesImpact(anchor, ['needsreview','needs_review','needs-review','needs review']);
  }

  function findNumericInScope(scope) {
    if (!scope) return null;
    const selectors = ['span','strong','div','p','a'];
    const candidates = selectors.flatMap(sel => Array.from(scope.querySelectorAll(sel)))
      .filter(el => el && !el.querySelector?.('svg'));
    for (let i = candidates.length - 1; i >= 0; i--) {
      const val = getNumericText(candidates[i]);
      if (val != null) return val;
    }
    return null;
  }

  function findCountByAnchor(doc, matcher) {
    if (!doc || typeof matcher !== 'function') return null;
    const anchors = Array.from(doc.querySelectorAll('a[href]'));
    for (const anchor of anchors) {
      let matched = false;
      try {
        matched = matcher(anchor);
      } catch (err) {
        matched = false;
      }
      if (!matched) continue;
      let value = getNumericText(anchor);
      if (value != null) return value;
      const scope = anchor.closest('li,div,section,article');
      value = findNumericInScope(scope);
      if (value != null) return value;
    }
    return null;
  }

  function findIssuesByImpactSection(doc) {
    if (!doc) return null;
    const selectors = [
      issuesSectionHintSelector,
      '#main-content section.Panel section > ul',
      '#main-content section.Panel section > section'
    ].filter(Boolean);
    for (const selector of selectors) {
      const candidate = doc.querySelector(selector);
      if (candidate) return candidate;
    }
    const criticalLabel = doc.querySelector('#issue-count-critical');
    if (criticalLabel) {
      const fromLabel = criticalLabel.closest('section,div,ul,ol');
      if (fromLabel) return fromLabel.closest('section,div') || fromLabel;
    }
    return Array.from(doc.querySelectorAll('section,div')).find(el => {
      const heading = el.querySelector('h2,h3,h4');
      return heading && /issues by impact/i.test(heading.textContent || '');
    }) || null;
  }

  function findPdfCriticalLabel(doc) {
    if (!doc) return null;
    const selectors = [
      '#pages-count-pages_with_critical_issues',
      pdfPanelHintSelector ? `${pdfPanelHintSelector} #pages-count-pages_with_critical_issues` : null
    ].filter(Boolean);
    for (const selector of selectors) {
      const candidate = doc.querySelector(selector);
      if (candidate) return candidate;
    }
    return null;
  }

  function extractIssueCounts(doc) {
    const labels = [
      { key: 'critical', id: 'issue-count-critical', regex: /critical/i, anchorMatch: anchor => anchorMatchesImpact(anchor, ['3','critical']) },
      { key: 'serious', id: 'issue-count-serious', regex: /serious/i, anchorMatch: anchor => anchorMatchesImpact(anchor, ['2','serious']) },
      { key: 'needsReview', id: 'issue-count-needsReview', regex: /needs\s*review/i, anchorMatch: anchorMatchesNeedsReview }
    ];
    const result = {};
    const issuesSection = findIssuesByImpactSection(doc);

    const scopes = [];
    if (issuesSection) scopes.push(issuesSection);
    scopes.push(doc);

    labels.forEach(label => {
      let value = null;
      if (label.anchorMatch) {
        value = findCountByAnchor(doc, label.anchorMatch);
      }
      if (value == null && label.id) {
        const described = doc.querySelector(`[aria-describedby="${label.id}"]`);
        if (described) value = getNumericText(described);
      }
      if (value == null && label.id) {
        const region = doc.querySelector(`#${label.id}`)?.closest('li,div,section');
        value = findNumericInScope(region);
      }
      if (value == null) {
        for (const scope of scopes) {
          const match = Array.from(scope.querySelectorAll('li,div,section')).find(el => label.regex.test(el.textContent || ''));
          value = findNumericInScope(match);
          if (value != null) break;
        }
      }
      if (value == null) {
        logWas('Missing value for', label.key);
        value = 0;
      }
      result[label.key] = value;
    });
    return result;
  }

  function extractPdfCritical(doc) {
    let val = findCountByAnchor(doc, anchor => anchorMatchesImpact(anchor, ['3','critical']));
    if (val == null) {
      const labelNode = findPdfCriticalLabel(doc);
      let target = doc.querySelector('[aria-describedby="pages-count-pages_with_critical_issues"]');
      if (!target && labelNode?.parentElement) {
        const candidate = labelNode.parentElement.querySelector('a, span, strong');
        if (candidate) target = candidate;
      }
      if (!target && labelNode) {
        const neighbor = labelNode.previousElementSibling || labelNode.nextElementSibling;
        if (neighbor) {
          const candidate = neighbor.querySelector?.('a, span, strong') || neighbor;
          const numeric = getNumericText(candidate);
          if (numeric != null) {
            val = numeric;
          } else {
            val = findNumericInScope(neighbor);
          }
        }
      }
      if (val == null && labelNode) {
        val = findNumericInScope(labelNode.closest('div,section') || labelNode);
      }
      if (!target && val == null) throw new Error('Missing pages with critical issues');
      if (val == null) val = getNumericText(target);
    }
    return Number.isFinite(val) ? val : 0;
  }

  async function fetchIssueCountsForScan(row, { signal } = {}) {
    const metrics = await fetchRunMetricsForRow(row, { signal });
    return {
      critical: coerceNumber(metrics.critical, 0),
      serious: coerceNumber(metrics.serious, 0),
      needsReview: coerceNumber(metrics.needsReview, 0),
      status: metrics.status || metrics.run?.status || '',
      runNumber: metrics.run?.runNumber ?? null,
      scanUrl: row?.url || null
    };
  }

  async function fetchPdfCountsForScan(row, { signal } = {}) {
    const metrics = await fetchRunMetricsForRow(row, { signal });
    return {
      criticalPages: coerceNumber(metrics.pagesCritical, 0),
      status: metrics.status || metrics.run?.status || '',
      runNumber: metrics.run?.runNumber ?? null,
      scanUrl: row?.url || null
    };
  }

  async function loadWasMetrics(rowLookup, rowsToProcess, { onProgress, signal } = {}) {
    const activeRows = (rowsToProcess || wasConfig).filter(row => row.enabled !== false);
    const total = activeRows.length;
    const results = [];
    for (let i = 0; i < activeRows.length; i++) {
      if (signal?.aborted) {
        const error = new Error('cancelled');
        error.name = 'AbortError';
        throw error;
      }
      const report = activeRows[i];
      onProgress?.({ current: i, total, name: report.name, status: 'start' });
      const record = { name: report.name };
      const desktopRow = getRowByName(rowLookup, report.desktop);
      const mobileRow = getRowByName(rowLookup, report.mobile);
      const pdfRow = getRowByName(rowLookup, report.pdf);
      const safeFetch = async task => {
        try {
          return await fetchWithRetry(task, 2);
        } catch (err) {
          if (err?.name === 'AbortError') throw err;
          return { error: err?.message || 'Error getting number' };
        }
      };
      record.desktop = await safeFetch(() => fetchIssueCountsForScan(desktopRow, { signal }));
      record.mobile = await safeFetch(() => fetchIssueCountsForScan(mobileRow, { signal }));
      record.pdf = await safeFetch(() => fetchPdfCountsForScan(pdfRow, { signal }));
      if (record.desktop?.error || record.mobile?.error || record.pdf?.error) {
        logWas('Incomplete data for', report.name, 'desktop:', record.desktop?.error, 'mobile:', record.mobile?.error, 'pdf:', record.pdf?.error);
      }
      results.push(record);
      onProgress?.({ current: i + 1, total, name: report.name, status: 'done' });
    }
    return results;
  }

  function getDefaultAccordionState(tabKey) {
    if (tabKey === 'status') {
      return { 'Scan Status': true };
    }
    if (tabKey === 'quick' && pageContext === 'issues') {
      return { 'Assign Issues by Page': true };
    }
    return {};
  }

  const scoreBucketSpecs = [
    { label: '100%', min: 100, max: 100 },
    { label: '95-99%', min: 95, max: 99.999 },
    { label: '90-94%', min: 90, max: 94.999 },
    { label: '80-89%', min: 80, max: 89.999 },
    { label: '70-79%', min: 70, max: 79.999 },
    { label: '60-69%', min: 60, max: 69.999 },
    { label: '50-59%', min: 50, max: 59.999 },
    { label: '40-49%', min: 40, max: 49.999 },
    { label: '30-39%', min: 30, max: 39.999 },
    { label: '20-29%', min: 20, max: 29.999 },
    { label: '<20%', min: null, max: 19.999 }
  ];

  function makeScoreBuckets() {
    const buckets = {};
    scoreBucketSpecs.forEach(spec => { buckets[spec.label] = 0; });
    return buckets;
  }

  function getScoreBucketLabel(scoreVal) {
    if (!Number.isFinite(scoreVal)) return null;
    for (const spec of scoreBucketSpecs) {
      const meetsMin = spec.min == null ? true : scoreVal >= spec.min - 1e-9;
      const meetsMax = spec.max == null ? true : scoreVal <= spec.max + 1e-9;
      if (meetsMin && meetsMax) return spec.label;
    }
    return '<20%';
  }

  function pctOf(count, denom) {
    if (!denom) return '0.0%';
    return ((count / denom) * 100).toFixed(1) + '%';
  }

  function lerpColor(c1, c2, t) {
    function parse(c) {
      const m = c.trim().match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
      return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [0,0,0];
    }
    const [r1,g1,b1] = parse(c1);
    const [r2,g2,b2] = parse(c2);
    const r = Math.round(r1 + (r2 - r1) * t);
    const g = Math.round(g1 + (g2 - g1) * t);
    const b = Math.round(b1 + (b2 - b1) * t);
    return `rgb(${r},${g},${b})`;
  }

  function getSeverityColorForBand(band, order) {
    const idx = order.indexOf(band);
    if (idx === -1) return 'var(--metric-accent-mid)';
    const t = order.length > 1 ? idx / (order.length - 1) : 0;
    const good = getComputedStyle(document.documentElement).getPropertyValue('--metric-accent-full') || '#a5db75';
    const bad = getComputedStyle(document.documentElement).getPropertyValue('--accent-danger') || '#fe6d6b';
    return lerpColor(good, bad, t);
  }

  function parseRunsInProgress() {
    const expandButtons = Array.from(document.querySelectorAll('.ExpandCollapse__trigger'));
    const progressButton = expandButtons.find(btn =>
      /scan runs in progress/i.test(btn.textContent || '')
    );
    const tables = [];
    if (progressButton) {
      const container = progressButton.closest('.ExpandCollapse');
      if (container) {
        tables.push(...container.querySelectorAll('table'));
      }
    }
    if (!tables.length) {
      tables.push(...document.querySelectorAll('table.Table--border'));
    }
    const headersNeeded = ['scan name','started','pages scanned in the last hour','total pages scanned'];

    let matches = [];
    tables.forEach(table => {
      const headCells = Array.from(table.querySelectorAll('thead th'));
      if (!headCells.length) return;
      const map = headCells.map((th, idx) => ({
        idx,
        text: th.textContent.trim().toLowerCase()
      }));
      const hasAll = headersNeeded.every(h => map.some(m => m.text.includes(h)));
      if (!hasAll) return;
      const getIdx = label => {
        const found = map.find(m => m.text.includes(label));
        return found ? found.idx : -1;
      };
      const nameIdx = getIdx('scan name');
      const startedIdx = getIdx('started');
      const hourIdx = getIdx('pages scanned in the last hour');
      const totalIdx = getIdx('total pages scanned');
      Array.from(table.querySelectorAll('tbody tr')).forEach(tr => {
        const cells = Array.from(tr.querySelectorAll('td,th'));
        if (!cells.length) return;
        const nameCell = cells[nameIdx];
        const link = nameCell?.querySelector('a');
        matches.push({
          name: nameCell?.textContent.trim() || '',
          url: link?.href || null,
          started: startedIdx !== -1 ? (cells[startedIdx]?.textContent.trim() || '') : '',
          perHour: hourIdx !== -1 ? (cells[hourIdx]?.textContent.trim() || '') : '',
          totalPages: totalIdx !== -1 ? (cells[totalIdx]?.textContent.trim() || '') : ''
        });
      });
    });

    const buttonCountMatch = progressButton?.textContent.match(/\((\d+)\)/);
    const total = buttonCountMatch ? parseInt(buttonCountMatch[1], 10) : matches.length;

    return { runs: matches, total };
  }

  function setBackgroundInert(excludeEl) {
    Array.from(document.body.children).forEach(el => {
      if (el === root) return;
      if (el.contains(excludeEl)) return;
      if (!el.hasAttribute('inert')) {
        el.setAttribute('inert','');
        el.setAttribute('aria-hidden','true');
        el.setAttribute(inertAttr,'true');
      }
    });
  }

  function clearBackgroundInert() {
    Array.from(document.body.children).forEach(el => {
      if (el.hasAttribute(inertAttr)) {
        el.removeAttribute('inert');
        el.removeAttribute('aria-hidden');
        el.removeAttribute(inertAttr);
      }
    });
  }

  function sanitizePageImpactSelection(keys) {
    if (!Array.isArray(keys)) return [];
    const valid = new Set(pageImpactFilterOptions.map(option => option.key));
    const cleaned = [];
    keys.forEach(key => {
      if (!valid.has(key)) return;
      if (cleaned.includes(key)) return;
      cleaned.push(key);
    });
    return cleaned;
  }

  function getAllowedImpactKeysForSource(source, { scopedToView = false } = {}) {
    const key = source === 'api' ? 'api' : 'website';
    const allowedBase = pageImpactSourceAllowedKeys[key] || pageImpactSourceAllowedKeys[defaultPageImpactSource];
    const allowed = new Set(allowedBase);
    if (!scopedToView) return allowed;
    if (isPagesTabActive()) {
      const filtered = new Set();
      pagesTabImpactKeys.forEach(value => {
        if (allowed.has(value)) {
          filtered.add(value);
        }
      });
      return filtered.size ? filtered : allowed;
    }
    return allowed;
  }

  function getDefaultImpactsForSource(source = defaultPageImpactSource) {
    const allowed = getAllowedImpactKeysForSource(source);
    return pageImpactFilterOptions
      .map(option => option.key)
      .filter(key => allowed.has(key));
  }

  function getDefaultImpactsForView(source = defaultPageImpactSource) {
    const allowed = getAllowedImpactKeysForSource(source, { scopedToView: true });
    const defaults = pageImpactFilterOptions
      .map(option => option.key)
      .filter(key => allowed.has(key));
    return defaults.length ? defaults : Array.from(allowed);
  }

  function normalizeSelectionForSource(keys, source) {
    const allowed = getAllowedImpactKeysForSource(source);
    const list = Array.isArray(keys) ? keys.slice() : Array.from(keys || []);
    const cleaned = [];
    pageImpactFilterOptions.forEach(option => {
      if (!allowed.has(option.key)) return;
      if (!list.includes(option.key)) return;
      if (cleaned.includes(option.key)) return;
      cleaned.push(option.key);
    });
    return cleaned;
  }

  function loadStoredPageImpactFilters() {
    try {
      const raw = localStorage.getItem(pageImpactFilterStorageKey);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      let storedSelection = [];
      let storedSource = defaultPageImpactSource;
      if (Array.isArray(parsed)) {
        storedSelection = sanitizePageImpactSelection(parsed);
      } else if (parsed && typeof parsed === 'object') {
        storedSelection = sanitizePageImpactSelection(parsed.selection);
        if (parsed.source === 'api' || parsed.source === 'website') {
          storedSource = parsed.source;
        }
      } else {
        return;
      }
      const normalized = normalizeSelectionForSource(storedSelection, storedSource);
      const finalSelection = normalized.length ? normalized : getDefaultImpactsForSource(storedSource);
      pageImpactFilterState.source = storedSource;
      pageImpactFilterState.selection = new Set(finalSelection);
      persistPageImpactFilters(finalSelection, storedSource);
    } catch (err) {
      // ignore storage access errors
    }
  }

  function persistPageImpactFilters(selectionKeys, source = pageImpactFilterState.source) {
    try {
      const keys = Array.isArray(selectionKeys) ? selectionKeys.slice() : Array.from(selectionKeys || []);
      const payload = {
        selection: keys,
        source
      };
      localStorage.setItem(pageImpactFilterStorageKey, JSON.stringify(payload));
    } catch (err) {
      // ignore storage access errors
    }
  }

  function applyPageImpactFilter(selectionKeys, source) {
    const normalizedSource = (source === 'api' || source === 'website') ? source : defaultPageImpactSource;
    pageImpactFilterState.source = normalizedSource;
    setPageImpactSelection(selectionKeys, normalizedSource);
  }

  function setPageImpactSelection(keys, source = pageImpactFilterState.source) {
    const cleaned = sanitizePageImpactSelection(Array.isArray(keys) ? keys : Array.from(keys || []));
    const normalized = normalizeSelectionForSource(cleaned, source);
    const next = normalized.length ? normalized : getDefaultImpactsForSource(source);
    pageImpactFilterState.selection = new Set(next);
    persistPageImpactFilters(next, source);
  }

  function setPageImpactSource(source) {
    const normalizedSource = (source === 'api' || source === 'website') ? source : defaultPageImpactSource;
    if (normalizedSource === 'api' && isPagesTabActive()) {
      return;
    }
    const prevSource = getPageImpactSource();
    let nextSelection = Array.from(pageImpactFilterState.selection || []);
    if (normalizedSource === 'api' && prevSource !== 'api') {
      const defaults = getDefaultImpactsForSource('api');
      defaults.forEach(key => {
        if (!nextSelection.includes(key)) nextSelection.push(key);
      });
    }
    applyPageImpactFilter(nextSelection, normalizedSource);
  }

  function getPageImpactSource() {
    return pageImpactFilterState.source || defaultPageImpactSource;
  }

  function getPageImpactSourceForView() {
    if (isPagesTabActive()) {
      return defaultPageImpactSource;
    }
    return getPageImpactSource();
  }

  function getPageImpactSourceLabel(source = getPageImpactSource()) {
    const option = pageImpactSourceOptions.find(entry => entry.key === source);
    if (option) return option.label;
    const fallback = pageImpactSourceOptions.find(entry => entry.key === defaultPageImpactSource);
    return fallback ? fallback.label : source;
  }

  function getActivePageImpactSet() {
    const source = getPageImpactSource();
    if (!pageImpactFilterState.selection || !pageImpactFilterState.selection.size) {
      const defaults = getDefaultImpactsForSource(source);
      pageImpactFilterState.selection = new Set(defaults);
      persistPageImpactFilters(defaults, source);
    }
    const currentKeys = Array.from(pageImpactFilterState.selection);
    const normalized = normalizeSelectionForSource(currentKeys, source);
    if (normalized.length !== currentKeys.length || normalized.some((key, idx) => key !== currentKeys[idx])) {
      const finalKeys = normalized.length ? normalized : getDefaultImpactsForSource(source);
      pageImpactFilterState.selection = new Set(finalKeys);
      persistPageImpactFilters(finalKeys, source);
    }
    const viewAllowed = getAllowedImpactKeysForSource(source, { scopedToView: true });
    let finalViewKeys = normalized.filter(key => viewAllowed.has(key));
    if (!finalViewKeys.length) {
      finalViewKeys = getDefaultImpactsForView(source);
    }
    return new Set(finalViewKeys);
  }

  function getRowScanId(row) {
    if (!row) return null;
    if (row.scanId != null && row.scanId !== '') return String(row.scanId);
    const url = row.url || row.scanUrl || '';
    const id = extractScanIdFromUrl(url);
    return id ? String(id) : null;
  }

  function getImpactScanRows() {
    const map = new Map();
    const addRow = row => {
      const id = getRowScanId(row);
      if (!id) return;
      if (!map.has(id)) {
        map.set(id, row);
      }
    };
    const issueRows = Array.isArray(lastRenderedData?.filtered) ? lastRenderedData.filtered : [];
    issueRows.forEach(addRow);
    const pageRows = Array.isArray(lastRenderedData?.pagesSummary?.filtered) ? lastRenderedData.pagesSummary.filtered : [];
    pageRows.forEach(addRow);
    return map;
  }

  function getImpactScanIds() {
    return Array.from(getImpactScanRows().keys());
  }

  function getPageImpactApiRecord(rowOrId) {
    if (!rowOrId) return null;
    const key = typeof rowOrId === 'string' ? rowOrId : getRowScanId(rowOrId);
    if (!key) return null;
    return pageImpactApiState.data.get(String(key)) || null;
  }

  function getPageImpactApiCoverage() {
    const ids = getImpactScanIds();
    const total = ids.length;
    let available = 0;
    ids.forEach(id => {
      if (pageImpactApiState.data.has(id)) available += 1;
    });
    const missing = total - available;
    return { total, available, missing };
  }

  function isMonitorApiDataReady() {
    if (pageImpactApiState.status === 'loading') return false;
    const coverage = getPageImpactApiCoverage();
    if (!coverage.total || coverage.missing > 0) return false;
    return pageImpactApiState.data.size >= coverage.total;
  }

  function setFooterBaseTimestamp(value) {
    pageImpactFilterState.footerBaseTimestamp = value || '';
  }

  function setFooterRefreshMessage(message) {
    const info = pageImpactFilterState.footerInfoEl;
    if (!info) return;
    const base = pageImpactFilterState.footerBaseTimestamp || new Date().toLocaleString();
    const finalText = message || `Last data refresh: ${base}`;
    info.textContent = finalText;
  }

  function selectionHasMonitorApiOnlyImpacts(selection) {
    if (!selection) return false;
    const values = selection instanceof Set
      ? Array.from(selection)
      : Array.isArray(selection)
        ? selection.slice()
        : [selection];
    return values.some(key => monitorApiOnlyImpactKeys.has(key));
  }

  async function ensureMonitorApiDataAvailability({ reason = 'toggle', selection } = {}) {
    if (isMonitorApiDataReady()) return true;
    if (pageImpactApiState.status === 'loading') return true;
    if (selection && !selectionHasMonitorApiOnlyImpacts(selection)) {
      return true;
    }
    const coverage = getPageImpactApiCoverage();
    const missingText = coverage.total
      ? `${coverage.missing} of ${coverage.total} scans are missing Monitor API data.`
      : 'Monitor API data has not been requested for the scans shown on this page yet.';
    const intro = reason === 'filter'
      ? 'Moderate and Minor impacts require data from the Monitor API.'
      : 'Switching to the Monitor API enables Moderate and Minor impacts.';
    const confirmed = await openSimpleDialog({
      title: 'Load Monitor API data',
      message: `${intro}\n\n${missingText}\n\nLoad data from the API now?`,
      primaryLabel: 'Load missing data',
      secondaryLabel: 'Not now'
    });
    if (!confirmed) return false;
    try {
      await requestPageImpactApiData({ mode: 'missing' });
      if (!getStoredMonitorApiKey()) {
        return false;
      }
      return true;
    } catch (err) {
      console.error(err);
      return false;
    }
  }

  async function openMonitorApiMissingDialog({ missing, total }) {
    if (!missing) return;
    const plural = total === 1 ? 'scan' : 'scans';
    const message = `Monitor API data is missing for ${missing} of ${total} ${plural}. Moderate and Minor impacts will remain blank until the data loads.\n\nLoad the missing data now?`;
    const confirmed = await openSimpleDialog({
      title: 'Monitor API data missing',
      message,
      primaryLabel: 'Load missing data',
      secondaryLabel: 'Close'
    });
    if (!confirmed) return;
    try {
      await requestPageImpactApiData({ mode: 'missing' });
    } catch (err) {
      console.error(err);
    }
  }

  function getActivePageImpactKeys() {
    return Array.from(getActivePageImpactSet());
  }

  function isPageImpactEnabled(key) {
    return getActivePageImpactSet().has(key);
  }

  function formatPageImpactSelection(keys = getActivePageImpactKeys()) {
    if (!keys || !keys.length) return 'None';
    const active = new Set(keys);
    const labels = pageImpactFilterOptions
      .filter(option => active.has(option.key))
      .map(option => option.label);
    return labels.join(', ') || 'None';
  }

  function getFocusable(container) {
    return Array.from(container.querySelectorAll(
      'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), summary, [tabindex]:not([tabindex="-1"])'
    ));
  }

  function buildDomainHierarchy(domains) {
    const order = [];
    const map = new Map();
    domains.forEach((domain, idx) => {
      const [firstSegment] = domain.split(' - ');
      const parentKey = (firstSegment || domain).trim();
      let entry = map.get(parentKey);
      if (!entry) {
        entry = {
          label: parentKey,
          children: [],
          hasNested: false,
          firstIndex: idx,
        };
        map.set(parentKey, entry);
        order.push(entry);
      }
      const isNested = domain.includes(' - ');
      if (isNested) entry.hasNested = true;
      entry.children.push({ label: domain, value: domain, order: idx });
    });

    order.sort((a, b) => a.firstIndex - b.firstIndex);

    const normalized = [];
    order.forEach(entry => {
      entry.children.sort((a, b) => a.order - b.order);
      if (entry.hasNested) {
        normalized.push({
          type: 'group',
          label: entry.label,
          children: entry.children.map(child => ({
            label: child.label,
            value: child.value,
          })),
        });
      } else {
        entry.children.forEach(child => {
          normalized.push({
            type: 'single',
            label: child.label,
            value: child.value,
          });
        });
      }
    });

    return normalized;
  }

  function appendOverlayAfterFooter(overlay) {
    const footer = document.querySelector('footer');
    const parent = footer?.parentNode || document.body;
    const existingOverlays = Array.from(parent.querySelectorAll('.a11y-scan-report-overlay, .a11y-filter-overlay'));
    const anchor = existingOverlays.length
      ? existingOverlays[existingOverlays.length - 1]
      : footer;
    if (anchor) {
      anchor.parentNode.insertBefore(overlay, anchor.nextSibling);
    } else {
      parent.appendChild(overlay);
    }
  }

  const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
  function throwIfAborted(signal) {
    if (signal?.aborted) {
      const error = new Error('Operation cancelled');
      error.name = 'AbortError';
      throw error;
    }
  }

  async function waitForCondition(checkFn, { timeout = 5000, interval = 100 } = {}) {
    const start = Date.now();
    return new Promise((resolve, reject) => {
      (function check() {
        let result = null;
        try {
          result = checkFn();
        } catch (err) {
          // swallow errors until timeout
        }
        if (result) {
          resolve(result);
          return;
        }
        if (Date.now() - start >= timeout) {
          reject(new Error('Timed out waiting for condition.'));
          return;
        }
        setTimeout(check, interval);
      })();
    });
  }

  async function waitForElement(selector, { timeout = 5000, root = document } = {}) {
    return waitForCondition(() => {
      return root.querySelector(selector);
    }, { timeout });
  }

  function getPaginationContainer() {
    return document.querySelector('#main-content .Pagination') ||
      document.querySelector('.Pagination');
  }

  function getPageSizeSelect() {
    return document.querySelector('#page-size-select-3') ||
      document.querySelector('select[id^="page-size-select"]');
  }

  function getPaginationStatus() {
    const container = getPaginationContainer();
    if (!container) return null;
    const logEl =
      container.querySelector('[role="log"]') ||
      container.querySelector('span') ||
      container;
    if (!logEl) return null;
    const text = (logEl.textContent || '').trim();
    const parseNumber = value => {
      if (value == null) return null;
      const normalized = String(value).replace(/,/g,'').trim();
      const parsed = parseInt(normalized, 10);
      return Number.isNaN(parsed) ? null : parsed;
    };
    const strongValues = Array.from(logEl.querySelectorAll('strong'))
      .map(el => parseNumber(el.textContent))
      .filter(val => val != null);
    let start = null;
    let end = null;
    let total = null;
    if (strongValues.length >= 3) {
      [start, end, total] = strongValues;
    } else {
      const normalized = text.replace(/,/g,'');
      const match = normalized.match(/(\d+)[^\d]+(\d+)[^\d]+(\d+)/);
      if (match) {
        start = parseInt(match[1], 10);
        end = parseInt(match[2], 10);
        total = parseInt(match[3], 10);
      }
    }
    return { start, end, total, text };
  }

  async function waitForPaginationAdvance(previousStatus, delayMs = 1000) {
    await wait(delayMs);
    const nextStatus = getPaginationStatus();
    if (
      previousStatus &&
      nextStatus &&
      previousStatus.start === nextStatus.start &&
      previousStatus.end === nextStatus.end
    ) {
      logCopyPageUrls('Pagination status unchanged after delay', {
        previous: previousStatus,
        next: nextStatus
      });
    }
    return nextStatus || previousStatus || null;
  }

  function getTableSignature() {
    const table = findScansTable();
    if (!table) return '';
    const rows = Array.from(table.querySelectorAll('tbody tr'))
      .slice(0, 5)
      .map(tr => tr.textContent.trim().slice(0, 120))
      .join('|');
    const count = table.querySelectorAll('tbody tr').length;
    return `${rows}::${count}`;
  }

  async function waitForTableChange(prevSignature, timeout = 7000) {
    const start = Date.now();
    return new Promise(resolve => {
      (function check() {
        const current = getTableSignature();
        if (!prevSignature || current !== prevSignature) {
          resolve(true);
          return;
        }
        if (Date.now() - start > timeout) {
          resolve(false);
          return;
        }
        requestAnimationFrame(check);
      })();
    });
  }

  function findIssuesTable() {
    const tables = Array.from(document.querySelectorAll('#main-content table, table'));
    for (const table of tables) {
      const headers = Array.from(table.querySelectorAll('thead th')).map(th =>
        (th.textContent || '').trim().toLowerCase()
      );
      if (!headers.length) continue;
      const hasPageUrl = headers.some(text => text.includes('page') && text.includes('url'));
      const looksLikeIssues = headers.some(text => /issue|status|priority|page url/.test(text));
      if (hasPageUrl && looksLikeIssues) return table;
    }
    return tables[0] || null;
  }

  function getIssuesTableSignature() {
    const table = findIssuesTable();
    if (!table) return '';
    const rows = Array.from(table.querySelectorAll('tbody tr'))
      .slice(0, 5)
      .map(tr => tr.textContent.trim().slice(0, 160))
      .join('|');
    const count = table.querySelectorAll('tbody tr').length;
    return `${rows}::${count}`;
  }

  function findPagesTable() {
    const tables = Array.from(document.querySelectorAll('#main-content table, table'));
    for (const table of tables) {
      const headers = Array.from(table.querySelectorAll('thead th')).map(th =>
        (th.textContent || '').trim().toLowerCase()
      );
      if (!headers.length) continue;
      const hasPageUrl = headers.some(text => text.includes('page url') || (text.includes('page') && text.includes('url')));
      if (hasPageUrl) return table;
    }
    return null;
  }

  function getPagesTableSignature() {
    const table = findPagesTable();
    if (!table) return '';
    const rows = Array.from(table.querySelectorAll('tbody tr'))
      .slice(0, 5)
      .map(tr => tr.textContent.trim().slice(0, 160))
      .join('|');
    const count = table.querySelectorAll('tbody tr').length;
    return `${rows}::${count}`;
  }

  async function waitForPagesTableChange(prevSignature, timeout = 8000) {
    const start = Date.now();
    return new Promise(resolve => {
      (function check() {
        const current = getPagesTableSignature();
        if (!prevSignature || current !== prevSignature) {
          resolve(true);
          return;
        }
        if (Date.now() - start > timeout) {
          resolve(false);
          return;
        }
        requestAnimationFrame(check);
      })();
    });
  }

  async function waitForPagesTable({ timeout = 8000 } = {}) {
    return waitForCondition(() => findPagesTable(), { timeout }).catch(() => findPagesTable());
  }

  function readPageUrlFromCell(cell) {
    if (!cell) return '';
    const text = cell.textContent ? cell.textContent.trim() : '';
    if (text) return text;
    const anchor = cell.querySelector?.('a');
    if (anchor) {
      const anchorText = (anchor.textContent || '').trim();
      if (anchorText) return anchorText;
      const href = anchor.getAttribute('href') || anchor.href || '';
      if (href) return href;
    }
    const dataValue = cell.getAttribute?.('data-value') || cell.getAttribute?.('aria-label') || '';
    return dataValue ? dataValue.trim() : '';
  }

  function extractPageUrlsFromTable(table) {
    if (!table) return [];
    const headers = Array.from(table.querySelectorAll('thead th'));
    const rows = Array.from(table.querySelectorAll('tbody tr'));
    const headerMap = headers.map((th, idx) => ({
      idx,
      text: (th.textContent || '').trim().toLowerCase()
    }));
    const urlHeader = headerMap.find(entry =>
      entry.text.includes('page url') ||
      (entry.text.includes('page') && entry.text.includes('url'))
    );
    const urlIdx = urlHeader ? urlHeader.idx : -1;
    const urls = [];
    rows.forEach(row => {
      const cols = Array.from(row.querySelectorAll('td,th'));
      if (!cols.length) return;
      const targetCell =
        (urlIdx >= 0 && cols[urlIdx]) ||
        cols.find(col => /url/i.test(col.textContent || '') || col.querySelector('a'));
      const value = readPageUrlFromCell(targetCell);
      if (value) urls.push(value);
    });
    return urls;
  }

  function isPdfUrl(url) {
    if (!url) return false;
    const cleaned = url.split('#')[0].split('?')[0];
    return /\.pdf$/i.test(cleaned);
  }

  function normalizePdfUrl(url) {
    if (!url) return '';
    try {
      return new URL(url, location.origin).href;
    } catch (err) {
      return url;
    }
  }

  function filterPdfUrls(urls) {
    const deduped = [];
    const seen = new Set();
    urls.forEach(url => {
      const normalized = normalizePdfUrl(url);
      if (!normalized) return;
      if (!isPdfUrl(normalized)) return;
      const key = normalized.toLowerCase();
      if (seen.has(key)) return;
      seen.add(key);
      deduped.push(normalized);
    });
    return deduped;
  }

  function normalizeNameForMatch(value) {
    if (!value) return '';
    let base = value.replace(/[#?].*$/, '');
    try {
      base = decodeURIComponent(base);
    } catch (err) {
      // ignore decode errors
    }
    return base.replace(/\s+/g, ' ').trim().toLowerCase();
  }

  function getUrlMatchKey(url) {
    if (!url) return '';
    let target = url;
    try {
      const parsed = new URL(url, location.origin);
      target = parsed.pathname.split('/').pop() || '';
    } catch (err) {
      target = url.split('/').pop() || url;
    }
    return normalizeNameForMatch(target);
  }

  function getFileMatchKey(filename) {
    if (!filename) return '';
    return normalizeNameForMatch(filename);
  }

  function parseUserDateInput(value) {
    const raw = (value || '').trim();
    if (!raw) return null;
    if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) {
      const parts = raw.split('-').map(Number);
      const date = new Date(parts[0], parts[1] - 1, parts[2]);
      return Number.isNaN(date.getTime()) ? null : date;
    }
    const match = raw.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
    if (match) {
      const month = parseInt(match[1], 10);
      const day = parseInt(match[2], 10);
      const year = parseInt(match[3], 10);
      const date = new Date(year, month - 1, day);
      if (Number.isNaN(date.getTime())) return null;
      if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
        return null;
      }
      return date;
    }
    const parsed = new Date(raw);
    return Number.isNaN(parsed.getTime()) ? null : parsed;
  }

  function formatPdfDateDisplay(date) {
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) return 'Unknown';
    return date.toLocaleString();
  }

  function formatFilterShort(filter) {
    if (!filter) return '';
    if (filter.mode === 'before') {
      return `Before ${formatPdfDateDisplay(filter.start)}`;
    }
    if (filter.mode === 'after') {
      return `After ${formatPdfDateDisplay(filter.start)}`;
    }
    if (filter.mode === 'between') {
      return `Between ${formatPdfDateDisplay(filter.start)} – ${formatPdfDateDisplay(filter.end)}`;
    }
    return '';
  }

  function describePdfFilter(filter) {
    if (!filter) return '';
    if (filter.mode === 'before') {
      return `before ${formatPdfDateDisplay(filter.start)}`;
    }
    if (filter.mode === 'after') {
      return `after ${formatPdfDateDisplay(filter.start)}`;
    }
    if (filter.mode === 'between') {
      return `between ${formatPdfDateDisplay(filter.start)} and ${formatPdfDateDisplay(filter.end)}`;
    }
    return '';
  }

  function evaluatePdfFilter(date, filter) {
    if (!filter || !(date instanceof Date) || Number.isNaN(date.getTime())) return false;
    if (filter.mode === 'before') {
      return date.getTime() <= filter.start.getTime();
    }
    if (filter.mode === 'after') {
      return date.getTime() >= filter.start.getTime();
    }
    if (filter.mode === 'between') {
      return date.getTime() >= filter.start.getTime() && date.getTime() <= filter.end.getTime();
    }
    return false;
  }

  function pushPdfLog(message, type = 'info') {
    pdfInspectorState.log.unshift({ message, type, timestamp: Date.now() });
    pdfInspectorState.log = pdfInspectorState.log.slice(0, 200);
    pdfInspectorState.render?.();
    logPdfInspector(message);
  }

  function attemptDateFromParts({ year, month = 1, day = 1, hour = 0, minute = 0, second = 0, offset }) {
    if (!year) return null;
    const pad = n => String(n).padStart(2, '0');
    let iso = `${year}-${pad(month)}-${pad(day)}T${pad(hour)}:${pad(minute)}:${pad(second)}`;
    if (offset) {
      iso += offset;
    } else {
      iso += 'Z';
    }
    const d = new Date(iso);
    if (!Number.isNaN(d.getTime())) return d;
    return null;
  }

  function normalizeTimezoneSuffix(offset) {
    if (!offset) return '';
    if (offset === 'Z' || offset === 'z') return 'Z';
    const cleaned = offset.replace(/'/g, '');
    if (!/^[+\-]\d{2}\d{2}$/.test(cleaned)) return '';
    return `${cleaned.slice(0, 3)}:${cleaned.slice(3)}`;
  }

  function parsePdfDDate(value) {
    const match = value.match(/^D:(\d{4})(\d{2})?(\d{2})?(\d{2})?(\d{2})?(\d{2})?([Zz]|[+\-]\d{2}'?\d{2}'?)?/);
    if (!match) return null;
    const [
      ,
      year,
      month = '01',
      day = '01',
      hour = '00',
      minute = '00',
      second = '00',
      offset
    ] = match;
    const tz = normalizeTimezoneSuffix(offset);
    return attemptDateFromParts({
      year,
      month,
      day,
      hour,
      minute,
      second,
      offset: tz || undefined
    });
  }

  function parseSlashDate(value, assumeDayFirst = false) {
    const match = value.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:[\sT]+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
    if (!match) return null;
    let month = parseInt(match[1], 10);
    let day = parseInt(match[2], 10);
    if (assumeDayFirst) {
      day = parseInt(match[1], 10);
      month = parseInt(match[2], 10);
    }
    const year = parseInt(match[3], 10);
    const hour = match[4] ? parseInt(match[4], 10) : 0;
    const minute = match[5] ? parseInt(match[5], 10) : 0;
    const second = match[6] ? parseInt(match[6], 10) : 0;
    const date = new Date(year, month - 1, day, hour, minute, second);
    if (Number.isNaN(date.getTime())) return null;
    return date;
  }

  function parsePdfMetadataDate(rawValue) {
    if (!rawValue) return null;
    let value = String(rawValue).replace(/\u0000/g, '').trim();
    if (!value) return null;
    if (/^D:/i.test(value)) {
      const parsed = parsePdfDDate(value);
      if (parsed) return parsed;
    }
    value = value.replace(/^['"<\[]+/, '').replace(/['">\]]+$/, '').trim();
    const normalizedIso = value.replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
    const isoMatch = normalizedIso.match(/^(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2}:\d{2})(Z|[+\-]\d{2}:?\d{2})?$/);
    if (isoMatch) {
      const tz = isoMatch[3] ? isoMatch[3].replace(/(\d{2})(\d{2})$/, '$1:$2') : 'Z';
      const date = new Date(`${isoMatch[1]}T${isoMatch[2]}${tz}`);
      if (!Number.isNaN(date.getTime())) return date;
    }
    const compactMatch = value.match(/^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(Z|[+\-]\d{2}:?\d{2})?$/);
    if (compactMatch) {
      const tz = compactMatch[7] ? compactMatch[7].replace(/(\d{2})(\d{2})$/, '$1:$2') : 'Z';
      const date = new Date(
        `${compactMatch[1]}-${compactMatch[2]}-${compactMatch[3]}T${compactMatch[4]}:${compactMatch[5]}:${compactMatch[6]}${tz}`
      );
      if (!Number.isNaN(date.getTime())) return date;
    }
    const longMatch = value.match(/^(\d{4}):(\d{2}):(\d{2})\s+(\d{2}):(\d{2})(?::(\d{2}))?$/);
    if (longMatch) {
      const date = new Date(
        `${longMatch[1]}-${longMatch[2]}-${longMatch[3]}T${longMatch[4]}:${longMatch[5]}:${longMatch[6] || '00'}`
      );
      if (!Number.isNaN(date.getTime())) return date;
    }
    const slashDate = parseSlashDate(value);
    if (slashDate) return slashDate;
    const slashDayFirst = parseSlashDate(value, true);
    if (slashDayFirst) return slashDayFirst;
    const fallback = new Date(value);
    if (!Number.isNaN(fallback.getTime())) return fallback;
    return null;
  }

  function extractPdfModifiedDate(buffer) {
    if (!buffer) return null;
    let text = '';
    try {
      text = new TextDecoder('utf-8', { fatal: false }).decode(buffer);
    } catch (err) {
      try {
        text = new TextDecoder('windows-1252', { fatal: false }).decode(buffer);
      } catch (e) {
        return null;
      }
    }

    const scanFieldInText = (sourceText, field) => {
      if (!sourceText) return null;
      const escaped = field.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');

      const literal = new RegExp(`/${escaped}\\s*\\(([^)]+)\\)`, 'gi');
      let match = literal.exec(sourceText);
      while (match) {
        const parsed = parsePdfMetadataDate(match[1]);
        if (parsed) return { date: parsed, field, raw: match[1] };
        match = literal.exec(sourceText);
      }

      const xml = new RegExp(`<${field}[^>]*>([^<]+)</${field}>`, 'gi');
      match = xml.exec(sourceText);
      while (match) {
        const parsed = parsePdfMetadataDate(match[1]);
        if (parsed) return { date: parsed, field, raw: match[1] };
        match = xml.exec(sourceText);
      }

      const attr = new RegExp(`${escaped}\\s*=\\s*"([^"]+)"`, 'gi');
      match = attr.exec(sourceText);
      while (match) {
        const parsed = parsePdfMetadataDate(match[1]);
        if (parsed) return { date: parsed, field, raw: match[1] };
        match = attr.exec(sourceText);
      }

      const simple = new RegExp(`${escaped}:\\s*([^\\s<]+)`, 'gi');
      match = simple.exec(sourceText);
      while (match) {
        const parsed = parsePdfMetadataDate(match[1]);
        if (parsed) return { date: parsed, field, raw: match[1] };
        match = simple.exec(sourceText);
      }
      return null;
    };

    for (const field of pdfModifiedDateFields) {
      const direct = scanFieldInText(text, field);
      if (direct) return direct;
    }

    for (const field of pdfModifiedDateFields) {
      const refRegex = new RegExp(`/${field.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s+(\\d+)\\s+0\\s+R`, 'g');
      let refMatch = refRegex.exec(text);
      while (refMatch) {
        const objNumber = refMatch[1];
        const objRegex = new RegExp(`\\b${objNumber}\\s+0\\s+obj([\\s\\S]*?)endobj`, 'g');
        let objMatch = objRegex.exec(text);
        while (objMatch) {
          const block = objMatch[1];
          const indirect = scanFieldInText(block, field);
          if (indirect) return indirect;
          objMatch = objRegex.exec(text);
        }
        refMatch = refRegex.exec(text);
      }
    }

    return null;
  }

  function getPdfFilenameFromUrl(url, index) {
    try {
      const parsed = new URL(url);
      const segments = parsed.pathname.split('/').filter(Boolean);
      const last = segments.pop() || `pdf-${index + 1}.pdf`;
      const base = last.split('?')[0] || last;
      return base.toLowerCase().endsWith('.pdf') ? base : `${base}.pdf`;
    } catch (err) {
      return `pdf-${index + 1}.pdf`;
    }
  }

  let pdfDownloadFrame = null;

  function ensurePdfDownloadFrame() {
    if (pdfDownloadFrame && document.body.contains(pdfDownloadFrame)) {
      return pdfDownloadFrame;
    }
    const frame = document.createElement('iframe');
    frame.id = 'a11y-pdf-download-frame';
    frame.name = 'a11y-pdf-download-frame';
    frame.style.display = 'none';
    frame.setAttribute('sandbox','allow-scripts allow-popups allow-downloads');
    document.body.appendChild(frame);
    pdfDownloadFrame = frame;
    return frame;
  }

  function triggerPdfDownload(url, filename) {
    if (!url) return;
    ensurePdfDownloadFrame();
    const link = document.createElement('a');
    link.href = url;
    if (filename) link.download = filename;
    link.target = 'a11y-pdf-download-frame';
    link.style.display = 'none';
    document.body.appendChild(link);
    triggerClick(link);
    document.body.removeChild(link);
  }

  async function startPdfDownloadSequence() {
    if (pdfInspectorState.downloadPhase === 'downloading') {
      alert('Downloads are already being triggered.');
      return;
    }
    pdfInspectorState.downloadPhase = 'collecting';
    pdfInspectorState.status = 'collecting';
    pdfInspectorState.downloadErrorMessage = '';
    pdfInspectorState.matches = [];
    pdfInspectorState.failures = [];
    pdfInspectorState.lastError = null;
    pdfInspectorState.log = [];
    pdfInspectorState.progress = { total: 0, completed: 0 };
    pdfInspectorState.render?.();
    try {
      pushPdfLog('Collecting PDF URLs…');
      const urls = await collectAllPageUrls();
      const pdfUrls = filterPdfUrls(urls);
      if (!pdfUrls.length) {
        throw new Error('No PDF URLs found in the current table.');
      }
      pdfInspectorState.urls = pdfUrls;
      pdfInspectorState.downloadPhase = 'downloading';
      pdfInspectorState.status = 'downloading';
      pdfInspectorState.progress = { total: pdfUrls.length, completed: 0 };
      pdfInspectorState.render?.();
      for (let i = 0; i < pdfUrls.length; i += 1) {
        const url = pdfUrls[i];
        const filename = getPdfFilenameFromUrl(url, i);
        pushPdfLog(`Triggered download ${i + 1}/${pdfUrls.length}: ${url}`, 'info');
        triggerPdfDownload(url, filename);
        pdfInspectorState.progress.completed = i + 1;
        pdfInspectorState.render?.();
        await wait(250);
      }
      pdfInspectorState.downloadPhase = 'ready';
      pdfInspectorState.status = 'ready';
      pushPdfLog('Downloads triggered. Check your browser downloads list before analyzing.', 'success');
    } catch (err) {
      pdfInspectorState.downloadPhase = 'error';
      pdfInspectorState.downloadErrorMessage = err?.message || 'Unable to trigger downloads.';
      pdfInspectorState.status = 'error';
      pdfInspectorState.lastError = pdfInspectorState.downloadErrorMessage;
      pushPdfLog(pdfInspectorState.downloadErrorMessage, 'error');
    } finally {
      pdfInspectorState.render?.();
    }
  }

  async function ensureAnalysisFolderAccess(handle) {
    if (!handle) throw new Error('No folder selected.');
    if (typeof handle.queryPermission === 'function' && typeof handle.requestPermission === 'function') {
      const current = await handle.queryPermission({ mode: 'read' });
      if (current === 'granted') return handle;
      if (current === 'denied') throw new Error('Permission denied for the selected folder.');
      const requested = await handle.requestPermission({ mode: 'read' });
      if (requested !== 'granted') {
        throw new Error('Permission denied for the selected folder.');
      }
    }
    return handle;
  }

  async function choosePdfAnalysisFolder() {
    if (typeof window.showDirectoryPicker !== 'function') {
      alert('Selecting a folder requires a Chromium-based browser such as Chrome or Edge.');
      return;
    }
    try {
      const handle = await window.showDirectoryPicker({
        id: 'pdf-analysis-folder',
        mode: 'read',
        startIn: 'downloads'
      });
      if (!handle) return;
      await ensureAnalysisFolderAccess(handle);
      pdfInspectorState.analysisFolderHandle = handle;
      pdfInspectorState.analysisFolderName = handle.name || 'Selected folder';
      pdfInspectorState.analysisError = '';
      pdfInspectorState.render?.();
      pushPdfLog(`Selected folder for analysis: ${pdfInspectorState.analysisFolderName}`, 'info');
    } catch (err) {
      if (err?.name === 'AbortError') return;
      const lower = (err?.message || '').toLowerCase();
      const isSystemFolderError =
        err?.name === 'SecurityError' || /system files|access is denied|denied/i.test(lower);
      if (isSystemFolderError) {
        pdfInspectorState.analysisError =
          'Could not open this folder. Please choose a normal folder (for example your Downloads folder or a subfolder inside it).';
      } else {
        pdfInspectorState.analysisError = err?.message || 'Could not open this folder.';
      }
      pdfInspectorState.render?.();
      logPdfInspector('Analysis folder selection failed:', err);
    }
  }

  async function choosePdfMatchFolder() {
    if (typeof window.showDirectoryPicker !== 'function') {
      alert('Selecting a folder requires a Chromium-based browser such as Chrome or Edge.');
      return;
    }
    try {
      const handle = await window.showDirectoryPicker({
        id: 'pdf-match-folder',
        mode: 'read',
        startIn: 'downloads'
      });
      if (!handle) return;
      await ensureAnalysisFolderAccess(handle);
      pdfMatchState.folderHandle = handle;
      pdfMatchState.folderName = handle.name || 'Selected folder';
      pdfMatchState.status = 'idle';
      pdfMatchState.lastError = '';
      pdfMatchState.matches = [];
      pdfMatchState.unmatched = [];
      pdfMatchState.urlCount = 0;
      pdfMatchState.render?.();
    } catch (err) {
      if (err?.name === 'AbortError') return;
      pdfMatchState.lastError = err?.message || 'Could not open this folder.';
      pdfMatchState.render?.();
      logPdfInspector('Match folder selection failed:', err);
    }
  }

  function resetPdfMatchResults() {
    pdfMatchState.matches = [];
    pdfMatchState.unmatched = [];
    pdfMatchState.urlCount = 0;
    pdfMatchState.lastError = '';
  }

  async function collectPdfFiles(directoryHandle, { signal } = {}) {
    const files = [];
    if (!directoryHandle?.values) return files;
    for await (const entry of directoryHandle.values()) {
      throwIfAborted(signal);
      if (!entry || entry.kind !== 'file') continue;
      if (!/\.pdf$/i.test(entry.name)) continue;
      files.push({
        handle: entry,
        name: entry.name,
        key: entry.name.toLowerCase()
      });
    }
    return files;
  }

  async function analyzeLocalPdfs(folderHandle, urls, filter, { signal } = {}) {
    throwIfAborted(signal);
    const files = await collectPdfFiles(folderHandle, { signal });
    const fileMap = new Map();
    files.forEach(file => {
      let bucket = fileMap.get(file.key);
      if (!bucket) {
        bucket = [];
        fileMap.set(file.key, bucket);
      }
      bucket.push(file.handle);
    });
    const matches = [];
    const failures = [];
    const targets = (urls && urls.length
      ? urls.map((url, index) => {
          const filename = getPdfFilenameFromUrl(url, index);
          return {
            id: url,
            filename,
            key: filename.toLowerCase(),
            type: 'url'
          };
        })
      : files.map(file => ({
          id: file.name,
          filename: file.name,
          key: file.key,
          type: 'file',
          handle: file.handle
        }))) || [];
    if (!targets.length) {
      throw new Error('No PDFs found in the selected folder.');
    }
    throwIfAborted(signal);
    pdfInspectorState.progress = { total: targets.length, completed: 0 };
    pdfInspectorState.render?.();
    const concurrency = Math.min(5, Math.max(1, targets.length));
    let index = 0;
    const workers = Array.from({ length: concurrency }, () => (async () => {
      while (true) {
        throwIfAborted(signal);
        const currentIndex = index;
        index += 1;
        if (currentIndex >= targets.length) break;
        const target = targets[currentIndex];
        const label = target.id;
        const filename = target.filename;
        let handle = null;
        if (target.type === 'file') {
          handle = target.handle;
        } else {
          const candidates = fileMap.get(target.key) || [];
          handle = candidates.shift() || null;
        }
        if (!handle) {
          const reason = target.type === 'url'
            ? 'Downloaded file not found in selected folder.'
            : 'File not found in selected folder.';
          failures.push({ url: label, reason });
          pushPdfLog(`[FAIL] ${label}: ${reason}`, 'error');
          pdfInspectorState.progress.completed += 1;
          pdfInspectorState.render?.();
          continue;
        }
        try {
          throwIfAborted(signal);
          const file = await handle.getFile();
          const buffer = await file.arrayBuffer();
          throwIfAborted(signal);
          const meta = extractPdfModifiedDate(buffer);
          if (!meta || !meta.date) {
            const reason = 'Could not identify a valid modified date.';
            failures.push({ url: label, reason });
            pushPdfLog(`[FAIL] ${label} -> ${handle.name}: ${reason}`, 'error');
          } else if (evaluatePdfFilter(meta.date, filter)) {
            matches.push({
              url: label,
              date: meta.date,
              source: meta.field,
              filename: handle.name
            });
            pushPdfLog(
              `[OK] ${label} -> ${handle.name}, Modified date: ${formatPdfDateDisplay(meta.date)}`,
              'success'
            );
          } else {
            pushPdfLog(
              `[SKIP] ${label} -> ${handle.name}, Modified date ${formatPdfDateDisplay(meta.date)} outside filter.`,
              'info'
            );
          }
        } catch (err) {
          if (err?.name === 'AbortError') throw err;
          const reason = err?.message || 'Unable to read file.';
          failures.push({ url: label, reason });
          pushPdfLog(`[FAIL] ${label} -> ${filename}: ${reason}`, 'error');
        } finally {
          pdfInspectorState.progress.completed += 1;
          pdfInspectorState.render?.();
        }
      }
    })());
    await Promise.all(workers);
    matches.sort((a, b) => a.date.getTime() - b.date.getTime());
    return { matches, failures };
  }

  async function startPdfAnalysis(filter) {
    if (!pdfInspectorState.analysisFolderHandle) {
      pdfInspectorState.analysisError = 'Please choose the folder with your downloaded PDFs first.';
      pdfInspectorState.render?.();
      alert('Please choose the folder with your downloaded PDFs first.');
      return;
    }
    if (pdfInspectorState.status === 'analyzing') {
      alert('PDF analysis is already running.');
      return;
    }
    if (pdfInspectorState.analysisAbortController) {
      pdfInspectorState.analysisAbortController.abort();
    }
    const controller = new AbortController();
    pdfInspectorState.analysisAbortController = controller;
    pdfInspectorState.status = 'analyzing';
    pdfInspectorState.filter = filter;
    pdfInspectorState.matches = [];
    pdfInspectorState.failures = [];
    pdfInspectorState.log = [];
    pdfInspectorState.lastError = null;
    pdfInspectorState.progress = { total: 0, completed: 0 };
    pdfInspectorState.render?.();
    try {
      await ensureAnalysisFolderAccess(pdfInspectorState.analysisFolderHandle);
      pushPdfLog('Analyzing PDFs in the selected folder…');
      const results = await analyzeLocalPdfs(
        pdfInspectorState.analysisFolderHandle,
        pdfInspectorState.urls || [],
        filter,
        { signal: controller.signal }
      );
      pdfInspectorState.matches = results.matches;
      pdfInspectorState.failures = results.failures;
      pdfInspectorState.status = 'completed';
      pushPdfLog('PDF analysis complete.', 'success');
    } catch (err) {
      if (err?.name === 'AbortError') {
        pdfInspectorState.status = 'cancelled';
        pdfInspectorState.lastError = '';
        pushPdfLog('PDF analysis cancelled.', 'error');
      } else {
        pdfInspectorState.status = 'error';
        pdfInspectorState.lastError = err?.message || 'Unable to analyze PDFs.';
        pushPdfLog(pdfInspectorState.lastError, 'error');
      }
    } finally {
      if (pdfInspectorState.analysisAbortController === controller) {
        pdfInspectorState.analysisAbortController = null;
      }
      pdfInspectorState.render?.();
    }
  }

  function cancelPdfAnalysis() {
    const controller = pdfInspectorState.analysisAbortController;
    if (!controller || controller.signal.aborted) {
      return;
    }
    pdfInspectorState.status = 'cancelling';
    pdfInspectorState.lastError = '';
    pdfInspectorState.render?.();
    controller.abort();
    pushPdfLog('Cancelling PDF analysis…', 'info');
  }

  async function matchPdfFilesWithUrls() {
    if (!pdfMatchState.folderHandle) {
      alert('Choose the folder with your downloaded PDFs first.');
      return;
    }
    try {
      await ensureAnalysisFolderAccess(pdfMatchState.folderHandle);
    } catch (err) {
      pdfMatchState.lastError = err?.message || 'Permission required for the selected folder.';
      pdfMatchState.render?.();
      return;
    }
    pdfMatchState.status = 'matching';
    resetPdfMatchResults();
    pdfMatchState.render?.();
    try {
      const urls = await collectAllPageUrls();
      const pdfUrls = filterPdfUrls(urls);
      if (!pdfUrls.length) {
        throw new Error('No PDF URLs found for the current table.');
      }
      const urlMap = new Map();
      pdfUrls.forEach(url => {
        const key = getUrlMatchKey(url);
        if (!key) return;
        if (!urlMap.has(key)) urlMap.set(key, []);
        urlMap.get(key).push(url);
      });
      const files = await collectPdfFiles(pdfMatchState.folderHandle);
      if (!files.length) {
        throw new Error('No PDF files found in the selected folder.');
      }
      const matches = [];
      const unmatched = [];
      files.forEach(file => {
        const key = getFileMatchKey(file.name);
        if (key && urlMap.has(key) && urlMap.get(key).length) {
          const matchedUrl = urlMap.get(key).shift();
          matches.push({ filename: file.name, url: matchedUrl });
        } else {
          unmatched.push(file.name);
        }
      });
      pdfMatchState.matches = matches;
      pdfMatchState.unmatched = unmatched;
      pdfMatchState.urlCount = pdfUrls.length;
      pdfMatchState.status = 'completed';
    } catch (err) {
      pdfMatchState.status = 'error';
      pdfMatchState.lastError = err?.message || 'Unable to match PDFs.';
    } finally {
      pdfMatchState.render?.();
    }
  }

  function readMatchingIssuesCount() {
    const tags = Array.from(document.querySelectorAll('.Panel__Header .Tag, .Panel__Header .TagButton'));
    for (const tag of tags) {
      const label = (tag.querySelector('.Tag__label')?.textContent || tag.getAttribute('aria-label') || '').toLowerCase();
      const text = tag.textContent || '';
      if (label.includes('matching issues') || /matching\s+issues/i.test(text)) {
        const match = text.replace(/,/g,'').match(/matching\s+issues[:\s]*(-?\d+)/i);
        if (match) return parseInt(match[1], 10);
        const numberMatch = text.replace(/,/g,'').match(/(-?\d+)\s*$/);
        if (numberMatch) return parseInt(numberMatch[1], 10);
      }
    }
    return null;
  }

  async function getMatchingIssuesCount({ timeout = 6000 } = {}) {
    return waitForCondition(() => {
      const value = readMatchingIssuesCount();
      return typeof value === 'number' ? value : null;
    }, { timeout }).catch(() => readMatchingIssuesCount());
  }

  async function waitForIssuesTableChange(prevSignature, timeout = 8000) {
    const start = Date.now();
    return new Promise(resolve => {
      (function check() {
        const current = getIssuesTableSignature();
        if (!prevSignature || current !== prevSignature) {
          resolve(true);
          return;
        }
        if (Date.now() - start > timeout) {
          resolve(false);
          return;
        }
        requestAnimationFrame(check);
      })();
    });
  }

  function getQuickActionStorageKey(prefix) {
    const runId = scanRunParam ? String(scanRunParam) : 'global';
    return `${prefix}::${runId}`;
  }

  function normalizeQuickActionEntry(value) {
    return value.trim().replace(/^(https?:\/\/)/i, '');
  }

  function normalizeFilterValue(value) {
    if (value == null) return null;
    const normalized = normalizeQuickActionEntry(String(value));
    return normalized || null;
  }

  function validateQuickActionEntries(inputText) {
    const normalizedText = String(inputText || '').replace(/\r\n/g, '\n');
    const lines = normalizedText.split('\n');
    const entries = [];
    const errors = [];
    lines.forEach((line, idx) => {
      const trimmed = line.trim();
      if (!trimmed) return;
      const encoded = trimmed.replace(/\s/g, ch => encodeURIComponent(ch));
      entries.push(normalizeQuickActionEntry(encoded));
    });
    if (!entries.length) {
      errors.push({ line: null, message: 'Enter at least one URL or path.' });
    }
    return { entries, errors };
  }

  function setInputValue(input, nextValue) {
    if (!input) return;
    const value = nextValue == null ? '' : String(nextValue);
    const proto = Object.getPrototypeOf(input);
    const descriptor = proto && Object.getOwnPropertyDescriptor(proto, 'value');
    const setter = descriptor?.set;
    if (setter) {
      setter.call(input, value);
    } else {
      input.value = value;
    }
    input.dispatchEvent(new Event('input', { bubbles: true }));
  }

  function dispatchNativeClick(element) {
    if (!element) return false;
    const eventTypes = ['pointerdown','mousedown','mouseup','click'];
    eventTypes.forEach(type => {
      const event = new MouseEvent(type, {
        bubbles: true,
        cancelable: true,
        view: window,
        buttons: 1
      });
      element.dispatchEvent(event);
    });
    return true;
  }

  function triggerClick(element) {
    if (!element) return false;
    if (dispatchNativeClick(element)) return true;
    if (typeof element.click === 'function') {
      element.click();
      return true;
    }
    return false;
  }

  function simulateKeyboardActivation(element, key = 'Enter') {
    if (!element) return false;
    const init = {
      key,
      code: key === ' ' ? 'Space' : key,
      bubbles: true,
      cancelable: true
    };
    const down = new KeyboardEvent('keydown', init);
    const up = new KeyboardEvent('keyup', init);
    const downResult = element.dispatchEvent(down);
    element.dispatchEvent(up);
    return downResult;
  }

  function getAssociatedLabel(element) {
    if (!element) return null;
    if (element.id) {
      const label = document.querySelector(`label[for="${element.id}"]`);
      if (label) return label;
    }
    return element.closest?.('label') || null;
  }

  function getCheckboxInput(element) {
    if (!element) return null;
    if (element.matches?.('input[type="checkbox"]')) return element;
    return element.querySelector?.('input[type="checkbox"]') || null;
  }

  function getCheckboxStateInfo(element) {
    if (!element) {
      return { checked: false, aria: null, source: 'none', input: null };
    }
    const input = getCheckboxInput(element);
    if (input) {
      return {
        checked: !!input.checked,
        aria: input.getAttribute('aria-checked'),
        source: 'input',
        input
      };
    }
    const aria = element.getAttribute?.('aria-checked');
    if (aria != null) {
      return {
        checked: aria === 'true',
        aria,
        source: 'aria',
        input: null
      };
    }
    const classes = element.classList || { contains: () => false };
    const heuristics = ['is-checked','Checkbox--isChecked','Checkbox--checked','Checkbox__input--checked'];
    const heurChecked = heuristics.some(cls => classes.contains?.(cls));
    return {
      checked: heurChecked,
      aria: null,
      source: 'class',
      input: null
    };
  }

  function isCheckboxChecked(element) {
    return getCheckboxStateInfo(element).checked;
  }

  function describeCheckboxState(element) {
    const base = describeDomElement(element) || {};
    const info = getCheckboxStateInfo(element);
    base.checkbox = {
      checked: info.checked,
      aria: info.aria,
      source: info.source,
      inputId: info.input?.id || null,
      inputClasses: info.input?.className || null
    };
    if (info.input) {
      base.checkbox.inputTag = info.input.tagName;
    }
    return base;
  }

  async function ensureCheckboxState(element, desiredChecked, { context = 'checkbox' } = {}) {
    if (!element) return false;
    const desired = !!desiredChecked;
    if (isCheckboxChecked(element) === desired) return true;
    const info = getCheckboxStateInfo(element);
    const input = info.input;
    const label = getAssociatedLabel(input || element);
    const clickTargets = [];
    if (input) clickTargets.push(input);
    clickTargets.push(element);
    if (label) clickTargets.push(label);
    const uniqueTargets = Array.from(new Set(clickTargets.filter(Boolean)));
    for (const target of uniqueTargets) {
      triggerClick(target);
      if (input && target !== input) {
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
      } else if (target === input) {
        input.dispatchEvent(new Event('input', { bubbles: true }));
        input.dispatchEvent(new Event('change', { bubbles: true }));
      } else {
        element.dispatchEvent?.(new Event('change', { bubbles: true }));
      }
      await wait(150);
      if (isCheckboxChecked(element) === desired) return true;
    }
    if (input && !!input.checked !== desired) {
      input.checked = desired;
      input.dispatchEvent(new Event('input', { bubbles: true }));
      input.dispatchEvent(new Event('change', { bubbles: true }));
      await wait(100);
      if (isCheckboxChecked(element) === desired) return true;
    }
    logQuickActions('ensureCheckboxState: failed to toggle checkbox', {
      context,
      desired,
      state: describeCheckboxState(element)
    });
    return isCheckboxChecked(element) === desired;
  }

  function getBulkActionsSelect() {
    const host = document.querySelector(issuesBulkActionsSelector);
    if (!host) return null;
    if (host.tagName === 'SELECT') return host;
    const nestedSelect = host.querySelector?.('select');
    if (nestedSelect) return nestedSelect;
    return host;
  }

  function describeDomElement(node) {
    if (!node) return null;
    const info = {
      tag: node.tagName || node.nodeName || null,
      id: node.id || null,
      classes: node.className || null,
      role: typeof node.getAttribute === 'function' ? (node.getAttribute('role') || null) : null,
      type: typeof node.getAttribute === 'function' ? (node.getAttribute('type') || null) : null,
      ariaDisabled: typeof node.getAttribute === 'function' ? (node.getAttribute('aria-disabled') || null) : null,
      ariaHaspopup: typeof node.getAttribute === 'function' ? (node.getAttribute('aria-haspopup') || null) : null,
      disabled: typeof node.disabled === 'boolean' ? node.disabled : null,
      childTags: Array.from(node.children || []).slice(0, 5).map(child => child.tagName),
      textSample: (node.textContent || '').trim().slice(0, 120) || null,
      hasShadowRoot: !!node.shadowRoot
    };
    if (node.shadowRoot) {
      info.shadowChildTags = Array.from(node.shadowRoot.children || []).slice(0, 5).map(child => child.tagName);
    }
    return info;
  }

  function findAssignOption(bulkSelect) {
    if (!bulkSelect) return null;
    const lower = value => (value || '').toLowerCase();
    const option = Array.from(bulkSelect.options || []).find(opt => {
      const text = lower(opt.textContent);
      const value = lower(opt.value);
      if (!text && !value) return false;
      return text.includes('assign to') || text.includes('assign') || value.includes('assign');
    });
    return option || null;
  }

  function findBulkActionOptionByText(bulkSelect, regex) {
    if (!bulkSelect || !regex) return null;
    const matcher = regex instanceof RegExp ? regex : new RegExp(String(regex), 'i');
    const options = bulkSelect.options && bulkSelect.options.length
      ? Array.from(bulkSelect.options)
      : Array.from(bulkSelect.querySelectorAll('option'));
    return options.find(opt => matcher.test((opt.textContent || opt.value || '').trim())) || null;
  }

  function describeBulkOptions(bulkSelect) {
    if (!bulkSelect) return [];
    return Array.from(bulkSelect.options || []).map(opt => ({
      text: (opt.textContent || '').trim(),
      value: opt.value,
      disabled: !!opt.disabled
    }));
  }

  function getOptionValue(node) {
    if (!node) return '';
    if (typeof node.value === 'string' && node.value) return node.value;
    const attr = typeof node.getAttribute === 'function' ? (node.getAttribute('value') || '') : '';
    if (attr) return attr;
    if (node.dataset) {
      const datasetValue = node.dataset.value || node.dataset.id || node.dataset.optionValue;
      if (datasetValue) return datasetValue;
    }
    const text = (node.textContent || '').trim();
    return text;
  }

  function isOptionNodeDisabled(node) {
    if (!node) return true;
    if (typeof node.disabled === 'boolean') return node.disabled;
    const ariaDisabled = typeof node.getAttribute === 'function' ? node.getAttribute('aria-disabled') : null;
    if (ariaDisabled != null) return ariaDisabled === 'true';
    const classes = node.classList || { contains: () => false };
    return classes.contains?.('is-disabled') || classes.contains?.('Option--isDisabled') || classes.contains?.('Select-option--disabled');
  }

  function mapOptionNode(node) {
    if (!node) return null;
    const label = (node.textContent || '').trim();
    const value = getOptionValue(node);
    const disabled = isOptionNodeDisabled(node);
    return { label, value, disabled };
  }

  function findBulkApplyButton(keyword) {
    const normalized = (keyword || '').toLowerCase();
    const explicit = issuesBulkApplyButtonSelector ? document.querySelector(issuesBulkApplyButtonSelector) : null;
    if (explicit) return explicit;
    const buttons = new Set([
      ...document.querySelectorAll('#main-content button'),
      ...document.querySelectorAll('body button')
    ]);
    for (const btn of buttons) {
      const text = (btn.getAttribute('aria-label') || btn.textContent || '').toLowerCase();
      if (!text) continue;
      if (!text.includes('apply')) continue;
      if (!text.includes('bulk')) continue;
      if (normalized && !text.includes(normalized)) continue;
      return btn;
    }
    return null;
  }

  function getAssignDropdownToggle(host) {
    if (!host) return null;
    if (host.tagName === 'SELECT') return null;
    const combobox = host.querySelector?.('[role="combobox"]');
    if (combobox) return combobox;
    const button = host.querySelector?.('button');
    if (button) return button;
    return host;
  }

  function pokeAssignDropdown(host) {
    if (!host) return;
    const toggle = getAssignDropdownToggle(host);
    if (!toggle) return;
    triggerClick(toggle);
    if (typeof toggle.focus === 'function') {
      toggle.focus();
    }
  }

  async function waitForAssignSelectOptions({ timeout = 20000, minOptions = 1 } = {}) {
    let lastPoke = 0;
    return waitForCondition(() => {
      const host = document.querySelector(issuesBulkAssignSelectSelector);
      if (!host) return null;
      const now = Date.now();
      if (host.tagName !== 'SELECT' && now - lastPoke > 500) {
        pokeAssignDropdown(host);
        lastPoke = now;
      }
      const select = host.tagName === 'SELECT' ? host : host.querySelector?.('select');
      let rawNodes = [];
      if (select?.options?.length) {
        rawNodes = Array.from(select.options);
      }
      if (!rawNodes.length) {
        rawNodes = Array.from(host.querySelectorAll('option'));
      }
      if (!rawNodes.length) {
        rawNodes = Array.from(host.querySelectorAll('[role="option"]'));
      }
      const mapped = rawNodes.map(mapOptionNode).filter(Boolean);
      const usable = mapped.filter(opt => opt.value && opt.label && !opt.disabled);
      if (usable.length >= minOptions) {
        return { select: select || host, optionNodes: rawNodes, options: usable };
      }
      return null;
    }, { timeout }).catch(() => null);
  }

  async function waitForBulkActionsEnabled({ timeout = 6000 } = {}) {
    let bulkSelect = getBulkActionsSelect();
    if (!bulkSelect) {
      if (pageContext === 'issues') logQuickActions('waitForBulkActionsEnabled: bulk select not found, retrying');
      await wait(50);
      bulkSelect = getBulkActionsSelect();
      if (!bulkSelect) return null;
    }
    await waitForCondition(() => {
      bulkSelect = getBulkActionsSelect();
      return bulkSelect && !bulkSelect.disabled;
    }, { timeout }).catch(() => null);
    if (!bulkSelect || bulkSelect.disabled) {
      if (pageContext === 'issues') {
        logQuickActions('waitForBulkActionsEnabled: bulk select still disabled or missing after wait', describeDomElement(bulkSelect));
      }
      return null;
    }
    return bulkSelect;
  }

  async function waitForBulkOptions({ timeout = 4000 } = {}) {
    let attempt = 0;
    const select = await waitForCondition(() => {
      const current = getBulkActionsSelect();
      attempt++;
      if (current && current.options && current.options.length > 0) {
        return current;
      }
      return null;
    }, { timeout }).catch(() => null);
    if (!select || !select.options || !select.options.length) {
      if (pageContext === 'issues') {
        const host = document.querySelector(issuesBulkActionsSelector);
        logQuickActions('waitForBulkOptions: options still empty after wait', {
          selectDetails: describeDomElement(select),
          hostDetails: host && host !== select ? describeDomElement(host) : null,
          attempts: attempt
        });
      }
      return null;
    }
    return select;
  }

  function getInputLabelText(input) {
    if (!input) return '';
    if (input.id) {
      const forLabel = document.querySelector(`label[for="${input.id}"]`);
      if (forLabel) return (forLabel.textContent || '').trim();
    }
    const ancestorLabel = input.closest('label');
    if (ancestorLabel) return (ancestorLabel.textContent || '').trim();
    return (input.getAttribute('aria-label') || '').trim();
  }

  function getIssuesViewByRadios() {
    const radios = Array.from(document.querySelectorAll('input[type="radio"]'));
    return radios
      .map(input => {
        const label = getInputLabelText(input);
        const legend = input.closest('fieldset')?.querySelector('legend');
        const groupLabel = legend ? legend.textContent || '' : '';
        return {
          input,
          label,
          groupLabel,
          name: input.name || ''
        };
      })
      .filter(info => {
        const name = info.name.toLowerCase();
        if (name.includes('view')) return true;
        const label = (info.label || '').toLowerCase();
        if (label.includes('view')) return true;
        const group = (info.groupLabel || '').toLowerCase();
        return group.includes('view');
      });
  }

  function isPageUrlLabel(labelText) {
    const text = (labelText || '').toLowerCase();
    if (!text) return false;
    if (text.includes('page url')) return true;
    return text.includes('page') && text.includes('url');
  }

  async function ensureIssuesViewByPage() {
    if (pageContext !== 'issues') return;
    logQuickActions('ensureIssuesViewByPage: verifying active view radio');
    const radios = getIssuesViewByRadios();
    if (!radios.length) return;
    const pageRadio = radios.find(info => isPageUrlLabel(info.label) || isPageUrlLabel(info.input.value));
    if (!pageRadio) return;
    if (pageRadio.input.checked) return;
    logQuickActions('ensureIssuesViewByPage: switching view to Page URL');
    triggerClick(pageRadio.input);
    pageRadio.input.dispatchEvent(new Event('change', { bubbles: true }));
    await waitForIssuesResultsIdle();
  }

  function getPagesViewByRadios() {
    const buckets = new Set();
    const label = document.querySelector('#pages-view-by');
    if (label && label.parentElement) {
      label.parentElement.querySelectorAll?.('input[type="radio"]').forEach(input => buckets.add(input));
    }
    const ariaGroup = document.querySelector('[aria-labelledby="pages-view-by"]');
    if (ariaGroup) {
      ariaGroup.querySelectorAll?.('input[type="radio"]').forEach(input => buckets.add(input));
    }
    if (!buckets.size) {
      document.querySelectorAll('input[type="radio"]').forEach(input => {
        const id = (input.id || '').toLowerCase();
        const name = (input.name || '').toLowerCase();
        if (id.includes('pages-view-by') || name.includes('view')) buckets.add(input);
      });
    }
    return Array.from(buckets).map(input => ({
      input,
      value: (input.value || '').toLowerCase(),
      label: (getInputLabelText(input) || '').toLowerCase()
    }));
  }

  async function ensurePagesViewByUrl() {
    if (pageContext !== 'pages') return;
    const radios = getPagesViewByRadios();
    if (!radios.length) return;
    const target = radios.find(info => {
      if (!info) return false;
      if (info.value === 'url') return true;
      if ((info.input.id || '').toLowerCase().includes('pages-view-by-url')) return true;
      return info.label.includes('page url');
    });
    if (!target || target.input.checked) return;
    logCopyPageUrls('Switching view to Page URL');
    const signature = getPagesTableSignature();
    triggerClick(target.input);
    target.input.dispatchEvent(new Event('change', { bubbles: true }));
    await waitForPagesTableChange(signature);
  }

  async function ensureSelectAllUnchecked() {
    if (pageContext !== 'issues') return;
    const selectAll = document.querySelector(issuesSelectAllSelector);
    if (!selectAll) return;
    if (!isCheckboxChecked(selectAll)) return;
    logQuickActions('ensureSelectAllUnchecked: clearing Select All checkbox');
    const success = await ensureCheckboxState(selectAll, false, { context: 'ensureSelectAllUnchecked' });
    if (!success) {
      logQuickActions('ensureSelectAllUnchecked: failed to clear Select All', describeCheckboxState(selectAll));
    }
    await wait(50);
  }

  function getIssuesFilterButton() {
    return document.querySelector(issuesFilterButtonSelector) ||
      document.querySelector('#main-content button[aria-label="Filters"]') ||
      document.querySelector('#main-content button[data-test="filters-button"]');
  }

  async function waitForIssuesFilterButton({ timeout = 8000, requireEnabled = false } = {}) {
    return waitForCondition(() => {
      const button = getIssuesFilterButton();
      if (!button) return null;
      if (requireEnabled && button.disabled) return null;
      return button;
    }, { timeout }).catch(() => null);
  }

  async function openIssuesFilterModal({ ensureButtonEnabled = true } = {}) {
    const existing = document.querySelector(issuesFilterModalSelector);
    if (existing) return existing;
    const button = await waitForIssuesFilterButton({
      timeout: 8000,
      requireEnabled: ensureButtonEnabled
    }).catch(() => null);
    if (!button) throw new Error('Filters button not available on the Issues page.');
    if (button.disabled && ensureButtonEnabled) {
      await waitForCondition(() => !button.disabled, { timeout: 4000 }).catch(() => {});
    }
    triggerClick(button);
    const modal = await waitForElement(issuesFilterModalSelector, { timeout: 8000 }).catch(() => null);
    if (!modal) throw new Error('Filters dialog did not open.');
    return modal;
  }

  async function applyIssuesPageUrlFilter(rawValue, { matchType = 'contains' } = {}) {
    const targetValue = rawValue == null ? '' : String(rawValue);
    const modal = await openIssuesFilterModal({ ensureButtonEnabled: true });
    if (!modal) throw new Error('Filters dialog not available.');
    const urlField = modal.querySelector(issuesUrlFieldSelector);
    if (!urlField) throw new Error('Page URL filter field not found in the Filters dialog.');
    setInputValue(urlField, targetValue);

    const desiredRadio =
      matchType === 'equals'
        ? modal.querySelector(issuesUrlEqualsRadioSelector)
        : modal.querySelector(issuesUrlContainsRadioSelector);
    if (desiredRadio && !desiredRadio.checked) {
      triggerClick(desiredRadio);
    }

    const applyBtn = modal.querySelector(issuesFilterApplySelector);
    if (!applyBtn) throw new Error('Filters Apply button not found.');
    if (applyBtn.disabled) {
      await waitForCondition(() => !applyBtn.disabled, { timeout: 4000 }).catch(() => {});
    }

    const prevSignature = getIssuesTableSignature();
    triggerClick(applyBtn);
    await waitForCondition(
      () => !document.querySelector(issuesFilterModalSelector),
      { timeout: 8000 }
    ).catch(() => {});
    await waitForIssuesResultsIdle();
    await waitForIssuesTableChange(prevSignature, 8000);
    return targetValue;
  }

  async function clearIssuesPageUrlFilter() {
    try {
      await applyIssuesPageUrlFilter('', { matchType: 'contains' });
    } catch (err) {
      logQuickActions('clearIssuesPageUrlFilter: unable to clear Page URL filter', err);
      throw err;
    }
  }

  function findClearFiltersButton(modal) {
    if (!modal) return null;
    const selectors = [
      'button[data-test="clear-filters"]',
      'button[data-test="filters__clear"]',
      'button[data-testid="clear-filters"]',
      'button[aria-label*="clear" i]'
    ];
    for (const selector of selectors) {
      const candidate = modal.querySelector(selector);
      if (candidate) return candidate;
    }
    const buttons = Array.from(modal.querySelectorAll('button'));
    const patterns = [/clear all filters/i, /clear filters/i, /reset filters/i];
    return buttons.find(btn => {
      const text = (btn.textContent || btn.getAttribute('aria-label') || '').trim();
      return patterns.some(rx => rx.test(text));
    }) || null;
  }

  async function clearAllIssuesFilters() {
    if (pageContext !== 'issues') return;
    try {
      const modal = await openIssuesFilterModal({ ensureButtonEnabled: false }).catch(() => null);
      if (!modal) throw new Error('Filters dialog not available.');
      const clearBtn = findClearFiltersButton(modal);
      if (!clearBtn) {
        triggerClick(modal.querySelector(issuesFilterCancelSelector) || modal.querySelector('.Dialog__close'));
        throw new Error('Clear filters button not found.');
      }
      const prevSignature = getIssuesTableSignature();
      triggerClick(clearBtn);
      const applyBtn = modal.querySelector(issuesFilterApplySelector);
      if (applyBtn) {
        if (applyBtn.disabled) {
          await waitForCondition(() => !applyBtn.disabled, { timeout: 4000 }).catch(() => {});
        }
        triggerClick(applyBtn);
        await waitForCondition(() => !document.querySelector(issuesFilterModalSelector), { timeout: 8000 }).catch(() => {});
        await waitForIssuesResultsIdle();
        await waitForIssuesTableChange(prevSignature, 8000);
      } else {
        const cancelBtn = modal.querySelector(issuesFilterCancelSelector);
        if (cancelBtn) triggerClick(cancelBtn);
        await waitForCondition(() => !document.querySelector(issuesFilterModalSelector), { timeout: 4000 }).catch(() => {});
      }
    } catch (err) {
      logQuickActions('clearAllIssuesFilters: unable to clear filters', err);
      throw err;
    }
  }

  async function collectQuickAssignOptions() {
    if (pageContext !== 'issues') return [];
    logQuickActions('collectQuickAssignOptions: start');
    await ensureIssuesViewByPage();
    const selectAll = await waitForElement(issuesSelectAllSelector, { timeout: 6000 }).catch(() => null);
    if (!selectAll) throw new Error('Select All checkbox not found on Issues page.');
    if (selectAll.disabled) throw new Error('Select All checkbox is disabled. Unable to read assignee list.');
    let bulkSelect = getBulkActionsSelect();
    if (!bulkSelect) throw new Error('Bulk Actions dropdown not found on Issues page.');
    if (bulkSelect.tagName !== 'SELECT') {
      logQuickActions('collectQuickAssignOptions: bulk select is not a native <select>', describeDomElement(bulkSelect));
    }

    const initialSelectAllState = isCheckboxChecked(selectAll);
    if (!initialSelectAllState) {
      logQuickActions('collectQuickAssignOptions: toggling Select All for bulk options');
      const success = await ensureCheckboxState(selectAll, true, { context: 'collectQuickAssignOptions:enable' });
      logQuickActions('collectQuickAssignOptions: Select All state after toggle', describeCheckboxState(selectAll));
      if (!success) throw new Error('Select All checkbox could not be checked.');
      await wait(150); // let Monitor enable bulk actions for the new selection
    }

    bulkSelect = await waitForBulkActionsEnabled() || bulkSelect;
    logQuickActions('collectQuickAssignOptions: bulk select ready?', { disabled: !!bulkSelect.disabled });
    bulkSelect = await waitForBulkOptions({ timeout: 5000 }) || bulkSelect;
    if (!bulkSelect || !bulkSelect.options || !bulkSelect.options.length) {
      if (!initialSelectAllState) {
        await ensureCheckboxState(selectAll, false, { context: 'collectQuickAssignOptions:restore-on-empty' }).catch(() => {});
      }
      throw new Error('Bulk Actions dropdown has no actions available after selecting issues.');
    }

    let assignOption = findAssignOption(bulkSelect);
    if (!assignOption) {
      logQuickActions('collectQuickAssignOptions: assign option missing, current options:', describeBulkOptions(bulkSelect));
      logQuickActions('collectQuickAssignOptions: waiting for Assign option in bulk select');
      await waitForCondition(() => {
        bulkSelect = getBulkActionsSelect();
        assignOption = findAssignOption(bulkSelect);
        return !!assignOption;
      }, { timeout: 4000 }).catch(() => null);
      if (!assignOption) {
        logQuickActions('collectQuickAssignOptions: Assign option still missing after wait', describeBulkOptions(getBulkActionsSelect()));
      }
    }
    if (!assignOption) {
      if (!initialSelectAllState) {
        await ensureCheckboxState(selectAll, false, { context: 'collectQuickAssignOptions:restore-on-missing-assign' }).catch(() => {});
      }
      throw new Error('"Assign to" option not available in Bulk Actions.');
    }

    const previousBulkValue = bulkSelect.value;

    if (bulkSelect.value !== assignOption.value) {
      logQuickActions('collectQuickAssignOptions: switching bulk action to Assign');
      bulkSelect.value = assignOption.value;
      bulkSelect.dispatchEvent(new Event('change', { bubbles: true }));
    }

    const assignSelect = await waitForElement(issuesBulkAssignSelectSelector, { timeout: 6000 }).catch(() => null);
    if (!assignSelect) {
      logQuickActions('collectQuickAssignOptions: Assign select not found after waiting');
      if (!initialSelectAllState) {
        logQuickActions('collectQuickAssignOptions: Assign select missing, restoring Select All state');
        await ensureCheckboxState(selectAll, false, { context: 'collectQuickAssignOptions:restore-on-error' });
      }
      throw new Error('"Assign to" dropdown did not appear.');
    }

    logQuickActions('collectQuickAssignOptions: waiting for assignee options to populate');
    let assignOptionsResult =
      await waitForAssignSelectOptions({ timeout: 20000, minOptions: 2 });
    if (!assignOptionsResult) {
      logQuickActions('collectQuickAssignOptions: retrying with relaxed requirements');
      assignOptionsResult =
        await waitForAssignSelectOptions({ timeout: 8000, minOptions: 1 });
    }
    if (!assignOptionsResult) {
      logQuickActions('collectQuickAssignOptions: Assign options did not populate in time');
      if (!initialSelectAllState) {
        await ensureCheckboxState(selectAll, false, { context: 'collectQuickAssignOptions:restore-on-timeout' }).catch(() => {});
      }
      throw new Error('Unable to read "Assign to" options. Try again after the list loads.');
    }

    const assignSelectNode = assignOptionsResult.select || assignSelect;
    const optionDedup = [];
    const seenOptions = new Set();
    assignOptionsResult.options.forEach(opt => {
      if (!opt || !opt.value || !opt.label || opt.disabled) return;
      const key = `${opt.value}::${opt.label}`;
      if (seenOptions.has(key)) return;
      seenOptions.add(key);
      optionDedup.push({ value: opt.value, label: opt.label });
    });

    // Reset bulk action to its previous state
    if (previousBulkValue && bulkSelect.value !== previousBulkValue) {
      bulkSelect.value = previousBulkValue;
    } else if (!previousBulkValue && bulkSelect.selectedIndex !== 0) {
      bulkSelect.selectedIndex = 0;
    }
    bulkSelect.dispatchEvent(new Event('change', { bubbles: true }));
    await waitForCondition(() => !document.contains(assignSelectNode), { timeout: 4000 }).catch(() => null);

    if (!initialSelectAllState && isCheckboxChecked(selectAll)) {
      logQuickActions('collectQuickAssignOptions: restoring Select All to unchecked state');
      await ensureCheckboxState(selectAll, false, { context: 'collectQuickAssignOptions:restore' });
    }

    logQuickActions('collectQuickAssignOptions: loaded options', optionDedup.length);
    if (!optionDedup.length) throw new Error('No assignee options available.');
    return optionDedup;
  }

  async function ensureQuickAssignOptions() {
    if (quickAssignOptionsCache && quickAssignOptionsCache.length) {
      return quickAssignOptionsCache.slice();
    }
    if (quickAssignOptionsPromise) {
      return quickAssignOptionsPromise.then(opts => opts.slice());
    }
    quickAssignOptionsPromise = collectQuickAssignOptions()
      .then(options => {
        quickAssignOptionsCache = options.slice();
        return options.slice();
      })
      .finally(() => {
        quickAssignOptionsPromise = null;
      });
    return quickAssignOptionsPromise;
  }

  async function waitForIssuesResultsIdle(timeout = 8000) {
    const container =
      document.querySelector('#main-content section.Panel__Content') ||
      document.querySelector('#main-content section') ||
      document.querySelector('#main-content');
    if (!container) {
      await wait(500);
      return;
    }
    const start = Date.now();
    return new Promise(resolve => {
      (function check() {
        const busyAttr = container.getAttribute('aria-busy');
        const spinner = container.querySelector('.Spinner, .LoadingIndicator, [role="status"]');
        const isBusy = busyAttr === 'true' || !!spinner;
        if (!isBusy) {
          resolve(true);
          return;
        }
        if (Date.now() - start > timeout) {
          resolve(false);
          return;
        }
        requestAnimationFrame(check);
      })();
    });
  }

  function openQuickAssignPagesModal(initialEntries, { onSave } = {}) {
    const startingValue = Array.isArray(initialEntries) ? initialEntries.join('\n') : String(initialEntries || '');
    const overlay = document.createElement('div');
    overlay.className = 'a11y-filter-overlay';
    const dialog = document.createElement('div');
    dialog.className = 'a11y-filter-dialog a11y-assign-pages-dialog';
    dialog.setAttribute('role','dialog');
    dialog.setAttribute('aria-modal','true');
    dialog.setAttribute('aria-labelledby','a11y-assign-pages-title');

    const header = document.createElement('div');
    header.className = 'a11y-filter-header';
    const title = document.createElement('h2');
    title.id = 'a11y-assign-pages-title';
    title.textContent = 'Add pages to assign';
    header.appendChild(title);
    dialog.appendChild(header);

    const content = document.createElement('div');
    content.className = 'a11y-filter-content';
    const help = document.createElement('p');
    help.className = 'a11y-quick-actions-note';
    help.textContent = 'Paste one full or partial URL per line. Spaces are automatically encoded as %20. Entries keep their order.';
    content.appendChild(help);

    const editorWrap = document.createElement('div');
    editorWrap.className = 'a11y-pages-editor';
    const gutter = document.createElement('div');
    gutter.className = 'a11y-pages-editor-gutter';
    editorWrap.appendChild(gutter);
    const textarea = document.createElement('textarea');
    textarea.className = 'a11y-pages-editor-input';
    textarea.value = startingValue;
    textarea.wrap = 'off';
    textarea.spellcheck = false;
    editorWrap.appendChild(textarea);
    content.appendChild(editorWrap);

    const errorBox = document.createElement('div');
    errorBox.className = 'a11y-quick-actions-error';
    errorBox.hidden = true;
    errorBox.setAttribute('role','alert');
    content.appendChild(errorBox);

    dialog.appendChild(content);

    const footer = document.createElement('div');
    footer.className = 'a11y-filter-footer';
    const saveBtn = document.createElement('button');
    saveBtn.type = 'button';
    saveBtn.className = 'a11y-btn-primary';
    saveBtn.textContent = 'Save';
    const cancelBtn = document.createElement('button');
    cancelBtn.type = 'button';
    cancelBtn.className = 'a11y-btn-secondary';
    cancelBtn.textContent = 'Cancel';
    footer.appendChild(saveBtn);
    footer.appendChild(cancelBtn);
    dialog.appendChild(footer);

    overlay.appendChild(dialog);
    appendOverlayAfterFooter(overlay);

    const lastFocused = document.activeElement;

    function updateLineNumbers() {
      const lines = textarea.value.split('\n').length || 1;
      gutter.innerHTML = '';
      for (let i = 1; i <= lines; i++) {
        const line = document.createElement('div');
        line.textContent = i;
        gutter.appendChild(line);
      }
    }

    function showErrors(errors) {
      errorBox.innerHTML = '';
      if (!errors.length) {
        errorBox.hidden = true;
        return;
      }
      const ul = document.createElement('ul');
      errors.forEach(err => {
        const li = document.createElement('li');
        li.textContent = err.line ? `Line ${err.line}: ${err.message}` : err.message;
        ul.appendChild(li);
      });
      errorBox.appendChild(ul);
      errorBox.hidden = false;
    }

    function closeDialog() {
      document.removeEventListener('keydown', onKeydown, true);
      overlay.remove();
      if (lastFocused && lastFocused.focus) lastFocused.focus();
    }

    function onKeydown(e) {
      if (e.key === 'Escape') {
        e.preventDefault();
        closeDialog();
      } else if (e.key === 'Tab') {
        const focusables = getFocusable(dialog);
        if (!focusables.length) return;
        const first = focusables[0];
        const last = focusables[focusables.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault(); last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault(); first.focus();
        }
      }
    }

    saveBtn.addEventListener('click', () => {
      const { entries, errors } = validateQuickActionEntries(textarea.value);
      if (errors.length) {
        showErrors(errors);
        return;
      }
      if (typeof onSave === 'function') onSave(entries);
      closeDialog();
    });
    cancelBtn.addEventListener('click', closeDialog);
    overlay.addEventListener('click', e => {
      if (e.target === overlay) closeDialog();
    });
    textarea.addEventListener('input', updateLineNumbers);
    textarea.addEventListener('scroll', () => {
      gutter.scrollTop = textarea.scrollTop;
    });
    document.addEventListener('keydown', onKeydown, true);
    updateLineNumbers();
    textarea.focus();
  }

  async function performTableUpdate(action, { getSignature = getTableSignature, waitForChange } = {}) {
    const prevSignature = getSignature();
    action();
    if (typeof waitForChange === 'function') {
      await waitForChange(prevSignature);
    } else {
      await waitForTableChange(prevSignature);
    }
  }

  function isButtonDisabled(btn) {
    if (!btn) return true;
    return btn.disabled || btn.getAttribute('aria-disabled') === 'true';
  }

  async function ensurePageSize(select, options = {}) {
    if (!select) return;
    const desired = Array.from(select.options)
      .map(opt => parseInt(opt.value, 10))
      .filter(val => !Number.isNaN(val))
      .sort((a, b) => b - a)[0];
    if (!desired) return;
    if (parseInt(select.value, 10) === desired) return;
    await performTableUpdate(() => {
      select.value = String(desired);
      select.dispatchEvent(new Event('input', { bubbles: true }));
      select.dispatchEvent(new Event('change', { bubbles: true }));
    }, options);
  }

  async function goToFirstPage(pagination, options = {}) {
    if (!pagination) return false;
    const firstBtn =
      pagination.querySelector('button[aria-label*="First" i]') ||
      pagination.querySelector('li:first-child button');
    if (isButtonDisabled(firstBtn)) return false;
    await performTableUpdate(() => triggerClick(firstBtn), options);
    return true;
  }

  async function goToNextPage(pagination, options = {}) {
    if (!pagination) return false;
    const nextBtn =
      pagination.querySelector('button[aria-label*="Next" i]') ||
      pagination.querySelector('li:nth-child(4) button');
    if (isButtonDisabled(nextBtn)) return false;
    await performTableUpdate(() => triggerClick(nextBtn), options);
    return true;
  }

  async function iterateAllPages(processPage) {
    const table = findScansTable();
    if (!table) throw new Error('Scan table not found.');
    const pagination = getPaginationContainer();
    const select = getPageSizeSelect();
    await ensurePageSize(select);

    if (pagination) await goToFirstPage(pagination);

    let page = 1;
    while (true) {
      await processPage(page);
      if (!pagination) break;
      const advanced = await goToNextPage(pagination);
      if (!advanced) break;
      page++;
    }

    if (pagination && page > 1) {
      await goToFirstPage(pagination);
    }
  }

  let lastRenderedData = null;
  let modalContext = null;
  let buildDataPromise = null;
  let refreshMainViewPromise = null;

  function getBuildDataPromise() {
    if (!buildDataPromise) {
      buildDataPromise = (async () => {
        try {
          return await buildData();
        } finally {
          buildDataPromise = null;
        }
      })();
    }
    return buildDataPromise;
  }

  function captureAccordionState(container) {
    const scope = getActivePanelElement(container) || container;
    if (!scope) return null;
    const state = {};
    const detailsList = scope.querySelectorAll ? scope.querySelectorAll('details') : [];
    detailsList.forEach(details => {
      const summary = details.querySelector('summary');
      if (!summary) return;
      const key = summary.textContent.trim();
      state[key] = details.open;
    });
    return state;
  }

  function restoreAccordionState(container, state) {
    if (!container) return;
    const scope = getActivePanelElement(container) || container;
    if (!scope) return;
    const detailsList = scope.querySelectorAll ? scope.querySelectorAll('details') : [];
    if (!state) {
      detailsList.forEach(details => { details.open = false; });
      return;
    }
    detailsList.forEach(details => {
      details.open = false;
      const summary = details.querySelector('summary');
      if (!summary) return;
      const key = summary.textContent.trim();
      if (key in state) details.open = state[key];
    });
  }

  async function refreshMainView({ preserveState = true, targetTabKey } = {}) {
    if (pageContext !== 'scans') return null;
    if (refreshMainViewPromise) {
      logWidget('refreshMainView join in-flight', { preserveState, targetTabKey });
      return refreshMainViewPromise;
    }
    const runner = (async () => {
      if (!modalContext) {
        logWidget('refreshMainView (no modal) start', { preserveState, targetTabKey });
        if (targetTabKey) currentTabKey = targetTabKey;
        const data = await getBuildDataPromise();
        lastRenderedData = data;
        logWidget('refreshMainView (no modal) complete', { rowCount: data?.rows?.length || 0 });
        return data;
      }
      logWidget('refreshMainView start', { preserveState, targetTabKey, currentTabKey });
      const desiredTab = targetTabKey || currentTabKey || 'status';
      const { body, footer, updateFilterButtonLabel } = modalContext;
      if (preserveState) {
        const activePanel = getActivePanelElement(body);
        const existingState = captureAccordionState(activePanel || body);
        if (existingState) {
          accordionStateByTab[currentTabKey] = existingState;
        }
      }
      currentTabKey = desiredTab;
      const restoreState = accordionStateByTab[currentTabKey] || getDefaultAccordionState(currentTabKey);
      const data = await getBuildDataPromise();
      renderBody(body, data, updateFilterButtonLabel, footer, restoreState);
      const newPanel = getActivePanelElement(body);
      accordionStateByTab[currentTabKey] = captureAccordionState(newPanel || body) || {};
      logWidget('refreshMainView complete', { tab: currentTabKey, rowCount: data?.rows?.length || 0 });
      return data;
    })();
    refreshMainViewPromise = runner.finally(() => { refreshMainViewPromise = null; });
    return runner;
  }

  // --- Data builder ---

  async function buildDataSnapshot(mode = 'issues') {
    const snapshotStart = performance.now?.() || Date.now();
    logWidget('buildDataSnapshot start', { mode });
    await ensureViewMode(mode);
    const table = findScansTable();
    if (!table) throw new Error('Scan table not found.');

    const headers = Array.from(table.querySelectorAll('thead th'));
    const nameIdx = getColIndex(headers, 'scan name');
    const scoreIdx = getColIndex(headers, 'score');
    const statusIdx = getColIndex(headers, 'status');
    const lastRunIdx = getColIndex(headers, 'last run');
    const criticalIdx = getColIndex(headers, 'critical');
    const seriousIdx = getColIndex(headers, 'serious');
    const totalIdx = getColIndex(headers, 'total');
    const moderateIdx = getColIndex(headers, 'moderate');
    const minorIdx = getColIndex(headers, 'minor');
    const pagesIdx = headers.findIndex(th => {
      const text = th.textContent?.trim().toLowerCase() || '';
      if (!text) return false;
      return text.startsWith('pages') || text.includes('pages with');
    });

    if (scoreIdx === -1 || statusIdx === -1 || nameIdx === -1) {
      throw new Error('Could not find Scan Name / Score / Status columns.');
    }

    const impactMode = mode === 'pages' ? 'pages' : 'issues';
    const sortMeta = detectSortMeta(headers, {
      nameIdx,
      scoreIdx,
      statusIdx,
      lastRunIdx,
      criticalIdx,
      seriousIdx,
      totalIdx
    });
    currentSortMeta = sortMeta;

    const now = new Date();
    const nowMs = now.getTime();

    const bucketLabels = scoreBucketSpecs.map(spec => spec.label);
    const makeBuckets = () => makeScoreBuckets();

    const rows = [];
    let globalRowIndex = 0;

    const parseRowElement = tr => {
      const cells = Array.from(tr.querySelectorAll('td,th'));
      const nameCell = cells[nameIdx] || null;
      const rawName = nameCell?.textContent.trim() || '';
      const nameLink = nameCell?.querySelector('a');
      const scanUrl = nameLink?.href || null;
      const scanId = extractScanIdFromUrl(scanUrl);

      let type = 'Other';
      let domain = 'Other';
      if (rawName.includes(' - ')) {
        const parts = rawName.split(' - ');
        if (parts.length >= 2) {
          type = (parts[parts.length - 1] || '').trim() || 'Other';
          const dom = parts.slice(0, -1).join(' - ').trim();
          domain = dom || 'Other';
        }
      }

      const statusText = (cells[statusIdx]?.textContent || '').trim();
      let statusKey = 'Other';
      if (/complete/i.test(statusText)) statusKey = 'Complete';
      else if (/queued/i.test(statusText)) statusKey = 'Queued';
      else if (/cancel/i.test(statusText)) statusKey = 'Cancelled';

      const scoreText = (cells[scoreIdx]?.textContent || '').trim();
      const scoreVal = parseFloat(scoreText.replace('%',''));
      const scoreBucket = getScoreBucketLabel(scoreVal);

      let lastRun = null;
      if (lastRunIdx !== -1) {
        const cell = cells[lastRunIdx];
        if (cell) {
          const timeEl = cell.querySelector('time');
          const dtAttr = timeEl?.getAttribute('datetime');
          const rel = cell.textContent.trim();
          if (dtAttr) {
            const dt = new Date(dtAttr);
            if (!isNaN(dt)) lastRun = dt;
          } else if (rel && /\d/.test(rel)) {
            const dt = new Date(rel);
            if (!isNaN(dt)) lastRun = dt;
          }
        }
      }

      let crit = null, serious = null, moderate = null, minor = null, total = null, impactTotal = null, pages = null;
      if (pagesIdx !== -1) {
        pages = parseNum(cells[pagesIdx]?.innerText);
      }
      if (statusKey === 'Complete') {
        if (criticalIdx !== -1) crit = parseNum(cells[criticalIdx]?.innerText);
        if (seriousIdx !== -1) serious = parseNum(cells[seriousIdx]?.innerText);
        if (moderateIdx !== -1) moderate = parseNum(cells[moderateIdx]?.innerText);
        if (minorIdx !== -1) minor = parseNum(cells[minorIdx]?.innerText);
        if (totalIdx !== -1) total = parseNum(cells[totalIdx]?.innerText);
        if (crit != null && serious != null) {
          impactTotal = crit + serious;
        }
      }

      const rowEntry = {
        name: rawName,
        type,
        domain,
        statusKey,
        statusText,
        scoreText,
        scoreVal,
        scoreBucket,
        lastRun,
        crit, serious, moderate, minor, total, impactTotal,
        pages,
        scanId,
        url: scanUrl,
        originalIndex: globalRowIndex
      };
      if (impactMode === 'pages') {
        rowEntry.pageCritical = crit;
        rowEntry.pageSerious = serious;
        rowEntry.pageModerate = moderate;
        rowEntry.pageMinor = minor;
      }
      rowEntry.sortValue = getRowSortComparable(sortMeta, rowEntry, cells);
      globalRowIndex += 1;
      return rowEntry;
    };

    await iterateAllPages(async () => {
      const currentTable = findScansTable();
      if (!currentTable) return;
      const pageRows = Array.from(currentTable.querySelectorAll('tbody tr'))
        .filter(tr => tr.querySelectorAll('td,th').length);
      pageRows.forEach(tr => rows.push(parseRowElement(tr)));
    });

    // Filtered subset (empty filter = all)
    const filtered = rows.filter(r => {
      if (currentFilters.types.size && !currentFilters.types.has(r.type)) return false;
      if (currentFilters.domains.size && !currentFilters.domains.has(r.domain)) return false;
      if (currentFilters.statuses.size && !currentFilters.statuses.has(r.statusKey)) return false;
      return true;
    });

    const totalRows = filtered.length || 1;
    const statusCounts = { Complete:0, Queued:0, Cancelled:0, Other:0 };

    const scoreAll = makeBuckets();
    const byType = {};
    const completedLast24hByType = {};
    const completeRunTimes = [];
    const completeRunsLast24h = [];
    const impactIssuesByType = {}; // all types
    const impactPagesByType = {};

    filtered.forEach(r => {
      statusCounts[r.statusKey] = (statusCounts[r.statusKey] || 0) + 1;

      if (r.scoreBucket) {
        scoreAll[r.scoreBucket]++;
        if (!byType[r.type]) byType[r.type] = makeBuckets();
        byType[r.type][r.scoreBucket]++;
      }

      if (r.statusKey === 'Complete' && r.lastRun) {
        completeRunTimes.push(r.lastRun);
        const diff = nowMs - r.lastRun.getTime();
        if (diff >= 0 && diff <= msPerDay) {
          completeRunsLast24h.push(r);
          completedLast24hByType[r.type] = (completedLast24hByType[r.type] || 0) + 1;
        }
      }

      if (
        r.statusKey === 'Complete' &&
        Number.isFinite(r.scoreVal)
      ) {
        const selectedIssueTotal = getIssueTotal(r);
        if (selectedIssueTotal > 0) {
          if (!impactIssuesByType[r.type]) {
            impactIssuesByType[r.type] = initImpactBuckets(impactIssueBandOrder);
          }
          impactIssuesByType[r.type][getImpactBandIssues(selectedIssueTotal)]++;
        }
      }

      if (
        r.statusKey === 'Complete' &&
        typeof r.pages === 'number' &&
        Number.isFinite(r.pages)
      ) {
        if (!impactPagesByType[r.type]) {
          impactPagesByType[r.type] = [];
        }
        impactPagesByType[r.type].push(r);
      }
    });

    // Completed today metrics: average per hour over last 12h
    const totalLast24h = completeRunsLast24h.length;
    const twelveHoursMs = 12 * msPerHour;
    let avgPerHour12 = 0;
    if (totalLast24h > 0) {
      const recent = completeRunsLast24h.filter(r => r.lastRun && (nowMs - r.lastRun.getTime()) <= twelveHoursMs);
      const spanHours = 12;
      avgPerHour12 = recent.length / spanHours;
    }

    // Recent completion windows: fixed time ranges
    const windowRows = [];
    if (completeRunTimes.length) {
      function countWithin(msWindow) {
        return completeRunTimes.reduce((acc, dt) => {
          const diff = nowMs - dt.getTime();
          return (diff >= 0 && diff <= msWindow) ? acc + 1 : acc;
        }, 0);
      }

      const pushWindow = (label, windowMs, minMs) => {
        if (!label || windowMs <= 0) return;
        const count = minMs !== undefined ? 
          completeRunTimes.reduce((acc, dt) => {
            const diff = nowMs - dt.getTime();
            return (diff >= 0 && diff > minMs && diff <= windowMs) ? acc + 1 : acc;
          }, 0) : 
          countWithin(windowMs);
        windowRows.push({ label, count, windowMs, minMs });
      };

      // Fixed time ranges as requested
      pushWindow('Last 24 hours', msPerDay);
      pushWindow('Last 7 days', 7 * msPerDay);
      pushWindow('Last 30 days', 30 * msPerDay);
      pushWindow('1-2 months', 60 * msPerDay, 30 * msPerDay);
      pushWindow('2-4 months', 120 * msPerDay, 60 * msPerDay);
      pushWindow('4-6 months', 180 * msPerDay, 120 * msPerDay);
      pushWindow('6+ months', Infinity, 180 * msPerDay);
    }

    const typeOptions = Array.from(new Set(rows.map(r => r.type))).sort();
    const domainOptions = Array.from(new Set(rows.map(r => r.domain))).sort();
    const statusOptions = Array.from(new Set(rows.map(r => r.statusKey))).sort();
    const runsInProgress = parseRunsInProgress();

    const snapshot = {
      mode: impactMode,
      now,
      rows,
      filtered,
      totalRows,
      statusCounts,
      bucketLabels,
      scoreAll,
      byType,
      completedLast24hByType,
      totalLast24h,
      avgPerHour12,
      windowRows,
      impactIssuesByType,
      impactPagesByType,
      runsInProgress,
      typeOptions,
      domainOptions,
      statusOptions
    };
    const snapshotEnd = performance.now?.() || Date.now();
    logWidget('buildDataSnapshot complete', {
      mode,
      rows: rows.length,
      filtered: filtered.length,
      durationMs: Math.round(snapshotEnd - snapshotStart)
    });
    return snapshot;
  }

  async function buildData() {
    const buildStart = performance.now?.() || Date.now();
    logWidget('buildData start');
    const originalView = getActiveViewMode();
    const issuesData = await buildDataSnapshot('issues');
    let pagesSummary = null;
    try {
      pagesSummary = await buildDataSnapshot('pages');
    } finally {
      await ensureViewMode(originalView);
    }
    issuesData.pagesSummary = pagesSummary;
    const buildEnd = performance.now?.() || Date.now();
    logWidget('buildData complete', {
      issuesRows: issuesData.rows?.length || 0,
      filteredRows: issuesData.filtered?.length || 0,
      durationMs: Math.round(buildEnd - buildStart)
    });
    return issuesData;
  }

  // --- Scan list dialog (from counts) ---

  function openScansListDialog(contextLabel, scans, onClose, options = {}) {
    if (!scans || !scans.length) return;

    const dialogMode = options.mode || 'issues';
    const downloadBase = options.filenameBase || (dialogMode === 'pages' ? 'page-impact-drilldown' : 'scan-drilldown');
    let impactColumns = dialogMode === 'pages'
      ? pageImpactFilterOptions.filter(opt => getActivePageImpactKeys().includes(opt.key))
      : [];
    if (dialogMode === 'pages' && !impactColumns.length) {
      impactColumns = pageImpactFilterOptions.slice();
    }
    const hasPageColumns = dialogMode === 'pages';
    const pageColumnHeaders = hasPageColumns
      ? impactColumns.map(opt => `Pages with ${opt.label} issues`)
      : [];

    const overlay = document.createElement('div');
    overlay.className = 'a11y-filter-overlay'; // reuse styling
    const dialog = document.createElement('div');
    dialog.className = 'a11y-filter-dialog a11y-scans-dialog';
    dialog.setAttribute('role','dialog');
    dialog.setAttribute('aria-modal','true');

    const header = document.createElement('div');
    header.className = 'a11y-filter-header';
    const h2 = document.createElement('h2');
    const scanDialogTitleId = 'a11y-scan-drilldown-title';
    h2.id = scanDialogTitleId;
    h2.textContent = contextLabel;
    header.appendChild(h2);
    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'Dialog__close';
    closeBtn.innerHTML = '<span aria-hidden="true" class="Icon Icon--close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" height="24" width="24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" fill="currentColor"></path></svg></span><span class="Offscreen">Close</span>';
    header.appendChild(closeBtn);
    dialog.appendChild(header);
    dialog.setAttribute('aria-labelledby', scanDialogTitleId);

    const content = document.createElement('div');
    content.className = 'a11y-filter-content a11y-scans-dialog-content';

    const table = document.createElement('table');
    table.className = 'a11y-scan-report-table';
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    const baseHeaders = ['Scan Name','Score'];
    const trailingHeaders = ['Last Run','Status'];
    let bodyHeaders = [];
    if (hasPageColumns) {
      bodyHeaders = [...pageColumnHeaders, 'Total pages with selected impacts'];
    } else {
      bodyHeaders = ['Critical','Serious','Moderate*','Minor*','Total'];
    }
    [...baseHeaders, ...bodyHeaders, ...trailingHeaders].forEach(t => {
      const th = document.createElement('th');
      th.textContent = t;
      th.setAttribute('scope','col');
      hr.appendChild(th);
    });
    thead.appendChild(hr);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    scans.forEach(r => {
      const tr = document.createElement('tr');

      const nameCell = document.createElement('th');
      nameCell.setAttribute('scope','row');
      nameCell.appendChild(createScanLink(r));
      tr.appendChild(nameCell);

      const scoreCell = document.createElement('td');
      scoreCell.textContent = r.scoreText || (Number.isFinite(r.scoreVal) ? `${r.scoreVal}%` : '');
      tr.appendChild(scoreCell);

      if (hasPageColumns) {
        const counts = getFilteredPageImpactCounts(r);
        let rowTotal = 0;
        impactColumns.forEach(opt => {
          const td = document.createElement('td');
          const count = Math.max(0, coerceNumber(counts[opt.key], 0));
          td.textContent = String(count);
          tr.appendChild(td);
          rowTotal += count;
        });
        const totalCell = document.createElement('td');
        totalCell.textContent = String(rowTotal);
        tr.appendChild(totalCell);
      } else {
        const counts = getIssueImpactCounts(r);
        const getCountValue = key => Math.max(0, coerceNumber(counts[key], 0));
        const appendIssueCell = key => {
          const td = document.createElement('td');
          const needsApi = requiresMonitorApiImpact(key);
          const hasValue = !needsApi || hasIssueImpactValue(r, key);
          if (hasValue) {
            td.textContent = String(getCountValue(key));
          } else {
            td.textContent = '-';
          }
          tr.appendChild(td);
        };

        appendIssueCell('critical');
        appendIssueCell('serious');
        appendIssueCell('moderate');
        appendIssueCell('minor');

        const totalCell = document.createElement('td');
        let totalIssues = getCountValue('critical') + getCountValue('serious');
        if (hasIssueImpactValue(r, 'moderate')) totalIssues += getCountValue('moderate');
        if (hasIssueImpactValue(r, 'minor')) totalIssues += getCountValue('minor');
        totalCell.textContent = String(totalIssues);
        tr.appendChild(totalCell);
      }

      const runCell = document.createElement('td');
      runCell.textContent = r.lastRun ? r.lastRun.toLocaleString() : '';
      tr.appendChild(runCell);

      const statusCell = document.createElement('td');
      statusCell.textContent = r.statusText || r.statusKey || '';
      tr.appendChild(statusCell);

      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    appendTableWithDownload(content, table, { filenameBase: downloadBase, buttonLabel: 'Download CSV' });
  appendMonitorApiFootnote(content);
    dialog.appendChild(content);

    const footer = document.createElement('div');
    footer.className = 'a11y-filter-footer';
    const okBtn = document.createElement('button');
    okBtn.type = 'button';
    okBtn.className = 'a11y-btn-primary';
    okBtn.textContent = 'Close';
    footer.appendChild(okBtn);
    dialog.appendChild(footer);

    overlay.appendChild(dialog);
    appendOverlayAfterFooter(overlay);

    const lastFocused = document.activeElement;

    function close() {
      document.removeEventListener('keydown', onKeydown, true);
      overlay.remove();
      if (typeof onClose === 'function') {
        try {
          const maybePromise = onClose();
          if (maybePromise && typeof maybePromise.catch === 'function') {
            maybePromise.catch(err => console.error(err));
          }
        } catch (err) {
          console.error(err);
        }
      }
      if (lastFocused && lastFocused.focus) lastFocused.focus();
    }

    function onKeydown(e) {
      if (e.key === 'Escape') {
        e.preventDefault();
        close();
      } else if (e.key === 'Tab') {
        const f = getFocusable(dialog);
        if (!f.length) return;
        const first = f[0];
        const last = f[f.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault(); last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault(); first.focus();
        }
      }
    }

    document.addEventListener('keydown', onKeydown, true);
    closeBtn.addEventListener('click', close);
    okBtn.addEventListener('click', close);
    overlay.addEventListener('click', e => { if (e.target === overlay) close(); });

    h2.setAttribute('tabindex','-1');
    h2.focus();
  }

  function comparePrimaryValues(a, b, direction) {
    const aMissing = a == null;
    const bMissing = b == null;
    if (aMissing && bMissing) return 0;
    if (aMissing) return 1;
    if (bMissing) return -1;

    let base = 0;
    if (typeof a === 'number' && typeof b === 'number') {
      base = a === b ? 0 : (a < b ? -1 : 1);
    } else {
      base = String(a).localeCompare(String(b), undefined, { sensitivity: 'base' });
    }

    if (base === 0) return 0;
    return direction === 'desc' ? -base : base;
  }

  function sortScans(scans, mode = 'scoreThenName') {
    if (!Array.isArray(scans)) return [];
    const items = scans.slice();
    const getScore = row => Number.isFinite(row.scoreVal) ? row.scoreVal : -Infinity;
    items.sort((a, b) => {
      if (mode === 'critSerDesc') {
        const sum = r => (Number.isFinite(r.crit) ? r.crit : 0) + (Number.isFinite(r.serious) ? r.serious : 0);
        const diff = sum(b) - sum(a);
        if (diff !== 0) return diff;
        return (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' });
      }
      if (mode === 'recent') {
        const ta = a.lastRun ? a.lastRun.getTime() : -Infinity;
        const tb = b.lastRun ? b.lastRun.getTime() : -Infinity;
        if (tb !== ta) return tb - ta;
        return (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' });
      }
      if (mode === 'totalDesc') {
        const totalA = Number.isFinite(a.total) ? a.total : Number.isFinite(a.impactTotal) ? a.impactTotal : (Number.isFinite(a.crit) && Number.isFinite(a.serious) ? a.crit + a.serious : -Infinity);
        const totalB = Number.isFinite(b.total) ? b.total : Number.isFinite(b.impactTotal) ? b.impactTotal : (Number.isFinite(b.crit) && Number.isFinite(b.serious) ? b.crit + b.serious : -Infinity);
        if (totalB !== totalA) return totalB - totalA;
        return (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' });
      }
      if (mode === 'nameOnly') {
        return (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' });
      }
      const scoreDiff = getScore(b) - getScore(a);
      if (scoreDiff !== 0) return scoreDiff;
      const nameCompare = (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' });
      if (nameCompare !== 0) return nameCompare;
      return (a.originalIndex ?? 0) - (b.originalIndex ?? 0);
    });
    return items;
  }

  // --- Tables with clickable counts ---

  function makeCountButton(count, context, predicate, options = {}) {
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'a11y-scan-report-count-btn';
    btn.textContent = String(count);
    btn.style.border = 'none';
    btn.style.background = 'none';
    btn.style.padding = '0';
    btn.style.margin = '0';
    btn.style.textDecoration = 'underline';
    btn.style.cursor = 'pointer';
    btn.setAttribute('role','button');

    const label = `${count} Scans - ${context}`;
    btn.setAttribute('aria-label', label);

    btn.addEventListener('click', async () => {
      try {
        const data = await refreshMainView({ preserveState: true });
        let rows = [];
        if (typeof options.getRows === 'function') {
          rows = options.getRows(data) || [];
        } else {
          const sourceRows = options.source === 'all' ? data.rows : data.filtered;
          const predicateFn = typeof predicate === 'function' ? predicate : () => true;
          rows = sourceRows.filter(predicateFn);
        }
        const sortMode = options.sortMode || (options.context === 'impact' ? 'nameOnly' : 'scoreThenName');
        const sorted = sortScans(rows, sortMode);
        if (options.openDialog) {
          options.openDialog(sorted);
        } else {
          openScansListDialog(
            context,
            sorted,
            () => refreshMainView({ preserveState: true }),
            options.dialogOptions || {}
          );
        }
      } catch (e) {
        alert(e.message);
      }
    });

    return btn;
  }

  function createExternalIcon() {
    const span = document.createElement('span');
    span.setAttribute('aria-hidden','true');
    span.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" focusable="false">
        <path d="M19 19H5V5h7V3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7z"/>
        <path d="M21 3h-6v2h3.59l-9.83 9.83 1.41 1.41L20 6.41V10h2z"/>
      </svg>
    `;
    return span;
  }

  function createScanLink(row) {
    if (!row || !row.url) {
      const span = document.createElement('span');
      span.textContent = row?.name || '';
      return span;
    }
    const link = document.createElement('a');
    link.href = row.url;
    link.target = '_blank';
    link.rel = 'noopener';
    link.className = 'a11y-scan-link';
    link.textContent = row.name || '';
    const icon = createExternalIcon();
    link.appendChild(icon);
    const sr = document.createElement('span');
    sr.className = 'sr-only';
    sr.textContent = 'Opens in new window';
    link.appendChild(sr);
    return link;
  }

  function createExternalLink(url, label = 'Open link') {
    if (!url) return null;
    const link = document.createElement('a');
    link.href = url;
    link.target = '_blank';
    link.rel = 'noopener';
    link.textContent = label;
    link.className = 'a11y-link-button';
    return link;
  }

  function sanitizeFilename(base) {
    return (base || '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '')
      .slice(0, 60) || 'table';
  }

  function getCellCsvText(cell) {
    if (!cell) return '';
    const select = cell.querySelector('select');
    if (select) {
      const option = select.options[select.selectedIndex];
      const value = option?.textContent ?? select.value;
      return value ? value.trim() : '';
    }
    if (cell.dataset?.csvValue != null) {
      return cell.dataset.csvValue;
    }
    const checkbox = cell.querySelector('input[type="checkbox"]');
    if (checkbox) {
      const checkedLabel = cell.dataset?.csvChecked ?? 'Yes';
      const uncheckedLabel = cell.dataset?.csvUnchecked ?? 'No';
      return checkbox.checked ? checkedLabel : uncheckedLabel;
    }
    return (cell.textContent || '').replace(/\s+/g, ' ').trim();
  }

  function tableToCsv(table) {
    const rows = Array.from(table.querySelectorAll('tr'));
    return rows
      .map(row => {
        const cells = Array.from(row.querySelectorAll('th,td'));
        return cells
          .map(cell => {
            const text = getCellCsvText(cell);
            const escaped = text.replace(/"/g, '""');
            return /[",\n]/.test(text) ? `"${escaped}"` : escaped;
          })
          .join(',');
      })
      .join('\n');
  }

  function downloadCsv(content, filename) {
    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    triggerClick(link);
    document.body.removeChild(link);
    setTimeout(() => URL.revokeObjectURL(url), 500);
  }

  function objectsToCsv(rows, columns) {
    if (!rows?.length || !columns?.length) return '';
    const header = columns.map(col => col.label).join(',');
    const body = rows
      .map(row => columns.map(col => {
        const value = col.format ? col.format(row[col.key], row) : row[col.key];
        const text = value == null ? '' : String(value);
        const escaped = text.replace(/"/g,'""');
        return /[",\n]/.test(text) ? `"${escaped}"` : escaped;
      }).join(','))
      .join('\n');
    return [header, body].filter(Boolean).join('\n');
  }

  function downloadObjectCsv(rows, columns, filenameBase) {
    if (!rows?.length) {
      alert('No data available to download.');
      return;
    }
    const csv = objectsToCsv(rows, columns);
    const filename = `${sanitizeFilename(filenameBase || 'data')}-${new Date().toISOString().slice(0,10)}.csv`;
    downloadCsv(csv, filename);
  }

  async function writeTextToClipboard(text) {
    if (navigator.clipboard?.writeText) {
      await navigator.clipboard.writeText(text);
      return true;
    }
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.top = '-9999px';
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    let success = false;
    try {
      success = document.execCommand('copy');
    } catch (err) {
      success = false;
    } finally {
      document.body.removeChild(textarea);
    }
    return success;
  }

  function appendTableWithDownload(target, table, { filenameBase, buttonLabel } = {}) {
    if (!table || !target) return table;
    if (table.dataset.downloadReady === 'true') {
      target.appendChild(table.parentElement || table);
      return table;
    }
    const base = sanitizeFilename(filenameBase || table.caption?.textContent || 'table');
    const container = document.createElement('div');
    container.className = 'a11y-table-container';
    const toolbar = document.createElement('div');
    toolbar.className = 'a11y-table-toolbar';
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'a11y-table-download-btn';
    btn.textContent = buttonLabel || 'Download CSV';
    btn.addEventListener('click', () => {
      try {
        const csv = tableToCsv(table);
        const filename = `${base}-${new Date().toISOString().slice(0,10)}.csv`;
        downloadCsv(csv, filename);
      } catch (err) {
        console.error(err);
        alert('Unable to download CSV.');
      }
    });
    toolbar.appendChild(btn);
    container.appendChild(toolbar);
    container.appendChild(table);
    table.dataset.downloadReady = 'true';
    target.appendChild(container);
    return table;
  }

  function appendBandDownloadButton(target, rows, { filenameBase, label, columns, bandOrder, rowFilter, groupLabel, metricsType = 'issues' } = {}) {
    if (!target || !Array.isArray(rows) || !rows.length) return;
    const toolbar = document.createElement('div');
    toolbar.className = 'a11y-table-toolbar';
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'a11y-table-download-btn';
    btn.textContent = label || 'Download all band data';
    btn.addEventListener('click', async () => {
      try {
        // If bandOrder and rowFilter are provided, export detailed scan data
        if (bandOrder && typeof rowFilter === 'function') {
          const data = await refreshMainView({ preserveState: true });
          const usePageMetrics = metricsType === 'pages';
          const sourceRows = usePageMetrics
            ? (data.pagesSummary?.filtered || [])
            : (data.filtered || []);
          const allBandScans = [];
          
          // Collect all scans from each band
          // bandOrder can be either an array of band labels or array of {type, band} objects
          bandOrder.forEach(bandItem => {
            const bandScans = sourceRows.filter(r => rowFilter(r, bandItem));
            bandScans.forEach(scan => {
              const bandLabel = typeof bandItem === 'string' ? bandItem : bandItem.band;
              const groupLabelValue = typeof bandItem === 'string' ? 
                (groupLabel || '') : 
                (bandItem.type || groupLabel || '');
              const metricsCounts = usePageMetrics ? getPageImpactCounts(scan) : getIssueImpactCounts(scan);
              
              allBandScans.push({
                band: bandLabel,
                group: groupLabelValue,
                name: scan.name || '',
                type: scan.type || '',
                domain: scan.domain || '',
                status: scan.statusText || '',
                score: scan.scoreVal != null ? scan.scoreVal : '',
                critical: metricsCounts.critical != null ? metricsCounts.critical : '',
                serious: metricsCounts.serious != null ? metricsCounts.serious : '',
                moderate: metricsCounts.moderate != null ? metricsCounts.moderate : '',
                minor: metricsCounts.minor != null ? metricsCounts.minor : '',
                total: scan.total != null ? scan.total : '',
                pages: scan.pages != null ? scan.pages : '',
                lastRun: scan.lastRun ? scan.lastRun.toISOString() : '',
                url: scan.url || ''
              });
            });
          });
          
          downloadObjectCsv(allBandScans, [
            { key: 'band', label: 'Band' },
            { key: 'group', label: 'Group' },
            { key: 'name', label: 'Scan Name' },
            { key: 'type', label: 'Type' },
            { key: 'domain', label: 'Domain' },
            { key: 'status', label: 'Status' },
            { key: 'score', label: 'Score' },
            { key: 'critical', label: 'Critical' },
            { key: 'serious', label: 'Serious' },
            { key: 'moderate', label: 'Moderate' },
            { key: 'minor', label: 'Minor' },
            { key: 'total', label: 'Total Issues' },
            { key: 'pages', label: 'Pages' },
            { key: 'lastRun', label: 'Last Run' },
            { key: 'url', label: 'URL' }
          ], filenameBase || 'band-data-detailed');
        } else {
          // Fallback to summary data
          downloadObjectCsv(rows, columns || [
            { key: 'group', label: 'Group' },
            { key: 'band', label: 'Band' },
            { key: 'count', label: 'Count' },
            { key: 'percent', label: 'Percent' }
          ], filenameBase || 'band-data');
        }
      } catch (err) {
        console.error(err);
        alert('Unable to download band data.');
      }
    });
    toolbar.appendChild(btn);
    target.appendChild(toolbar);
  }

  // --- Renderers ---

  function renderScoreTable(details, buckets, total, bandOrder, explain, rowFilter, contextPrefix = '', options = {}) {
    if (!total) {
      const p = document.createElement('p');
      p.textContent = 'No scans in this group.';
      details.appendChild(p);
      return [];
    }

    const table = document.createElement('table');
    table.className = 'a11y-scan-report-table';

    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    ['Band','Scans','Percent'].forEach(t => {
      const th = document.createElement('th');
      th.textContent = t;
      th.setAttribute('scope','col');
      hr.appendChild(th);
    });
    thead.appendChild(hr);
    table.appendChild(thead);

    const exportRows = [];
    const tbody = document.createElement('tbody');
    bandOrder.forEach(band => {
      const count = buckets[band] || 0;
      if (!count) return;
      const pctNum = (count / total) * 100;
      const pctText = pctNum.toFixed(1) + '%';

      const tr = document.createElement('tr');

      const bandHeader = document.createElement('th');
      bandHeader.setAttribute('scope','row');
      bandHeader.textContent = band;
      tr.appendChild(bandHeader);

      const tdScans = document.createElement('td');
      const context = `${band} - ${contextPrefix}`;
      const btn = makeCountButton(
        count,
        context,
        r => rowFilter(r, band),
        { sortMode: 'scoreThenName' }
      );
      tdScans.appendChild(btn);
      tr.appendChild(tdScans);

      const tdPct = document.createElement('td');
      const wrap = document.createElement('div');
      wrap.className = 'a11y-impact-bar-wrap';

      const bar = document.createElement('div');
      bar.className = 'a11y-impact-bar';
      bar.style.width = pctNum.toFixed(1) + '%';
      bar.style.backgroundColor = getSeverityColorForBand(band, bandOrder);

      const span = document.createElement('span');
      span.textContent = pctText;

      wrap.appendChild(bar);
      wrap.appendChild(span);
      tdPct.appendChild(wrap);
      tr.appendChild(tdPct);

      tbody.appendChild(tr);

      exportRows.push({
        group: options.groupLabel || contextPrefix || 'Summary',
        band,
        count,
        percent: pctNum.toFixed(1)
      });
    });

    table.appendChild(tbody);
    appendTableWithDownload(details, table, { filenameBase: options.filenameBase || contextPrefix || 'score-table' });

    const p = document.createElement('p');
    p.style.fontSize = '11px';
    p.style.margin = '2px 0 4px';
    p.textContent = explain;
    details.appendChild(p);
    return exportRows;
  }

  function buildScanMetricsTable(rows, { includeSumRow = false } = {}) {
    const table = document.createElement('table');
    table.className = 'a11y-scan-report-table';

    const impactColumns = pageImpactFilterOptions.slice();
    const activeImpacts = new Set(getActivePageImpactKeys());

    const thead = document.createElement('thead');
    const hr = document.createElement('tr');

    const scanTh = document.createElement('th');
    scanTh.textContent = 'Scan';
    scanTh.setAttribute('scope','col');
    hr.appendChild(scanTh);

    impactColumns.forEach(impact => {
      const th = document.createElement('th');
      th.textContent = requiresMonitorApiImpact(impact.key) ? `${impact.label}*` : impact.label;
      th.setAttribute('scope','col');
      hr.appendChild(th);
    });

    ['Total of selected impacts','Total of all issues'].forEach(t => {
      const th = document.createElement('th');
      th.textContent = t;
      th.setAttribute('scope','col');
      hr.appendChild(th);
    });

    thead.appendChild(hr);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    const impactTotals = {};
    impactColumns.forEach(impact => {
      impactTotals[impact.key] = { value: 0, hasData: !requiresMonitorApiImpact(impact.key) };
    });
    let selectedTotal = 0;
    let issuesTotal = 0;

    rows.forEach(scan => {
      const tr = document.createElement('tr');
      const nameCell = document.createElement('th');
      nameCell.setAttribute('scope','row');
      nameCell.appendChild(createScanLink(scan));
      tr.appendChild(nameCell);

  const counts = getIssueImpactCounts(scan);
  const getCountValue = key => Math.max(0, coerceNumber(counts[key], 0));
  let rowSelectedTotal = 0;
  let rowAllIssues = getCountValue('critical') + getCountValue('serious');

      impactColumns.forEach(impact => {
        const td = document.createElement('td');
        const needsApi = requiresMonitorApiImpact(impact.key);
        const hasValue = !needsApi || hasIssueImpactValue(scan, impact.key);
        if (hasValue) {
          const value = getCountValue(impact.key);
          td.textContent = String(value);
          if (activeImpacts.has(impact.key)) {
            rowSelectedTotal += value;
          }
          impactTotals[impact.key].value += value;
          impactTotals[impact.key].hasData = true;
          if (impact.key === 'moderate' || impact.key === 'minor') {
            rowAllIssues += value;
          }
        } else {
          td.textContent = '-';
        }
        tr.appendChild(td);
      });

      selectedTotal += rowSelectedTotal;
      issuesTotal += rowAllIssues;

      const selCell = document.createElement('td');
      selCell.textContent = String(rowSelectedTotal);
      tr.appendChild(selCell);

      const totalCell = document.createElement('td');
      totalCell.textContent = String(rowAllIssues);
      tr.appendChild(totalCell);

      tbody.appendChild(tr);
    });

    if (includeSumRow) {
      const sumRow = document.createElement('tr');
      sumRow.className = 'a11y-table-sum-row';
      const labelCell = document.createElement('th');
      labelCell.setAttribute('scope','row');
      labelCell.textContent = 'Total';
      sumRow.appendChild(labelCell);

      impactColumns.forEach(impact => {
        const td = document.createElement('td');
        const totalInfo = impactTotals[impact.key];
        td.textContent = totalInfo.hasData ? String(totalInfo.value) : '-';
        sumRow.appendChild(td);
      });

      const selCell = document.createElement('td');
      selCell.textContent = String(selectedTotal);
      sumRow.appendChild(selCell);

      const totalCell = document.createElement('td');
      totalCell.textContent = String(issuesTotal);
      sumRow.appendChild(totalCell);

      tbody.appendChild(sumRow);
    }

    table.appendChild(tbody);
    return table;
  }

  function appendMonitorApiFootnote(target) {
    if (!target) return;
    if (target.querySelector('[data-monitor-api-footnote="true"]')) return;
    const note = document.createElement('p');
    note.className = 'a11y-monitor-api-footnote';
    note.dataset.monitorApiFootnote = 'true';
    note.style.fontSize = '11px';
    note.style.margin = '4px 0 0';
    note.textContent = monitorApiFootnoteText;
    target.appendChild(note);
  }

  function buildPagesMetricsTable(rows, { includeSumRow = false } = {}) {
    const table = document.createElement('table');
    table.className = 'a11y-scan-report-table';
    const activeImpacts = getActivePageImpactKeys();
    const impactColumns = pageImpactFilterOptions.filter(opt => activeImpacts.includes(opt.key));

    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    const headers = ['Scan', ...impactColumns.map(opt => `Pages with ${opt.label} issues`), 'Total pages with selected impacts'];
    headers.forEach(text => {
      const th = document.createElement('th');
      th.textContent = text;
      th.setAttribute('scope','col');
      hr.appendChild(th);
    });
    thead.appendChild(hr);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    const impactTotals = {};
    impactColumns.forEach(opt => {
      impactTotals[opt.key] = 0;
    });
    let selectedTotal = 0;

    rows.forEach(scan => {
      const counts = getFilteredPageImpactCounts(scan);
      const tr = document.createElement('tr');
      const nameCell = document.createElement('th');
      nameCell.setAttribute('scope','row');
      nameCell.appendChild(createScanLink(scan));
      tr.appendChild(nameCell);

      let rowSelectedTotal = 0;
      impactColumns.forEach(opt => {
        const count = counts[opt.key] || 0;
        impactTotals[opt.key] += count;
        rowSelectedTotal += count;
        const td = document.createElement('td');
        td.textContent = String(count);
        tr.appendChild(td);
      });

      const totalCell = document.createElement('td');
      totalCell.textContent = String(rowSelectedTotal);
      tr.appendChild(totalCell);
      selectedTotal += rowSelectedTotal;
      tbody.appendChild(tr);
    });

    if (includeSumRow) {
      const tr = document.createElement('tr');
      tr.className = 'a11y-table-sum-row';
      const labelCell = document.createElement('th');
      labelCell.setAttribute('scope','row');
      labelCell.textContent = 'Total';
      tr.appendChild(labelCell);

      impactColumns.forEach(opt => {
        const td = document.createElement('td');
        td.textContent = String(impactTotals[opt.key] || 0);
        tr.appendChild(td);
      });

      const totalCell = document.createElement('td');
      totalCell.textContent = String(selectedTotal);
      tr.appendChild(totalCell);
      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    return table;
  }

  function createScanSelect(options, currentValue) {
    const select = document.createElement('select');
    select.className = 'a11y-was-config-select';
    const blank = document.createElement('option');
    blank.value = '';
    blank.textContent = '(none)';
    select.appendChild(blank);

    const normalizedSet = new Set();
    const findScanIdForName = name => {
      if (!name) return null;
      const explicit = extractScanIdFromLabel(name);
      if (explicit) return explicit;
      if (!wasRuntimeContext?.rowLookup) return null;
      const row = getRowByName(wasRuntimeContext.rowLookup, name);
      if (!row) return null;
      return getRowScanId(row);
    };
    const appendOption = optionData => {
      if (!optionData) return;
      const entry = typeof optionData === 'string'
        ? { value: optionData, label: optionData, id: null }
        : optionData;
      const rawValue = entry.value ?? entry.label;
      if (rawValue == null) return;
      const value = String(rawValue);
      const label = entry.label != null ? String(entry.label) : value;
      const id = entry.id || null;
      const normalized = normalizeScanOptionKey(value);
      if (!normalized || normalizedSet.has(normalized)) return;
      normalizedSet.add(normalized);
      const option = document.createElement('option');
      option.value = value;
      option.textContent = formatScanLabelWithId(label, id);
      select.appendChild(option);
    };
    (options || []).forEach(appendOption);
    const normalizedCurrent = normalizeScanOptionKey(currentValue);
    if (currentValue && normalizedCurrent && !normalizedSet.has(normalizedCurrent)) {
      const option = document.createElement('option');
      option.value = currentValue;
      const resolvedId = findScanIdForName(currentValue);
      const labelWithId = formatScanLabelWithId(currentValue, resolvedId);
      option.textContent = `${labelWithId} (current)`;
      select.appendChild(option);
    }
    select.value = currentValue != null ? String(currentValue) : '';
    return select;
  }

  function renderBody(body, data, updateFilterButtonLabel, footer, previousAccordionState) {
    const {
      now = new Date(),
      rows = [],
      filtered = [],
      totalRows = 1,
      statusCounts = { Complete: 0, Queued: 0, Cancelled: 0, Other: 0 },
      bucketLabels = scoreBucketSpecs.map(spec => spec.label),
      scoreAll = makeScoreBuckets(),
      byType = {},
      completedLast24hByType = {},
      totalLast24h = 0,
      avgPerHour12 = 0,
      windowRows = [],
      impactIssuesByType = {},
      domainOptions = [],
      runsInProgress = { runs: [], total: 0 },
      pagesSummary = null
    } = data || {};

    if (pageContext === 'scans') {
      syncPageHealthAvailability(filtered);
      lastRenderedData = data;
    } else {
      lastRenderedData = null;
    }

    const scoreBandOrder = bucketLabels;
    const nowMs = now.getTime();
    const domainHierarchy = buildDomainHierarchy(domainOptions);
    const domainAggregates = aggregateDomains(filtered);
    const pageDataAvailable = !!(pagesSummary && Array.isArray(pagesSummary.filtered));
    const pageFilteredSource = pageDataAvailable ? (pagesSummary.filtered || []) : [];
    const pageRowsQualified = pageFilteredSource.filter(row => {
      if (!row || row.statusKey !== 'Complete') return false;
      const counts = getFilteredPageImpactCounts(row);
      return (counts.critical + counts.serious + counts.moderate + counts.minor) > 0;
    });
    const pageRowsByType = {};
    pageRowsQualified.forEach(row => {
      if (getPageTotal(row) <= 0) return;
      if (!pageRowsByType[row.type]) pageRowsByType[row.type] = [];
      pageRowsByType[row.type].push(row);
    });
    const pageDomainAggregates = pageDataAvailable ? aggregatePageDomains(pageRowsQualified) : new Map();
  const activeImpactKeys = getActivePageImpactKeys();
  const activeImpactSet = new Set(activeImpactKeys);
  const impactFilterLabel = formatPageImpactSelection(activeImpactKeys);
  const activeViewSource = getPageImpactSourceForView();
  const sourceLabel = getPageImpactSourceLabel(activeViewSource);
  const impactHeadingSuffixParts = [];
  if (impactFilterLabel) impactHeadingSuffixParts.push(`Impact: ${impactFilterLabel}`);
  if (sourceLabel) impactHeadingSuffixParts.push(`Source: ${sourceLabel}`);
  const impactHeadingSuffix = impactHeadingSuffixParts.length ? ` (${impactHeadingSuffixParts.join(' | ')})` : '';
  const impactSelectionDescriptor = impactFilterLabel || 'All impacts';
  pageImpactFilterState.headingSuffix = impactHeadingSuffix;
  if (typeof window !== 'undefined') {
    window.impactHeadingSuffix = impactHeadingSuffix;
  }

    const severityChipTemplates = {
      critical: `<span class="a17e98589504 a11y-severity-chip"><div class="c2adf923ed89 e2de49808a35"><span aria-hidden="true" class="Icon Icon--chevron-double-up Icon__up"><svg overflow="visible" preserveAspectRatio="none" viewBox="0 0 24 24" height="24" width="24"><path d="M17.2 11.84a.35.35 0 0 0-.1-.24l-.52-.52a.332.332 0 0 0-.47-.01l-.01.01-4.1 4.1-4.09-4.1a.332.332 0 0 0-.47-.01l-.01.01-.52.52c-.13.13-.14.33-.01.47l.01.01 4.85 4.85c.13.13.33.14.47.01l.01-.01 4.85-4.85c.06-.06.1-.15.1-.24h.01zm0-4a.35.35 0 0 0-.1-.24l-.52-.52a.332.332 0 0 0-.47-.01l-.01.01-4.1 4.1-4.09-4.09a.333.333 0 0 0-.47-.02l-.01.01-.52.53a.32.32 0 0 0-.02.46l.01.01 4.85 4.85c.13.13.33.14.47.01l.01-.01 4.85-4.85c.06-.06.1-.15.1-.24h.02z" fill="currentColor" vector-effect="non-scaling-stroke"></path></svg></span><span class="Offscreen">Critical</span></div> Critical</span>`,
      serious: `<span class="a17e98589504 a11y-severity-chip"><div class="c2adf923ed89 c1d7b29a41e0"><span aria-hidden="true" class="Icon Icon--chevron-up Icon__up"><svg overflow="visible" preserveAspectRatio="none" viewBox="0 0 24 24" height="24" width="24"><path d="M17.2 9.84a.35.35 0 0 0-.1-.24l-.52-.52a.332.332 0 0 0-.47-.01l-.01.01-4.1 4.1-4.09-4.1a.333.333 0 0 0-.47-.02l-.01.01-.52.53c-.13.13-.14.33-.01.47l.01.01 4.85 4.85c.13.13.33.14.47.01l.01-.01 4.85-4.85c.06-.06.1-.15.1-.24h.01z" fill="currentColor" vector-effect="non-scaling-stroke"></path></svg></span><span class="Offscreen">Serious</span></div> Serious</span>`,
      moderate: `<span class="a17e98589504 a11y-severity-chip"><div class="c2adf923ed89 a99bd1117bc5"><span aria-hidden="true" class="Icon Icon--chevron-down Icon__down"><svg overflow="visible" preserveAspectRatio="none" viewBox="0 0 24 24" height="24" width="24"><path d="M17.2 9.84a.35.35 0 0 0-.1-.24l-.52-.52a.332.332 0 0 0-.47-.01l-.01.01-4.1 4.1-4.09-4.1a.333.333 0 0 0-.47-.02l-.01.01-.52.53c-.13.13-.14.33-.01.47l.01.01 4.85 4.85c.13.13.33.14.47.01l.01-.01 4.85-4.85c.06-.06.1-.15.1-.24h.01z" fill="currentColor" vector-effect="non-scaling-stroke"></path></svg></span><span class="Offscreen">Moderate</span></div> Moderate</span>`,
      minor: `<span class="a17e98589504 a11y-severity-chip"><div class="c2adf923ed89 f55e216514d1"><span aria-hidden="true" class="Icon Icon--chevron-double-down Icon__down"><svg overflow="visible" preserveAspectRatio="none" viewBox="0 0 24 24" height="24" width="24"><path d="M17.2 11.84a.35.35 0 0 0-.1-.24l-.52-.52a.332.332 0 0 0-.47-.01l-.01.01-4.1 4.1-4.09-4.1a.332.332 0 0 0-.47-.01l-.01.01-.52.52c-.13.13-.14.33-.01.47l.01.01 4.85 4.85c.13.13.33.14.47.01l.01-.01 4.85-4.85c.06-.06.1-.15.1-.24h.01zm0-4a.35.35 0 0 0-.1-.24l-.52-.52a.332.332 0 0 0-.47-.01l-.01.01-4.1 4.1-4.09-4.09a.333.333 0 0 0-.47-.02l-.01.01-.52.53a.32.32 0 0 0-.02.46l.01.01 4.85 4.85c.13.13.33.14.47.01l.01-.01 4.85-4.85c.06-.06.1-.15.1-.24h.02z" fill="currentColor" vector-effect="non-scaling-stroke"></path></svg></span><span class="Offscreen">Minor</span></div> Minor</span>`
    };

    const createChipFromHtml = html => {
      const template = document.createElement('template');
      template.innerHTML = html.trim();
      return template.content.firstElementChild;
    };

    const createSeverityChip = key => {
      const markup = severityChipTemplates[key];
      if (!markup) return null;
      const node = createChipFromHtml(markup);
      if (node) node.style.pointerEvents = 'none';
      return node;
    };

    const createSourceChip = () => {
      const sourceKey = getPageImpactSourceForView();
      if (sourceKey === 'api' && !isMonitorApiDataReady()) return null;
      const option = pageImpactSourceOptions.find(entry => entry.key === sourceKey);
      if (!option) return null;
      const text = option.shortLabel || option.label || sourceKey;
      const span = document.createElement('span');
      span.className = 'a11y-source-chip';
      span.textContent = text;
      span.setAttribute('aria-label', `Source: ${option.label || text}`);
      span.style.display = 'inline-flex';
      span.style.alignItems = 'center';
      span.style.fontSize = '12px';
      span.style.fontWeight = '600';
      span.style.padding = '2px 10px';
      span.style.borderRadius = '999px';
      span.style.pointerEvents = 'none';
      const palette = sourceKey === 'api'
        ? { bg: '#d1fae5', color: '#065f46' }
        : { bg: '#ecfdf5', color: '#065f46' };
      span.style.background = palette.bg;
      span.style.color = palette.color;
      span.style.border = '1px solid rgba(15,23,42,0.08)';
      return span;
    };

    const createMonitorApiStatusMetaChip = () => {
      if (getPageImpactSourceForView() !== 'api') return null;
      const coverage = getPageImpactApiCoverage();
      if (!coverage.total || coverage.missing <= 0) return null;
      const chip = document.createElement('span');
      chip.className = 'a11y-page-impact-api-chip a11y-page-impact-api-chip--meta';
      chip.style.background = '#fff7ed';
      chip.style.color = '#9a3412';
      chip.style.pointerEvents = 'none';
      chip.style.cursor = 'default';
      chip.dataset.status = 'missing';
      chip.setAttribute('aria-label', `API data missing for ${coverage.missing} of ${coverage.total} scans.`);
      renderMonitorApiChipContent(chip, 'API data • missing', { interactive: false });
      return chip;
    };

    const buildImpactSummaryMeta = () => {
      const chips = [];
      pageImpactFilterOptions.forEach(option => {
        if (activeImpactSet.has(option.key)) {
          const chip = createSeverityChip(option.key);
          if (chip) chips.push(chip);
        }
      });
      const apiStatusChip = createMonitorApiStatusMetaChip();
      if (apiStatusChip) chips.push(apiStatusChip);
      const sourceChip = createSourceChip();
      if (sourceChip) chips.push(sourceChip);
      if (!chips.length) return null;
      const wrap = document.createElement('div');
      wrap.className = 'a11y-impact-meta-chips';
      chips.forEach(chip => wrap.appendChild(chip));
      return wrap;
    };
    const rowLookup = buildRowLookup(rows);
    ensureWasConfigDefaults();
    wasRuntimeContext = { rowLookup };

    closePageImpactFilterPopover({ focusButton: false });
    body.innerHTML = '';
    body.setAttribute('tabindex','0');
    pageImpactFilterState.button = null;
    pageImpactFilterState.summaryEl = null;
    pageImpactFilterState.apiContainer = null;
    pageImpactFilterState.apiStatusEl = null;
    pageImpactFilterState.apiButton = null;
    pageImpactFilterState.apiChip = null;
  pageImpactFilterState.footerChipContainer = null;
  pageImpactFilterState.footerApiChip = null;
  pageImpactFilterState.footerInfoEl = null;
  pageImpactFilterState.footerBaseTimestamp = '';

    const sectionsByTab = {
      status: [],
      score: [],
      issues: [],
      pages: [],
      ranking: [],
      quick: []
    };

    const makeDetails = (title, options = {}) => {
      const details = document.createElement('details');
      details.open = false;
      const summary = document.createElement('summary');
      summary.className = 'a11y-accordion-summary';
      summary.style.display = 'flex';
      summary.style.flexWrap = 'wrap';
      summary.style.alignItems = 'center';
      summary.style.gap = '8px';
      const h2 = document.createElement('h2');
      h2.textContent = title;
      summary.appendChild(h2);
      if (typeof options.appendMeta === 'function') {
        const meta = options.appendMeta();
        if (meta) summary.appendChild(meta);
      }
      details.appendChild(summary);
      return details;
    };

    const pushSection = (tabKey, details) => {
      if (!details) return;
      sectionsByTab[tabKey].push(details);
    };

    const getDomainRowsForEntry = (entry, aggregatesMap) => {
      const sections = entry.type === 'group' ? entry.children : [entry];
      const rows = [];
      sections.forEach(section => {
        const key = section.value || section.label;
        const agg = aggregatesMap.get(key);
        if (agg) rows.push(...agg.rows);
      });
      return rows;
    };

    const buildAverageScoreEntries = groups => {
      return groups
        .map(group => {
          const rows = (group.rows || []).filter(r => Number.isFinite(r.scoreVal));
          if (!rows.length) return null;
          const total = rows.reduce((acc, r) => acc + r.scoreVal, 0);
          return {
            label: group.label,
            avg: total / rows.length,
            count: rows.length,
            rows
          };
        })
        .filter(Boolean)
        .sort((a, b) => {
          if (b.avg !== a.avg) return b.avg - a.avg;
          if (b.count !== a.count) return b.count - a.count;
          return a.label.localeCompare(b.label, undefined, { sensitivity: 'base' });
        });
    };

    const appendAverageScoreSection = (title, groups, contextPrefix) => {
      const details = makeDetails(title, { appendMeta: buildImpactSummaryMeta });
      const entries = buildAverageScoreEntries(groups);
      if (!entries.length) {
        const p = document.createElement('p');
        p.textContent = 'No scans with scores in the current filter set.';
        details.appendChild(p);
      } else {
        const table = document.createElement('table');
        table.className = 'a11y-scan-report-table';
        const thead = document.createElement('thead');
        const hr = document.createElement('tr');
        const groupColumnLabel = /website/i.test(contextPrefix || title) ? 'Website' : 'Domain';
        [groupColumnLabel,'Average score','Scan count'].forEach(t => {
          const th = document.createElement('th');
          th.textContent = t;
          th.setAttribute('scope','col');
          hr.appendChild(th);
        });
        thead.appendChild(hr);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');
        entries.forEach(entry => {
          const tr = document.createElement('tr');
          const labelCell = document.createElement('th');
          labelCell.setAttribute('scope','row');
          labelCell.textContent = entry.label;
          tr.appendChild(labelCell);

          const avgCell = document.createElement('td');
          avgCell.textContent = formatScoreValue(entry.avg, '—');
          tr.appendChild(avgCell);

          const countCell = document.createElement('td');
          // Create a set of scan identifiers (URLs or names) instead of row objects
          const scanIdentifiers = new Set(entry.rows.map(r => r.url || r.name));
          const btn = makeCountButton(
            entry.count,
            `${entry.label} - ${contextPrefix}`,
            r => scanIdentifiers.has(r.url || r.name),
            { sortMode: 'scoreThenName' }
          );
          countCell.appendChild(btn);
          tr.appendChild(countCell);

          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        appendTableWithDownload(details, table, { filenameBase: contextPrefix || title.toLowerCase() });

        // Add "Download all scans" button exporting every scan across all groups with contextual column (Domain/Website)
        const toolbar = document.createElement('div');
        toolbar.className = 'a11y-table-toolbar';
        const dlBtn = document.createElement('button');
        dlBtn.type = 'button';
        dlBtn.className = 'a11y-table-download-btn';
        dlBtn.textContent = 'Download all scans';
        dlBtn.addEventListener('click', async () => {
          try {
            // Refresh to get current filtered rows
            const latest = await refreshMainView({ preserveState: true });
            const sourceRows = latest.filtered || [];
            // Build a set of identifiers for rows included in entries to avoid domain mismatch
            const identifiersByDomain = new Map();
            entries.forEach(entry => {
              const ids = new Set(entry.rows.map(r => r.url || r.name));
              identifiersByDomain.set(entry.label, ids);
            });
            // Collect scans and attach Domain column (group label)
            const all = [];
            sourceRows.forEach(r => {
              // Determine which group (domain) this row belongs to based on entries
              let domainLabel = null;
              for (const [label, ids] of identifiersByDomain.entries()) {
                if (ids.has(r.url || r.name)) {
                  domainLabel = label;
                  break;
                }
              }
              // Only include rows that are part of the grouped entries
              if (!domainLabel) return;
              all.push({
                ContextGroup: domainLabel,
                name: r.name || '',
                type: r.type || '',
                domain: r.domain || '',
                status: r.statusText || '',
                score: Number.isFinite(r.scoreVal) ? r.scoreVal : '',
                critical: r.crit != null ? r.crit : '',
                serious: r.serious != null ? r.serious : '',
                moderate: r.moderate != null ? r.moderate : '',
                minor: r.minor != null ? r.minor : '',
                total: r.total != null ? r.total : '',
                pages: r.pages != null ? r.pages : '',
                lastRun: r.lastRun ? r.lastRun.toISOString() : '',
                url: r.url || ''
              });
            });

            const groupColumnLabelCsv = /website/i.test(contextPrefix || title) ? 'Website' : 'Domain';
            downloadObjectCsv(all, [
              { key: 'ContextGroup', label: groupColumnLabelCsv },
              { key: 'name', label: 'Scan Name' },
              { key: 'type', label: 'Type' },
              { key: 'domain', label: 'Domain (raw)' },
              { key: 'status', label: 'Status' },
              { key: 'score', label: 'Score' },
              { key: 'critical', label: 'Critical' },
              { key: 'serious', label: 'Serious' },
              { key: 'moderate', label: 'Moderate' },
              { key: 'minor', label: 'Minor' },
              { key: 'total', label: 'Total Issues' },
              { key: 'pages', label: 'Pages' },
              { key: 'lastRun', label: 'Last Run' },
              { key: 'url', label: 'URL' }
            ], `${sanitizeFilename(contextPrefix || title)}-all-scans`);
          } catch (err) {
            console.error(err);
            alert('Unable to download all scans.');
          }
        });
        toolbar.appendChild(dlBtn);
        details.appendChild(toolbar);
      }
      pushSection('score', details);
    };

    // Scan Status summary
    {
      const details = makeDetails('Scan Status');
      const ul = document.createElement('ul');
      const preferredOrder = ['Complete','Queued','Cancelled','Other'];
      const statuses = Array.from(new Set([...preferredOrder, ...Object.keys(statusCounts)]));
      statuses.forEach(k => {
        const c = statusCounts[k] || 0;
        if (!c) return;
        const li = document.createElement('li');
        const label = document.createElement('span');
        label.textContent = `${k}: `;
        li.appendChild(label);
        const btn = makeCountButton(
          c,
          `${k} - Scan Status`,
          r => r.statusKey === k,
          { sortMode: 'scoreThenName' }
        );
        li.appendChild(btn);
        const pct = document.createElement('span');
        pct.textContent = ` (${pctOf(c, totalRows)})`;
        li.appendChild(pct);
        ul.appendChild(li);
      });
      const runsCount = runsInProgress?.total || (runsInProgress?.runs?.length || 0);
      if (runsCount) {
        const li = document.createElement('li');
        const label = document.createElement('span');
        label.textContent = 'Scan runs in progress: ';
        li.appendChild(label);
        const btn = makeCountButton(
          runsCount,
          'Scan runs in progress',
          null,
          {
            getRows: data => (data.runsInProgress?.runs || []).slice(),
            sortMode: 'nameOnly',
            openDialog: rows => openRunsInProgressDialog('Scan runs in progress', rows, () => refreshMainView({ preserveState: true }))
          }
        );
        li.appendChild(btn);
        ul.appendChild(li);
      }
      details.appendChild(ul);
      pushSection('status', details);
    }

    // Score summary (all scans)
    {
      const details = makeDetails('Score summary', { appendMeta: buildImpactSummaryMeta });
      const total = Object.values(scoreAll).reduce((a,b)=>a+b,0);
      const summaryRows = renderScoreTable(
        details,
        scoreAll,
        total,
        scoreBandOrder,
        'Higher scores are better. Bar width shows share of scans in each band; colors run from green (100%) to red (<50%).',
        (r, band) => r.scoreBucket === band,
        'Score summary',
        { filenameBase: 'score-summary-bands', groupLabel: 'All scans' }
      );
      if (summaryRows.length) {
        appendBandDownloadButton(details, summaryRows, {
          filenameBase: 'score-summary-bands-all',
          bandOrder: scoreBandOrder,
          rowFilter: (r, band) => r.scoreBucket === band,
          groupLabel: 'All scans',
          columns: [
            { key: 'group', label: 'Group' },
            { key: 'band', label: 'Band' },
            { key: 'count', label: 'Scans' },
            { key: 'percent', label: 'Percent' }
          ]
        });
      }
      pushSection('score', details);
    }

    // Score summary by type
    {
      const details = makeDetails('Score by scan type', { appendMeta: buildImpactSummaryMeta });
      const typeKeys = Object.keys(byType).sort();
      if (!typeKeys.length) {
        const p = document.createElement('p');
        p.textContent = 'No scans with scores in the current filter set.';
        details.appendChild(p);
      } else {
        const bandDownloadRows = [];
        const allTypeBandFilters = []; // Store filters for each type-band combination
        typeKeys.forEach(type => {
          const h3 = document.createElement('h3');
          h3.textContent = type;
          details.appendChild(h3);
          const total = Object.values(byType[type]).reduce((a,b)=>a+b,0);
          const rows = renderScoreTable(
            details,
            byType[type],
            total,
            scoreBandOrder,
            `Score distribution for ${type}.`,
            (r, band) => r.type === type && r.scoreBucket === band,
            `Score summary by type - ${type}`,
            { filenameBase: `score-bands-${sanitizeFilename(type)}`, groupLabel: type }
          );
          rows.forEach(row => {
            bandDownloadRows.push(row);
            // Store the type and band for later filtering
            allTypeBandFilters.push({ type: type, band: row.band });
          });
        });
        if (bandDownloadRows.length) {
          appendBandDownloadButton(details, bandDownloadRows, {
            filenameBase: 'score-bands-by-type',
            bandOrder: allTypeBandFilters,
            rowFilter: (r, typeBand) => r.type === typeBand.type && r.scoreBucket === typeBand.band,
            groupLabel: 'By Type',
            columns: [
              { key: 'group', label: 'Scan type' },
              { key: 'band', label: 'Band' },
              { key: 'count', label: 'Scans' },
              { key: 'percent', label: 'Percent' }
            ]
          });
        }
      }
      pushSection('score', details);
    }

    {
      const domainAvgGroups = domainHierarchy.map(entry => ({
        label: entry.label,
        rows: getDomainRowsForEntry(entry, domainAggregates)
      }));
      appendAverageScoreSection('Avg Score by domain', domainAvgGroups, 'Avg Score by domain');
    }

    {
      // Group by website: remove trailing scan type tokens (Desktop/Mobile/PDF) from the name,
      // and use the remaining full prefix as the website label.
      const scanTypes = new Set(['Desktop','Mobile','PDF']);
      const websiteMap = new Map();
      filtered.forEach(r => {
        const raw = (r.name || '').trim();
        let tokens = raw.split(' - ').map(s => s.trim()).filter(Boolean);
        if (tokens.length === 0) tokens = [(r.domain || 'Other')];
        // If the last token is a known scan type, drop it
        if (tokens.length > 1 && scanTypes.has(tokens[tokens.length - 1])) {
          tokens = tokens.slice(0, -1);
        }
        const key = tokens.join(' - ') || (r.domain || 'Other');
        if (!websiteMap.has(key)) websiteMap.set(key, []);
        websiteMap.get(key).push(r);
      });
      const websiteGroups = Array.from(websiteMap.entries()).map(([label, rows]) => ({ label, rows }));
      appendAverageScoreSection('Avg Score by website', websiteGroups, 'Avg Score by website');
    }

    // Issue impact bands
    {
  const impactBandOrder = impactIssueBandOrder;
  const impactMap = impactIssuesByType;
  const details = makeDetails('Issue impact bands', { appendMeta: buildImpactSummaryMeta });
  const issueBandColumnLabel = `Band (Impacts: ${impactSelectionDescriptor})`;
      const types = Object.keys(impactMap).sort();
      const bandDownloadRows = [];
      if (!types.length) {
        const p = document.createElement('p');
        p.textContent = 'No Complete scans with selected impact counts in the current filter set.';
        details.appendChild(p);
      } else {
        types.forEach(type => {
          const bands = impactMap[type] || {};
          const total = Object.values(bands).reduce((a,b)=>a+b,0);
          const h3 = document.createElement('h3');
          h3.textContent = type;
          details.appendChild(h3);
          if (!total) {
            const p = document.createElement('p');
            p.textContent = 'No qualifying scans for this type.';
            details.appendChild(p);
            return;
          }
          const table = document.createElement('table');
          table.className = 'a11y-scan-report-table';
          const thead = document.createElement('thead');
          const hr = document.createElement('tr');
          [issueBandColumnLabel,'Scans','Percent'].forEach(t => {
            const th = document.createElement('th');
            th.textContent = t;
            th.setAttribute('scope','col');
            hr.appendChild(th);
          });
          thead.appendChild(hr);
          table.appendChild(thead);
          const tbody = document.createElement('tbody');
          impactBandOrder.forEach(band => {
            const count = bands[band] || 0;
            if (!count) return;
            const pctNum = (count / total) * 100;
            const pctText = pctNum.toFixed(1) + '%';
            const tr = document.createElement('tr');
            const tdBand = document.createElement('th');
            tdBand.setAttribute('scope','row');
            const bandLabel = `${band} issues`;
            tdBand.textContent = bandLabel;
            tr.appendChild(tdBand);
            const tdScans = document.createElement('td');
            const context = `${band} - Issue impact bands - ${type}`;
            const btn = makeCountButton(
              count,
              context,
              row =>
                row.type === type &&
                row.statusKey === 'Complete' &&
                Number.isFinite(row.scoreVal) &&
                getImpactBandIssues(getIssueTotal(row)) === band,
              { sortMode: 'nameOnly', context: 'impact' }
            );
            tdScans.appendChild(btn);
            tr.appendChild(tdScans);
            const tdPct = document.createElement('td');
            const wrap = document.createElement('div');
            wrap.className = 'a11y-impact-bar-wrap';
            const bar = document.createElement('div');
            bar.className = 'a11y-impact-bar';
            bar.style.width = pctNum.toFixed(1) + '%';
            bar.style.backgroundColor = getSeverityColorForBand(band, impactBandOrder);
            const span = document.createElement('span');
            span.textContent = pctText;
            wrap.appendChild(bar);
            wrap.appendChild(span);
            tdPct.appendChild(wrap);
            tr.appendChild(tdPct);
            tbody.appendChild(tr);

            bandDownloadRows.push({
              group: type,
              band: bandLabel,
              count,
              percent: pctNum.toFixed(1)
            });
          });
          table.appendChild(tbody);
          appendTableWithDownload(details, table, { filenameBase: `issue-impact-${type}` });
        });
        const note = document.createElement('p');
        note.style.fontSize = '11px';
        note.textContent = 'Note: Impact bands include only Complete scans with Critical + Serious values and valid percentage scores. Queued and Cancelled scans are excluded.';
        details.appendChild(note);
        
        // Create filters for all type-band combinations
        const allTypeBandFilters = [];
        types.forEach(type => {
          impactBandOrder.forEach(band => {
            const bands = impactMap[type] || {};
            const count = bands[band] || 0;
            if (count > 0) {
              allTypeBandFilters.push({ type: type, band: band });
            }
          });
        });
        
        appendBandDownloadButton(details, bandDownloadRows, {
          filenameBase: 'issue-impact-bands',
          bandOrder: allTypeBandFilters,
          rowFilter: (row, typeBand) =>
            row.type === typeBand.type &&
            row.statusKey === 'Complete' &&
            Number.isFinite(row.scoreVal) &&
            getImpactBandIssues(getIssueTotal(row)) === typeBand.band,
          groupLabel: 'Issue Impact',
          columns: [
            { key: 'group', label: 'Scan type' },
            { key: 'band', label: issueBandColumnLabel },
            { key: 'count', label: 'Scans' },
            { key: 'percent', label: 'Percent' }
          ]
        });
      }
      pushSection('issues', details);
    }

    // Critical + Serious counts by type
    {
  const details = makeDetails('Scan Type - Issue counts', { appendMeta: buildImpactSummaryMeta });
      const grouped = {};
      filtered
        .filter(r => r.statusKey === 'Complete' && (typeof r.crit === 'number' || typeof r.serious === 'number' || typeof r.total === 'number'))
        .forEach(r => {
          if (!grouped[r.type]) grouped[r.type] = [];
          grouped[r.type].push(r);
        });
      const types = Object.keys(grouped).sort();
      if (!types.length) {
        const p = document.createElement('p');
        p.textContent = 'No Complete scans with Critical or Serious counts in the current filter set.';
        details.appendChild(p);
      } else {
        let hasTable = false;
        types.forEach(type => {
          const scans = sortScans(grouped[type], 'critSerDesc');
          if (!scans.length) return;
          const h3 = document.createElement('h3');
          h3.textContent = type;
          details.appendChild(h3);
          const table = buildScanMetricsTable(scans, { includeSumRow: false });
          appendTableWithDownload(details, table, { filenameBase: `critical-serious-${sanitizeFilename(type)}` });
          hasTable = true;
        });
        if (hasTable) {
          appendMonitorApiFootnote(details);
        }
      }
      pushSection('issues', details);
    }

    // Critical + Serious counts by domain (per scan rows + totals)
    {
  const details = makeDetails('Domain - Issue counts', { appendMeta: buildImpactSummaryMeta });
      if (!domainHierarchy.length) {
        const p = document.createElement('p');
        p.textContent = 'No domain information available.';
        details.appendChild(p);
      } else {
        let hasDomainData = false;
        let hasTable = false;
        domainHierarchy.forEach(entry => {
          const heading = document.createElement('h3');
          heading.textContent = entry.label;
          details.appendChild(heading);
          const sections = entry.type === 'group' ? entry.children : [entry];
          const scans = [];
          sections.forEach(child => {
            const agg = domainAggregates.get(child.value || child.label);
            if (agg) {
              hasDomainData = true;
              scans.push(...agg.rows);
            }
          });
          if (!scans.length) {
            const p = document.createElement('p');
            p.textContent = 'No Complete scans with Critical or Serious counts for this domain.';
            details.appendChild(p);
            return;
          }
          const sorted = sortScans(scans, 'critSerDesc');
          const table = buildScanMetricsTable(sorted, { includeSumRow: true });
          appendTableWithDownload(details, table, { filenameBase: `critical-serious-${sanitizeFilename(entry.label)}` });
          hasTable = true;
        });
        if (!hasDomainData) {
          const p = document.createElement('p');
          p.textContent = 'No Complete scans with Critical or Serious counts for any domain in the current filter set.';
          details.appendChild(p);
        } else if (hasTable) {
          appendMonitorApiFootnote(details);
        }
      }
      pushSection('issues', details);
    }

  if (pageContext === 'scans') {
    pushSection('quick', buildWasSection(rowLookup));
    pushSection('quick', buildPageHealthSection({ data }));
  } else if (pageContext === 'issues') {
    [buildAssignIssuesSection(), buildIgnoreIssuesSection(), buildMarkIssuesSection()].forEach(section => {
      if (section) sectionsByTab.quick.push(section);
    });
  } else if (pageContext === 'pages') {
    const copySection = buildCopyPageUrlsSection();
    if (copySection) pushSection('quick', copySection);
    const pdfSection = buildFindPdfsSection();
    if (pdfSection) pushSection('quick', pdfSection);
    const pdfMatchSection = buildMatchPdfFilesSection();
    if (pdfMatchSection) pushSection('quick', pdfMatchSection);
  }

    // Pages with issues tab sections

    // Page impact bands
    {
      const bandsHeading = 'Page impact bands';
      const details = makeDetails(bandsHeading, { appendMeta: buildImpactSummaryMeta });
      const pageBandColumnLabel = `Band (Pages • Impacts: ${impactSelectionDescriptor})`;
      const types = pageDataAvailable ? Object.keys(pageRowsByType).sort() : [];
      const bandDownloadRows = [];
      if (!pageDataAvailable || !types.length) {
        const p = document.createElement('p');
        p.textContent = 'No Complete scans with pages in the selected impact filter.';
        details.appendChild(p);
      } else {
        types.forEach(type => {
          const rowsForType = (pageRowsByType[type] || []).filter(row => getPageTotal(row) > 0);
          if (!rowsForType.length) return;
          const rowsByBand = new Map();
          rowsForType.forEach(row => {
            const bandLabel = getImpactBandPages(getPageTotal(row));
            if (!rowsByBand.has(bandLabel)) rowsByBand.set(bandLabel, []);
            rowsByBand.get(bandLabel).push(row);
          });
          const total = rowsForType.length;
          const h3 = document.createElement('h3');
          h3.textContent = type;
          details.appendChild(h3);

          const table = document.createElement('table');
          table.className = 'a11y-scan-report-table';
          const thead = document.createElement('thead');
          const hr = document.createElement('tr');
          [pageBandColumnLabel,'Scans','Percent'].forEach(t => {
            const th = document.createElement('th');
            th.textContent = t;
            th.setAttribute('scope','col');
            hr.appendChild(th);
          });
          thead.appendChild(hr);
          table.appendChild(thead);

          const tbody = document.createElement('tbody');
          impactPageBandOrder.forEach(band => {
            const matchingRows = rowsByBand.get(band) || [];
            const count = matchingRows.length;
            if (!count) return;
            const pctNum = (count / total) * 100;
            const pctText = pctNum.toFixed(1) + '%';
            const tr = document.createElement('tr');
            const tdBand = document.createElement('th');
            tdBand.setAttribute('scope','row');
            tdBand.textContent = band;
            tr.appendChild(tdBand);
            const tdScans = document.createElement('td');
            const context = `${band} - Page impact bands - ${type}`;
            const btn = makeCountButton(
              count,
              context,
              null,
              {
                getRows: latestData => {
                  const source = (latestData.pagesSummary?.filtered || []);
                  return source.filter(row =>
                    row.type === type &&
                    row.statusKey === 'Complete' &&
                    getPageTotal(row) > 0 &&
                    getImpactBandPages(getPageTotal(row)) === band
                  );
                },
                sortMode: 'nameOnly',
                    context: 'impact',
                    dialogOptions: { mode: 'pages', filenameBase: 'page-impact-drilldown' }
              }
            );
            tdScans.appendChild(btn);
            tr.appendChild(tdScans);
            const tdPct = document.createElement('td');
            const wrap = document.createElement('div');
            wrap.className = 'a11y-impact-bar-wrap';
            const bar = document.createElement('div');
            bar.className = 'a11y-impact-bar';
            bar.style.width = pctNum.toFixed(1) + '%';
            bar.style.backgroundColor = getSeverityColorForBand(band, impactPageBandOrder);
            const span = document.createElement('span');
            span.textContent = pctText;
            wrap.appendChild(bar);
            wrap.appendChild(span);
            tdPct.appendChild(wrap);
            tr.appendChild(tdPct);
            tbody.appendChild(tr);

            bandDownloadRows.push({
              group: type,
              band,
              count,
              percent: pctNum.toFixed(1)
            });
          });
          table.appendChild(tbody);
          appendTableWithDownload(details, table, { filenameBase: `page-impact-${type}` });
        });
        const note = document.createElement('p');
        note.style.fontSize = '11px';
        note.textContent = `Note: Page impact bands include only Complete scans with available pages for the selected impacts (${impactFilterLabel}). Queued and Cancelled scans are excluded.`;
        details.appendChild(note);
        
        // Create filters for all type-band combinations
        const allTypeBandFilters = [];
        types.forEach(type => {
          impactPageBandOrder.forEach(band => {
            const rowsForType = (pageRowsByType[type] || []).filter(row => getPageTotal(row) > 0);
            const matchingRows = rowsForType.filter(row => getImpactBandPages(getPageTotal(row)) === band);
            if (matchingRows.length > 0) {
              allTypeBandFilters.push({ type: type, band: band });
            }
          });
        });
        
        appendBandDownloadButton(details, bandDownloadRows, {
          filenameBase: 'page-impact-bands',
          bandOrder: allTypeBandFilters,
          rowFilter: (row, typeBand) =>
            row.type === typeBand.type &&
            row.statusKey === 'Complete' &&
            getPageTotal(row) > 0 &&
            getImpactBandPages(getPageTotal(row)) === typeBand.band,
          groupLabel: 'Page Impact',
          metricsType: 'pages',
          columns: [
            { key: 'group', label: 'Scan type' },
            { key: 'band', label: pageBandColumnLabel },
            { key: 'count', label: 'Scans' },
            { key: 'percent', label: 'Percent' }
          ]
        });
      }
      pushSection('pages', details);
    }

    // Scan Type - Pages with issues (selected impacts)
    {
      const details = makeDetails('Scan Type - Pages with issues', { appendMeta: buildImpactSummaryMeta });
      if (!pageRowsQualified.length) {
        const p = document.createElement('p');
        p.textContent = 'No Complete scans with pages in the selected impact filter.';
        details.appendChild(p);
      } else {
        const grouped = {};
        pageRowsQualified.forEach(row => {
          if (!grouped[row.type]) grouped[row.type] = [];
          grouped[row.type].push(row);
        });
        Object.keys(grouped).sort().forEach(type => {
          const rowsList = grouped[type]
            .slice()
            .sort((a, b) => getPageTotal(b) - getPageTotal(a));
          const h3 = document.createElement('h3');
          h3.textContent = type;
          details.appendChild(h3);
          const table = buildPagesMetricsTable(rowsList, { includeSumRow: true });
          appendTableWithDownload(details, table, { filenameBase: `pages-impact-${sanitizeFilename(type)}` });
        });
      }
      pushSection('pages', details);
    }

    // Domain - Pages with issues (selected impacts)
    {
      const details = makeDetails('Domain - Pages with issues', { appendMeta: buildImpactSummaryMeta });
      if (!pageDataAvailable || !domainHierarchy.length || !pageRowsQualified.length) {
        const p = document.createElement('p');
        p.textContent = 'No domain information available for the selected impact filter.';
        details.appendChild(p);
      } else {
        let hasPageDomain = false;
        domainHierarchy.forEach(entry => {
          const rowsForDomain = getDomainRowsForEntry(entry, pageDomainAggregates);
          const heading = document.createElement('h3');
          heading.textContent = entry.label;
          details.appendChild(heading);
          if (!rowsForDomain.length) {
            const p = document.createElement('p');
            p.textContent = 'No Complete scans with pages for this domain in the selected impact filter.';
            details.appendChild(p);
            return;
          }
          hasPageDomain = true;
          const sorted = rowsForDomain
            .slice()
            .sort((a, b) => getPageTotal(b) - getPageTotal(a));
          const table = buildPagesMetricsTable(sorted, { includeSumRow: true });
          appendTableWithDownload(details, table, { filenameBase: `pages-impact-${sanitizeFilename(entry.label)}` });
        });
        if (!hasPageDomain) {
          const p = document.createElement('p');
          p.textContent = 'No Complete scans with pages for any domain in the selected impact filter.';
          details.appendChild(p);
        }
      }
      pushSection('pages', details);
    }

    // Recently completed scans
    {
      const details = makeDetails('Recently completed scans');
      if (!windowRows.length) {
        const p = document.createElement('p');
        p.textContent = 'No completed scans with parseable Last Run timestamps in the current filter set.';
        details.appendChild(p);
      } else {
        const table = document.createElement('table');
        table.className = 'a11y-scan-report-table';
        const thead = document.createElement('thead');
        const hr = document.createElement('tr');
        ['Time window','Completed scans'].forEach(t => {
          const th = document.createElement('th');
          th.textContent = t;
          th.setAttribute('scope','col');
          hr.appendChild(th);
        });
        thead.appendChild(hr);
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        windowRows.forEach(w => {
          const tr = document.createElement('tr');
          const t1 = document.createElement('th');
          t1.setAttribute('scope','row');
          t1.textContent = w.label;
          const t2 = document.createElement('td');
          const btn = makeCountButton(
            w.count,
            `${w.label} - Recently completed scans`,
            row => {
              if (row.statusKey !== 'Complete' || !row.lastRun) return false;
              const diff = nowMs - row.lastRun.getTime();
              if (w.minMs !== undefined) {
                // Range-based window (e.g., "1-2 months")
                return diff > w.minMs && diff <= w.windowMs;
              } else {
                // "Last X" window (e.g., "Last 24 hours")
                return diff >= 0 && diff <= (w.windowMs || 0);
              }
            },
            { sortMode: 'recent' }
          );
          t2.appendChild(btn);
          tr.appendChild(t1);
          tr.appendChild(t2);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        appendTableWithDownload(details, table, { filenameBase: 'recently-completed' });
      }
      pushSection('status', details);
    }

    // Completed in last 24 hours
    {
      const details = makeDetails('Completed in the last 24 hours');
      const wrap = document.createElement('div');
      if (!totalLast24h) {
        const p = document.createElement('p');
        p.textContent = 'No completed scans within the last 24 hours in the current filter set.';
        wrap.appendChild(p);
      } else {
        const p1 = document.createElement('p');
        p1.textContent = `Total completed (last 24h): ${totalLast24h}`;
        wrap.appendChild(p1);
        const p4 = document.createElement('p');
        p4.textContent = `Average completions per hour over the last 12 hours: ${avgPerHour12.toFixed(2)}`;
        wrap.appendChild(p4);
        const table = document.createElement('table');
        table.className = 'a11y-scan-report-table';
        const thead = document.createElement('thead');
        const hr = document.createElement('tr');
        ['Type','Completed (24h)','Percent of 24h total'].forEach(t => {
          const th = document.createElement('th');
          th.textContent = t;
          th.setAttribute('scope','col');
          hr.appendChild(th);
        });
        thead.appendChild(hr);
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        Object.keys(completedLast24hByType).sort().forEach(type => {
          const c = completedLast24hByType[type];
          const tr = document.createElement('tr');
          const tdT = document.createElement('th');
          tdT.setAttribute('scope','row');
          tdT.textContent = type;
          const tdC = document.createElement('td');
          const btn = makeCountButton(
            c,
            `${type} - Completed last 24 hours`,
            row =>
              row.type === type &&
              row.statusKey === 'Complete' &&
              row.lastRun &&
              (nowMs - row.lastRun.getTime()) <= msPerDay,
            { sortMode: 'scoreThenName' }
          );
          tdC.appendChild(btn);
          const remainder = document.createTextNode(`/${totalLast24h}`);
          tdC.appendChild(remainder);
          const tdP = document.createElement('td');
          tdP.textContent = pctOf(c, totalLast24h);
          tr.appendChild(tdT);
          tr.appendChild(tdC);
          tr.appendChild(tdP);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        appendTableWithDownload(wrap, table, { filenameBase: 'completed-last-24h' });
      }
      details.appendChild(wrap);
      pushSection('status', details);
    }

    const completeRows = filtered.filter(r => r.statusKey === 'Complete');

    function aggregateRows(rows, label) {
      if (!rows || !rows.length) return null;
      let crit = 0;
      let serious = 0;
      let moderate = 0;
      let minor = 0;
      let moderateComplete = true;
      let minorComplete = true;
      let totalIssues = 0;
      let scoreSum = 0;
      let scoreCount = 0;
      rows.forEach(row => {
        crit += getRowCritical(row);
        serious += getRowSerious(row);
        totalIssues += getRowTotalIssues(row);
        const counts = getIssueImpactCounts(row);
        if (hasIssueImpactValue(row, 'moderate')) {
          moderate += Math.max(0, coerceNumber(counts.moderate, 0));
        } else {
          moderateComplete = false;
        }
        if (hasIssueImpactValue(row, 'minor')) {
          minor += Math.max(0, coerceNumber(counts.minor, 0));
        } else {
          minorComplete = false;
        }
        if (Number.isFinite(row.scoreVal)) {
          scoreSum += row.scoreVal;
          scoreCount += 1;
        }
      });
      const totalCs = crit + serious;
      const avgScore = scoreCount ? scoreSum / scoreCount : null;
      return {
        label,
        name: label,
        crit,
        serious,
        moderate: moderateComplete ? moderate : null,
        minor: minorComplete ? minor : null,
        totalCs,
        totalIssues,
        total: totalIssues,
        avgScore,
        scoreVal: avgScore,
        rows: rows.slice()
      };
    }

    function buildRankingEntries(mode) {
      const entries = [];
      if (mode === 'domain') {
        domainHierarchy.forEach(entry => {
          const sections = entry.type === 'group' ? entry.children : [entry];
          const rows = [];
          sections.forEach(child => {
            const agg = domainAggregates.get(child.value || child.label);
            if (agg) rows.push(...agg.rows);
          });
          const result = aggregateRows(rows, entry.label);
          if (result) entries.push(result);
        });
      } else if (mode === 'website') {
        domainAggregates.forEach(agg => {
          const result = aggregateRows(agg.rows, agg.domain);
          if (result) entries.push(result);
        });
      }
      return entries;
    }

    function buildRankingDetails(mode) {
      if (mode === 'type') {
        return buildRankingByTypeDetails();
      }
      const modeLabel =
        mode === 'domain' ? 'Ranking by domain' :
        mode === 'website' ? 'Ranking by website' :
        'Ranking by type';
      const columnLabel =
        mode === 'domain' ? 'Domain' :
        mode === 'website' ? 'Website' :
        'Type';
  const details = makeDetails(modeLabel, { appendMeta: buildImpactSummaryMeta });
      const entries = buildRankingEntries(mode);
      if (!entries.length) {
        const p = document.createElement('p');
        p.textContent = 'No ranking data available for the current selection.';
        details.appendChild(p);
        return details;
      }
      const rankingCriteria = getRankingCriteria({ includeFallback: true });
      entries.sort((a, b) => compareByRankingCriteria(a, b, rankingCriteria));
      let lastRankSignature = null;
      let lastRank = 0;
      entries.forEach((entry, idx) => {
        const signature = buildRankingSignature(entry, rankingCriteria);
        if (signature !== lastRankSignature) {
          lastRank = idx + 1;
          lastRankSignature = signature;
        }
        entry.rank = lastRank;
      });
      const table = document.createElement('table');
      table.className = 'a11y-scan-report-table';
      const thead = document.createElement('thead');
      const hr = document.createElement('tr');
      ['Rank', columnLabel, 'Score', 'Critical', 'Serious', 'Moderate*', 'Minor*', 'Total Critical + Serious', 'Total of all issues'].forEach(t => {
        const th = document.createElement('th');
        th.textContent = t;
        th.setAttribute('scope','col');
        hr.appendChild(th);
      });
      thead.appendChild(hr);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      entries.forEach(entry => {
        const tr = document.createElement('tr');
        const rankCell = document.createElement('th');
        rankCell.setAttribute('scope','row');
        rankCell.textContent = String(entry.rank);
        tr.appendChild(rankCell);
        const labelCell = document.createElement('td');
        if (mode === 'domain' || mode === 'website') {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'a11y-link-button';
          btn.setAttribute('role','button');
          btn.textContent = entry.label;
          btn.addEventListener('click', () => {
            const sortedRows = sortScans(entry.rows.slice(), 'scoreThenName');
            openScansListDialog(
              `${entry.label} - ${modeLabel}`,
              sortedRows,
              () => refreshMainView({ preserveState: true })
            );
          });
          labelCell.appendChild(btn);
        } else {
          labelCell.textContent = entry.label;
        }
        tr.appendChild(labelCell);
        const scoreCell = document.createElement('td');
        scoreCell.textContent = formatScoreValue(entry.avgScore);
        tr.appendChild(scoreCell);
        const critCell = document.createElement('td');
        critCell.textContent = String(entry.crit);
        tr.appendChild(critCell);
        const seriousCell = document.createElement('td');
        seriousCell.textContent = String(entry.serious);
        tr.appendChild(seriousCell);
  const moderateCell = document.createElement('td');
  moderateCell.textContent = Number.isFinite(entry.moderate) ? String(entry.moderate) : '-';
  tr.appendChild(moderateCell);
  const minorCell = document.createElement('td');
  minorCell.textContent = Number.isFinite(entry.minor) ? String(entry.minor) : '-';
  tr.appendChild(minorCell);
        const csCell = document.createElement('td');
        csCell.textContent = String(entry.totalCs);
        tr.appendChild(csCell);
        const totalCell = document.createElement('td');
        totalCell.textContent = String(entry.totalIssues);
        tr.appendChild(totalCell);
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      appendTableWithDownload(details, table, { filenameBase: `${mode}-ranking` });
      appendMonitorApiFootnote(details);
      return details;
    }

    function compareRankingRows(a, b) {
      return compareByRankingCriteria(a, b);
    }

    function rankScans(rows) {
      const rankingCriteria = getRankingCriteria({ includeFallback: true });
      const sorted = rows.slice().sort((a, b) => compareByRankingCriteria(a, b, rankingCriteria));
      let lastSignature = null;
      let lastRank = 0;
      return sorted.map((row, idx) => {
        const signature = buildRankingSignature(row, rankingCriteria);
        if (signature !== lastSignature) {
          lastRank = idx + 1;
          lastSignature = signature;
        }
        return { rank: lastRank, row };
      });
    }

    function buildTypeRankingTable(rankedRows) {
      const table = document.createElement('table');
      table.className = 'a11y-scan-report-table';
      const thead = document.createElement('thead');
      const hr = document.createElement('tr');
      ['Rank','Scan','Score','Critical','Serious','Moderate*','Minor*','Total Critical + Serious','Total of all issues'].forEach(t => {
        const th = document.createElement('th');
        th.textContent = t;
        th.setAttribute('scope','col');
        hr.appendChild(th);
      });
      thead.appendChild(hr);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      rankedRows.forEach(({ rank, row }) => {
        const tr = document.createElement('tr');
        const rankCell = document.createElement('th');
        rankCell.setAttribute('scope','row');
        rankCell.textContent = String(rank);
        tr.appendChild(rankCell);

        const nameCell = document.createElement('td');
        nameCell.appendChild(createScanLink(row));
        tr.appendChild(nameCell);

        const scoreCell = document.createElement('td');
        scoreCell.textContent = formatScoreValue(row.scoreVal, row.scoreText || '—');
        tr.appendChild(scoreCell);

        const critCell = document.createElement('td');
        critCell.textContent = String(getRowCritical(row));
        tr.appendChild(critCell);

        const seriousCell = document.createElement('td');
        seriousCell.textContent = String(getRowSerious(row));
        tr.appendChild(seriousCell);

        const moderateCell = document.createElement('td');
        const issueCounts = getIssueImpactCounts(row);
        const formatOptionalIssue = key => {
          if (!hasIssueImpactValue(row, key)) return '-';
          return String(Math.max(0, coerceNumber(issueCounts[key], 0)));
        };
        moderateCell.textContent = formatOptionalIssue('moderate');
        tr.appendChild(moderateCell);

        const minorCell = document.createElement('td');
        minorCell.textContent = formatOptionalIssue('minor');
        tr.appendChild(minorCell);

        const csCell = document.createElement('td');
        csCell.textContent = String(getRowCritical(row) + getRowSerious(row));
        tr.appendChild(csCell);

        const totalCell = document.createElement('td');
        totalCell.textContent = String(getRowTotalIssues(row));
        tr.appendChild(totalCell);

        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      return table;
    }

    function buildRankingByTypeDetails() {
      const details = makeDetails('Ranking by type', { appendMeta: buildImpactSummaryMeta });
      const grouped = new Map();
      completeRows.forEach(row => {
        if (!grouped.has(row.type)) grouped.set(row.type, []);
        grouped.get(row.type).push(row);
      });
      if (!grouped.size) {
        const p = document.createElement('p');
        p.textContent = 'No ranking data available for the current selection.';
        details.appendChild(p);
        return details;
      }
      Array.from(grouped.keys()).sort().forEach(type => {
        const rows = grouped.get(type) || [];
        if (!rows.length) return;
        const ranked = rankScans(rows);
        const h3 = document.createElement('h3');
        h3.textContent = type;
        details.appendChild(h3);
        const table = buildTypeRankingTable(ranked);
        appendTableWithDownload(details, table, { filenameBase: `ranking-${sanitizeFilename(type)}` });
        appendMonitorApiFootnote(details);
      });
      return details;
    }

    pushSection('ranking', buildRankingDetails('domain'));
    pushSection('ranking', buildRankingDetails('website'));
    pushSection('ranking', buildRankingDetails('type'));

    const tabs = [
      { key: 'status', label: 'Scan Status', sections: sectionsByTab.status },
      { key: 'score', label: 'Score', sections: sectionsByTab.score },
      { key: 'issues', label: 'Issue Count', sections: sectionsByTab.issues },
      { key: 'pages', label: 'Pages with Issues', sections: sectionsByTab.pages },
      { key: 'ranking', label: 'Ranking', sections: sectionsByTab.ranking },
      { key: 'quick', label: 'Quick Actions', sections: sectionsByTab.quick }
    ];
    const visibleTabs = pageContext === 'scans'
      ? tabs
      : tabs.filter(tab => tab.key === 'quick');

    const tabList = document.createElement('div');
    tabList.className = 'a11y-tablist';
    tabList.setAttribute('role','tablist');
    tabList.setAttribute('aria-labelledby','a11y-scan-report-title');
    body.appendChild(tabList);

    const panelsWrap = document.createElement('div');
    panelsWrap.className = 'a11y-tabpanels';
    body.appendChild(panelsWrap);

    const tabButtons = [];
    const restoreState = previousAccordionState || getDefaultAccordionState(currentTabKey);

    const requestTabChange = key => {
      if (!key) return;
      if (key === currentTabKey) {
        const activeBtn = tabList.querySelector(`button[data-tab-key="${key}"]`);
        if (activeBtn) activeBtn.focus();
        return;
      }
      refreshMainView({ preserveState: true, targetTabKey: key })
        .then(() => {
          const latestBody = modalContext?.body;
          const nextBtn = latestBody?.querySelector(`.a11y-tablist button[data-tab-key="${key}"]`);
          if (nextBtn) nextBtn.focus();
        })
        .catch(err => alert(err.message));
    };

    const handleTabKeydown = (event, index) => {
      const { key } = event;
      const maxIndex = tabButtons.length - 1;
      if (key === 'Enter' || key === ' ' || key === 'Spacebar') {
        event.preventDefault();
        const targetKey = tabButtons[index]?.dataset.tabKey;
        requestTabChange(targetKey);
        return;
      }
      let nextIndex = null;
      if (key === 'ArrowLeft' || key === 'ArrowUp') {
        nextIndex = (index - 1 + tabButtons.length) % tabButtons.length;
      } else if (key === 'ArrowRight' || key === 'ArrowDown') {
        nextIndex = (index + 1) % tabButtons.length;
      } else if (key === 'Home') {
        nextIndex = 0;
      } else if (key === 'End') {
        nextIndex = maxIndex;
      } else {
        return;
      }
      event.preventDefault();
      const nextBtn = tabButtons[nextIndex];
      if (nextBtn) {
        nextBtn.focus();
        requestTabChange(nextBtn.dataset.tabKey);
      }
    };

    const appendSectionsToPanel = (panel, sections) => {
      const isPagesTab = pageContext === 'scans' && panel?.dataset?.tabKey === 'pages';
      const isIssuesTab = pageContext === 'scans' && panel?.dataset?.tabKey === 'issues';
      if (isPagesTab || isIssuesTab) {
        const filterBlock = buildPageImpactFilterControls();
        if (filterBlock) panel.appendChild(filterBlock);
      }
      if (!sections.length) {
        const p = document.createElement('p');
        p.textContent = 'No data available for this tab.';
        panel.appendChild(p);
        return;
      }
      const controls = document.createElement('div');
      controls.className = 'a11y-panel-controls';
      if (panel?.dataset?.tabKey === 'ranking' && pageContext === 'scans') {
        const rankingControl = buildRankingControlBlock();
        if (rankingControl) controls.appendChild(rankingControl);
      }
      const expandBtn = document.createElement('button');
      expandBtn.type = 'button';
      expandBtn.className = 'a11y-panel-toggle-btn';
      expandBtn.textContent = 'Expand all';
      expandBtn.addEventListener('click', () => {
        panel.querySelectorAll('details').forEach(d => { d.open = true; });
        accordionStateByTab[currentTabKey] = captureAccordionState(panel) || {};
      });
      const collapseBtn = document.createElement('button');
      collapseBtn.type = 'button';
      collapseBtn.className = 'a11y-panel-toggle-btn';
      collapseBtn.textContent = 'Collapse all';
      collapseBtn.addEventListener('click', () => {
        panel.querySelectorAll('details').forEach(d => { d.open = false; });
        accordionStateByTab[currentTabKey] = captureAccordionState(panel) || {};
      });
      controls.appendChild(expandBtn);
      controls.appendChild(collapseBtn);
      panel.appendChild(controls);
      sections.forEach(section => panel.appendChild(section));
      restoreAccordionState(panel, restoreState);
    };

    visibleTabs.forEach((tab, index) => {
      const tabId = `a11y-tab-${tab.key}`;
      const panelId = `a11y-tabpanel-${tab.key}`;
      const isSelected = tab.key === currentTabKey;
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.id = tabId;
      btn.dataset.tabKey = tab.key;
      btn.setAttribute('role','tab');
      btn.setAttribute('aria-selected', String(isSelected));
      btn.setAttribute('aria-controls', panelId);
      btn.tabIndex = isSelected ? 0 : -1;

      const focusWrap = document.createElement('span');
      focusWrap.className = 'a11y-tab-focus';
      const labelSpan = document.createElement('span');
      labelSpan.className = 'a11y-tab-label';
      labelSpan.textContent = tab.label;
      focusWrap.appendChild(labelSpan);
      btn.appendChild(focusWrap);
      btn.addEventListener('click', () => requestTabChange(tab.key));
      btn.addEventListener('keydown', event => handleTabKeydown(event, index));
      tabButtons.push(btn);
      tabList.appendChild(btn);

      const panel = document.createElement('div');
      panel.className = 'a11y-tabpanel';
      panel.id = panelId;
      panel.setAttribute('role','tabpanel');
      panel.setAttribute('aria-labelledby', tabId);
      panel.dataset.tabKey = tab.key;
      panel.tabIndex = -1;
      if (!isSelected) {
        panel.hidden = true;
      } else {
        appendSectionsToPanel(panel, tab.sections);
      }
      panelsWrap.appendChild(panel);
    });

    if (pageContext === 'scans') {
      renderRefreshFooter(footer, now, body, updateFilterButtonLabel);
      if (updateFilterButtonLabel) updateFilterButtonLabel(data);
    } else {
      footer.innerHTML = '';
      const note = document.createElement('p');
      note.className = 'a11y-quick-actions-note';
      note.textContent = 'Quick Actions run against the active Issues results on this page.';
      footer.appendChild(note);
    }
    updatePageImpactSourceControls();
  }

  function buildWasSection(rowLookup) {
    const details = document.createElement('details');
    details.open = true;
    const summary = document.createElement('summary');
    const h2 = document.createElement('h2');
    h2.textContent = 'WAS (Web Accessibility Scorecard)';
    summary.appendChild(h2);
    details.appendChild(summary);

    const summaryWrap = document.createElement('div');
    summaryWrap.className = 'a11y-was-summary';
    const summaryText = document.createElement('span');
    summaryWrap.appendChild(summaryText);

    const editBtn = document.createElement('button');
    editBtn.type = 'button';
    editBtn.className = 'a11y-was-edit-btn';
    editBtn.setAttribute('aria-label','Edit WAS report selections');
    editBtn.innerHTML = `
      <span aria-hidden="true" class="Icon Icon--pencil">
        <svg overflow="visible" preserveAspectRatio="none" viewBox="0 0 24 24" height="16" width="16">
          <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 0 0 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" vector-effect="non-scaling-stroke" fill="currentColor"></path>
        </svg>
      </span>
      <span>Edit list</span>
    `;
    summaryWrap.appendChild(editBtn);
    details.appendChild(summaryWrap);

    const intro = document.createElement('p');
    intro.textContent = 'Loads Critical, Serious, Needs Review, and PDF critical page counts for selected WAS reports by querying the Deque Monitor API. This may take a little while for large selections.';
    details.appendChild(intro);

    const actions = document.createElement('div');
    actions.className = 'a11y-was-actions';
    const loadBtn = document.createElement('button');
    loadBtn.type = 'button';
    loadBtn.className = 'a11y-btn-primary';
    loadBtn.textContent = wasDataCache.status === 'ready' ? 'Reload numbers' : 'Load numbers (may take some time)';
    actions.appendChild(loadBtn);
    const apiKeyBtn = document.createElement('button');
    apiKeyBtn.type = 'button';
    apiKeyBtn.className = 'a11y-btn-secondary';
    apiKeyBtn.textContent = 'Set API key';
    apiKeyBtn.setAttribute('aria-haspopup','dialog');
    actions.appendChild(apiKeyBtn);
    const apiKeyStatus = document.createElement('span');
    apiKeyStatus.className = 'a11y-was-api-status';
    apiKeyStatus.setAttribute('role','status');
    apiKeyStatus.setAttribute('aria-live','polite');
    actions.appendChild(apiKeyStatus);
    details.appendChild(actions);

    const content = document.createElement('div');
    content.className = 'a11y-was-results';
    details.appendChild(content);

    function updateSummary() {
      const count = getEnabledWasRows().length;
      summaryText.innerHTML = `<strong>${count}</strong> WAS Domains to be Checked`;
      loadBtn.disabled = count === 0 || wasDataCache.status === 'loading';
    }
    updateSummary();

    function updateApiKeyStatus() {
      const hasKey = !!getStoredMonitorApiKey();
      apiKeyStatus.textContent = hasKey ? 'API key set' : 'API key missing';
      apiKeyStatus.style.color = hasKey ? '#1b5e20' : '#a4000f';
    }
    updateApiKeyStatus();

    document.addEventListener('a11y-monitor-api-key-changed', updateApiKeyStatus);

    if (wasDataCache.status === 'ready' && Array.isArray(wasDataCache.data)) {
      renderWasTable(content, wasDataCache.data, wasDataCache.timestamp);
    }

    apiKeyBtn.addEventListener('click', async () => {
      try {
        const saved = await openSettingsDialog({ focusField: 'apiKey' });
        if (saved) {
          updateApiKeyStatus();
        }
      } catch (err) {
        console.error(err);
        alert(err?.message || 'Unable to open settings.');
      } finally {
        apiKeyBtn.focus();
      }
    });

    editBtn.addEventListener('click', () => {
      openWasConfigModal(rowLookup)
        .then(updated => {
          if (updated) {
            wasDataCache = { status: 'idle', data: null, timestamp: null };
            content.innerHTML = '';
            loadBtn.textContent = 'Load numbers (may take some time)';
            updateSummary();
          }
        })
        .catch(err => {
          console.error(err);
          alert(err?.message || 'Unable to open WAS editor.');
        });
    });

    loadBtn.addEventListener('click', () => {
      if (!rowLookup || !rowLookup.size) {
        logWas('Cannot load: row lookup not ready');
        alert('Scan data is still loading. Please try again in a moment.');
        return;
      }
      if (!getEnabledWasRows().length) {
        logWas('Cannot load: no WAS reports selected');
        alert('Select at least one WAS report to load.');
        return;
      }
      if (!getStoredMonitorApiKey()) {
        alert('Set the Deque Monitor API key before loading metrics.');
        return;
      }
      logWas('User initiated WAS load');
      handleWasLoad(rowLookup, content, loadBtn).catch(err => {
        console.error(err);
        alert(err.message || 'Unable to load WAS metrics.');
      });
    });

    return details;
  }

  function syncPageHealthAvailability(rows) {
    if (pageContext !== 'scans') return;
    const list = (rows || []).filter(row => row && row.scanId);
    const lookup = new Map();
    list.forEach(row => {
      lookup.set(String(row.scanId), row);
    });
    pageHealthState.availableScans = list;
    pageHealthState.scanLookup = lookup;
    let removed = false;
    pageHealthState.selectedScanIds.forEach(id => {
      if (!lookup.has(id)) {
        pageHealthState.selectedScanIds.delete(id);
        removed = true;
      }
    });
    if (removed) {
      logPageHealth('Removed scan selections that are no longer visible in the table.');
      pageHealthState.render?.();
    }
  }

  function getPageHealthSelectedRows() {
    const rows = [];
    pageHealthState.selectedScanIds.forEach(id => {
      const row = pageHealthState.scanLookup.get(id);
      if (row) rows.push(row);
    });
    return rows;
  }

  function clearPageHealthResults({ preserveSelection = true } = {}) {
    if (!preserveSelection) {
      pageHealthState.selectedScanIds.clear();
    }
    pageHealthState.results = [];
    pageHealthState.perScanStatus.clear();
    pageHealthState.progress = { total: 0, completed: 0, failed: 0 };
    pageHealthState.fetchStatus = 'idle';
    pageHealthState.fetchMessage = '';
    pageHealthState.lastError = null;
    pageHealthState.discovery.error = null;
  }

  function cancelPageHealthFetch(message = 'Cancelling…') {
    if (!pageHealthState.abortController) return;
    pageHealthState.fetchStatus = 'cancelling';
    pageHealthState.fetchMessage = message;
    pageHealthState.abortController.abort();
    logPageHealth('Cancellation requested.');
    pageHealthState.render?.();
  }

  function getPageIssueCounts(row) {
    const critical = Math.max(0, coerceNumber(row?.criticalIssues, 0));
    const serious = Math.max(0, coerceNumber(row?.seriousIssues, 0));
    const moderate = Math.max(0, coerceNumber(row?.moderateIssues, 0));
    const minor = Math.max(0, coerceNumber(row?.minorIssues, 0));
    const needsReview = Math.max(0, coerceNumber(row?.needsReview, 0));
    const exclNeeds = critical + serious + moderate + minor;
    const inclNeeds = exclNeeds + needsReview;
    return { critical, serious, moderate, minor, needsReview, exclNeeds, inclNeeds };
  }

  function matchesPageHealthFilter(row, key = pageHealthState.filterKey || 'completed') {
    const filterKey = key || 'completed';
    const status = (row?.status || '').toLowerCase();
    const counts = getPageIssueCounts(row);
    switch (filterKey) {
      case 'critical':
        return counts.critical > 0;
      case 'issues':
        return counts.inclNeeds > 0;
      case 'failed':
        return status !== 'completed';
      case 'completed':
      default:
        return status === 'completed';
    }
  }

  function getSortedPageHealthResults(sourceRows = pageHealthState.results) {
    const rows = sourceRows.slice();
    const { key, direction } = pageHealthState.sort || { key: 'issueCountInc', direction: 'desc' };
    const multiplier = direction === 'desc' ? -1 : 1;
    const numericKeys = new Set([
      'criticalIssues',
      'seriousIssues',
      'moderateIssues',
      'minorIssues',
      'needsReview',
      'openIssues',
      'fixedIssues',
      'issueCountExcl',
      'issueCountInc'
    ]);
    rows.sort((a, b) => {
      const aVal = numericKeys.has(key) ? coerceNumber(a[key], -Infinity) : (a[key] || '').toString().toLowerCase();
      const bVal = numericKeys.has(key) ? coerceNumber(b[key], -Infinity) : (b[key] || '').toString().toLowerCase();
      if (aVal < bVal) return -1 * multiplier;
      if (aVal > bVal) return 1 * multiplier;
      return (a.scanName || '').localeCompare(b.scanName || '', undefined, { sensitivity: 'base' });
    });
    return rows;
  }

  function getFilteredPageHealthResults() {
    const filtered = pageHealthState.results.filter(row => matchesPageHealthFilter(row));
    return getSortedPageHealthResults(filtered);
  }

  function setPageHealthSort(nextKey) {
    const current = pageHealthState.sort || { key: 'issueCountInc', direction: 'desc' };
    if (current.key === nextKey) {
      current.direction = current.direction === 'asc' ? 'desc' : 'asc';
    } else {
      current.key = nextKey;
      current.direction = nextKey === 'scanName' ? 'asc' : 'desc';
    }
    pageHealthState.sort = current;
    pageHealthState.render?.();
  }

  function renderPageHealthResults(container) {
    container.innerHTML = '';
    const rows = getFilteredPageHealthResults();
    if (!rows.length) {
      const empty = document.createElement('p');
      empty.textContent = pageHealthState.results.length
        ? 'No pages match the selected filter.'
        : 'No page-level data fetched yet. Select scans and run the fetch to see results.';
      container.appendChild(empty);
      return;
    }
    const toolbar = document.createElement('div');
    toolbar.className = 'a11y-table-toolbar';
    const downloadBtn = document.createElement('button');
    downloadBtn.type = 'button';
    downloadBtn.className = 'a11y-table-download-btn';
    downloadBtn.textContent = 'Download CSV';
    downloadBtn.addEventListener('click', () => downloadPageHealthCsv(rows));
    toolbar.appendChild(downloadBtn);
    container.appendChild(toolbar);

    const headers = [
      { key: 'url', label: 'Url Page' },
      { key: 'title', label: 'Title' },
      { key: 'template', label: 'Is template' },
      { key: 'status', label: 'Status' },
      { key: 'failureReason', label: 'Reason for Failure' },
      { key: 'issueCountExcl', label: 'Issue Count (Excl Needs Review)' },
      { key: 'issueCountInc', label: 'Issue Count (Inc Needs Review)' },
      { key: 'scanGroup', label: 'Scan Group' },
      { key: 'source', label: 'Source' },
      { key: 'scanUrl', label: 'URL' }
    ];

    const table = document.createElement('table');
    table.className = 'a11y-scan-report-table';
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headers.forEach(def => {
      const th = document.createElement('th');
      th.setAttribute('scope','col');
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'a11y-page-health-sort';
      btn.textContent = def.label;
      if (pageHealthState.sort?.key === def.key) {
        btn.dataset.sortDirection = pageHealthState.sort.direction;
      }
      btn.addEventListener('click', () => setPageHealthSort(def.key));
      th.appendChild(btn);
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    rows.forEach(row => {
      const tr = document.createElement('tr');
      const counts = getPageIssueCounts(row);
      row.issueCountExcl = counts.exclNeeds;
      row.issueCountInc = counts.inclNeeds;
      const cells = [
        row.url || '',
        row.title || '',
        row.template ? 'Yes' : 'No',
        row.status || '',
        row.failureReason || '',
        row.issueCountExcl,
        row.issueCountInc,
        row.scanGroup || row.scanName || '',
        row.source || row.domainUrl || '',
        row.scanUrl || row.scanName || ''
      ];
      cells.forEach((value, idx) => {
        const cell = document.createElement(idx === 0 ? 'th' : 'td');
        if (idx === 0) cell.setAttribute('scope','row');
        if (idx === 0 && row.url) {
          cell.textContent = '';
          const link = createExternalLink(row.url, row.url);
          link?.classList.add('a11y-page-link-inline');
          if (link) {
            cell.appendChild(link);
          } else {
            cell.textContent = String(value || '');
          }
        } else if (idx === cells.length - 1 && row.scanUrl) {
          const link = createExternalLink(row.scanUrl, row.scanUrl);
          if (link) {
            cell.textContent = '';
            cell.appendChild(link);
          } else {
            cell.textContent = String(value || '');
          }
        } else {
          cell.textContent = value == null ? '' : String(value);
        }
        tr.appendChild(cell);
      });
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    container.appendChild(table);
  }

  function downloadPageHealthCsv(rows) {
    const columns = [
      { key: 'url', label: 'Url Page' },
      { key: 'title', label: 'Title' },
      { key: 'template', label: 'Is template', format: value => (value ? 'Yes' : 'No') },
      { key: 'status', label: 'Status' },
      { key: 'failureReason', label: 'Reason for Failure' },
      { key: 'issueCountExcl', label: 'Issue Count (Excl Needs Review)' },
      { key: 'issueCountInc', label: 'Issue Count (Inc Needs Review)' },
      { key: 'scanGroup', label: 'Scan Group' },
      { key: 'source', label: 'Source' },
      { key: 'scanUrl', label: 'URL' }
    ];
    try {
      downloadObjectCsv(rows, columns, 'page-health-pages');
    } catch (err) {
      console.error(err);
      alert('Unable to download CSV.');
    }
  }

  function buildPageHealthSection({ data }) {
    const details = document.createElement('details');
    details.open = true;
    details.id = pageHealthSectionId;
    const summary = document.createElement('summary');
    const h2 = document.createElement('h2');
    h2.textContent = 'Page Lists';
    summary.appendChild(h2);
    details.appendChild(summary);

    const intro = document.createElement('p');
    intro.className = 'a11y-quick-actions-note';
    intro.textContent = 'Pick the scans in view, then pull a per-page list with status, failure reasons, and issue counts for each URL. Results live only for this session.';
    details.appendChild(intro);

    const content = document.createElement('div');
    content.className = 'a11y-page-health-body';
    details.appendChild(content);

    const render = () => {
      content.innerHTML = '';
      const hasSelection = pageHealthState.selectedScanIds.size > 0;
      const isFetching =
        pageHealthState.fetchStatus === 'fetching' || pageHealthState.fetchStatus === 'cancelling';
      const actions = document.createElement('div');
      actions.className = 'a11y-page-health-actions';

      const pickBtn = document.createElement('button');
      pickBtn.type = 'button';
      pickBtn.className = 'a11y-btn-primary';
      pickBtn.textContent = hasSelection ? 'Edit scan selection' : 'Choose scans';
      pickBtn.addEventListener('click', () => {
        if (!pageHealthState.availableScans.length) {
          alert('No scans are available in the current table. Adjust filters and try again.');
          return;
        }
        openPageHealthScanPicker({
          scans: pageHealthState.availableScans,
          selectedIds: pageHealthState.selectedScanIds,
          onSave(nextIds) {
            pageHealthState.selectedScanIds.clear();
            nextIds.forEach(id => pageHealthState.selectedScanIds.add(id));
            pageHealthState.render?.();
          }
        });
      });
      actions.appendChild(pickBtn);

      const fetchBtn = document.createElement('button');
      fetchBtn.type = 'button';
      fetchBtn.className = 'a11y-btn-primary';
      fetchBtn.textContent = isFetching ? 'Fetching…' : 'Fetch page data';
      fetchBtn.disabled = !hasSelection || isFetching;
      fetchBtn.addEventListener('click', () => {
        startPageHealthFetch().catch(err => {
          console.error(err);
          alert(err?.message || 'Unable to start page fetch.');
        });
      });
      actions.appendChild(fetchBtn);

      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.className = 'a11y-btn-secondary';
      cancelBtn.textContent = 'Cancel fetch';
      cancelBtn.hidden = !isFetching;
      cancelBtn.addEventListener('click', () => cancelPageHealthFetch('Cancelled by user.'));
      actions.appendChild(cancelBtn);

      const clearBtn = document.createElement('button');
      clearBtn.type = 'button';
      clearBtn.className = 'a11y-btn-secondary';
      clearBtn.textContent = 'Clear selection/results';
      clearBtn.disabled =
        !hasSelection && !pageHealthState.results.length && !pageHealthState.perScanStatus.size;
      clearBtn.addEventListener('click', () => {
        if (!hasSelection && !pageHealthState.results.length) return;
        if (!confirm('Clear the current scan selection and any fetched page data?')) return;
        if (isFetching) cancelPageHealthFetch('Cleared by user.');
        clearPageHealthResults({ preserveSelection: false });
        pageHealthState.render?.();
      });
      actions.appendChild(clearBtn);

      const progressNote = document.createElement('span');
      progressNote.className = 'a11y-page-health-progress';
      if (pageHealthState.fetchMessage) {
        progressNote.textContent = pageHealthState.fetchMessage;
      } else if (isFetching) {
        const total = pageHealthState.progress.total || pageHealthState.selectedScanIds.size || 0;
        const done = pageHealthState.progress.completed + pageHealthState.progress.failed;
        progressNote.textContent = `Fetching ${Math.min(done, total)}/${total || '?'} scans…`;
      } else if (hasSelection) {
        progressNote.textContent = `${pageHealthState.selectedScanIds.size} scan(s) ready.`;
      } else {
        progressNote.textContent = 'No scans selected.';
      }
      actions.appendChild(progressNote);
      content.appendChild(actions);

      const selectionBlock = document.createElement('div');
      selectionBlock.className = 'a11y-page-health-selection';
      const selectedRows = getPageHealthSelectedRows();
      if (!selectedRows.length) {
        selectionBlock.textContent = 'Use “Choose scans” to pick from the current table.';
      } else {
        const list = document.createElement('ul');
        selectedRows.slice(0, 6).forEach(row => {
          const li = document.createElement('li');
          const label = document.createElement('code');
          label.textContent = row.name;
          li.appendChild(label);
          const meta = document.createElement('span');
          meta.textContent = ` — ${row.domain || 'Domain'} · ${row.type || 'Type'}`;
          li.appendChild(meta);
          list.appendChild(li);
        });
        if (selectedRows.length > 6) {
          const li = document.createElement('li');
          li.textContent = `+${selectedRows.length - 6} more`;
          list.appendChild(li);
        }
        selectionBlock.appendChild(list);
      }
      content.appendChild(selectionBlock);

      const filterWrap = document.createElement('div');
      filterWrap.className = 'a11y-page-health-filter';
      const filterLabel = document.createElement('label');
      filterLabel.setAttribute('for','a11y-page-health-filter');
      filterLabel.textContent = 'Filter by';
      const filterSelect = document.createElement('select');
      filterSelect.id = 'a11y-page-health-filter';
      pageHealthFilterOptions.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.key;
        opt.textContent = option.label;
        filterSelect.appendChild(opt);
      });
      filterSelect.value = pageHealthState.filterKey || 'completed';
      filterSelect.disabled = !pageHealthState.results.length;
      filterSelect.addEventListener('change', () => {
        pageHealthState.filterKey = filterSelect.value;
        pageHealthState.render?.();
      });
      filterWrap.appendChild(filterLabel);
      filterWrap.appendChild(filterSelect);
      content.appendChild(filterWrap);

      const statusBox = document.createElement('div');
      statusBox.className = 'a11y-page-health-status';
      const statusList = document.createElement('ul');
      if (!pageHealthState.perScanStatus.size) {
        const li = document.createElement('li');
        li.textContent = 'No API calls started yet.';
        statusList.appendChild(li);
      } else {
        const entries = Array.from(pageHealthState.perScanStatus.values()).sort((a, b) =>
          (a.scanName || '').localeCompare(b.scanName || '', undefined, { sensitivity: 'base' })
        );
        entries.forEach(entry => {
          const li = document.createElement('li');
          if (entry.status) li.dataset.status = entry.status;
          const label = document.createElement('strong');
          label.textContent = entry.scanName || entry.scanId;
          li.appendChild(label);
          const msg = document.createElement('span');
          msg.textContent = ` — ${entry.message || 'Ready'}`;
          li.appendChild(msg);
          if (entry.truncated) {
            const note = document.createElement('em');
            note.textContent = ' (Reached per-scan cap)';
            li.appendChild(note);
          }
          statusList.appendChild(li);
        });
      }
      statusBox.appendChild(statusList);
      content.appendChild(statusBox);

      const resultsContainer = document.createElement('div');
      resultsContainer.className = 'a11y-page-health-results';
      renderPageHealthResults(resultsContainer);
      content.appendChild(resultsContainer);
    };

    pageHealthState.render = render;
    render();
    return details;
  }

  function openPageHealthScanPicker({ scans, selectedIds, onSave }) {
    const list = Array.from(scans || []).filter(row => row && row.scanId);
    if (!list.length) {
      alert('No scans are available to select.');
      return;
    }
    const overlay = document.createElement('div');
    overlay.className = 'a11y-filter-overlay';
    const dialog = document.createElement('div');
    dialog.className = 'a11y-filter-dialog a11y-page-health-picker';
    dialog.setAttribute('role','dialog');
    dialog.setAttribute('aria-modal','true');

    const header = document.createElement('div');
    header.className = 'a11y-filter-header';
    const title = document.createElement('h2');
    title.textContent = 'Select scans for Page Lists';
    header.appendChild(title);
    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'Dialog__close';
    closeBtn.innerHTML = '<span aria-hidden=\"true\" class=\"Icon Icon--close\"><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" height=\"24\" width=\"24\"><path d=\"M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" fill=\"currentColor\"></path></svg></span><span class=\"Offscreen\">Close</span>';
    header.appendChild(closeBtn);
    dialog.appendChild(header);

    const content = document.createElement('div');
    content.className = 'a11y-filter-content';

    const controls = document.createElement('div');
    controls.className = 'a11y-page-health-picker-controls';
    const searchInput = document.createElement('input');
    searchInput.type = 'search';
    searchInput.className = 'a11y-page-health-picker-search';
    searchInput.placeholder = 'Search by scan, domain, or type';
    controls.appendChild(searchInput);

    const selectAllBtn = document.createElement('button');
    selectAllBtn.type = 'button';
    selectAllBtn.className = 'a11y-btn-secondary';
    selectAllBtn.textContent = 'Select filtered';
    controls.appendChild(selectAllBtn);

    const clearBtn = document.createElement('button');
    clearBtn.type = 'button';
    clearBtn.className = 'a11y-btn-secondary';
    clearBtn.textContent = 'Clear selection';
    controls.appendChild(clearBtn);

    const counts = document.createElement('span');
    counts.className = 'a11y-page-health-picker-counts';
    controls.appendChild(counts);
    content.appendChild(controls);

    const listWrap = document.createElement('div');
    listWrap.className = 'a11y-page-health-picker-list';
    content.appendChild(listWrap);

    dialog.appendChild(content);

    const footer = document.createElement('div');
    footer.className = 'a11y-filter-footer';
    const saveBtn = document.createElement('button');
    saveBtn.type = 'button';
    saveBtn.className = 'a11y-btn-primary';
    saveBtn.textContent = 'Save selection';
    const cancelBtn = document.createElement('button');
    cancelBtn.type = 'button';
    cancelBtn.className = 'a11y-btn-secondary';
    cancelBtn.textContent = 'Cancel';
    footer.appendChild(saveBtn);
    footer.appendChild(cancelBtn);
    dialog.appendChild(footer);

    overlay.appendChild(dialog);
    appendOverlayAfterFooter(overlay);

    const selection = new Set(selectedIds ? Array.from(selectedIds) : []);
    let filterText = '';

    const getFiltered = () => {
      if (!filterText) return list;
      const term = filterText.toLowerCase();
      return list.filter(row => {
        return [row.name, row.domain, row.type]
          .filter(Boolean)
          .some(text => text.toLowerCase().includes(term));
      });
    };

    const updateCounts = () => {
      counts.textContent = `${selection.size} selected / ${list.length} available`;
    };

    const renderList = () => {
      const filtered = getFiltered();
      listWrap.innerHTML = '';
      if (!filtered.length) {
        const empty = document.createElement('p');
        empty.className = 'a11y-page-health-picker-empty';
        empty.textContent = 'No scans match the current search.';
        listWrap.appendChild(empty);
        updateCounts();
        return;
      }
      filtered.forEach(row => {
        const item = document.createElement('label');
        item.className = 'a11y-page-health-picker-row';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = selection.has(row.scanId);
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            selection.add(row.scanId);
          } else {
            selection.delete(row.scanId);
          }
          updateCounts();
        });
        item.appendChild(checkbox);
        const title = document.createElement('div');
        title.className = 'a11y-page-health-picker-title';
        title.innerHTML = `<strong>${row.name}</strong>`;
        item.appendChild(title);
        const meta = document.createElement('div');
        meta.className = 'a11y-page-health-picker-meta';
        meta.textContent = `${row.domain || 'Domain'} · ${row.type || 'Type'} · ${row.statusText || row.statusKey || ''}`;
        item.appendChild(meta);
        listWrap.appendChild(item);
      });
      updateCounts();
    };

    searchInput.addEventListener('input', () => {
      filterText = searchInput.value.trim();
      renderList();
    });
    selectAllBtn.addEventListener('click', () => {
      getFiltered().forEach(row => selection.add(row.scanId));
      renderList();
    });
    clearBtn.addEventListener('click', () => {
      selection.clear();
      renderList();
    });

    const lastFocused = document.activeElement;

    function close(result) {
      overlay.remove();
      if (result && typeof onSave === 'function') {
        onSave(Array.from(selection));
      }
      if (lastFocused && typeof lastFocused.focus === 'function') {
        lastFocused.focus();
      }
    }

    saveBtn.addEventListener('click', () => close(true));
    cancelBtn.addEventListener('click', () => close(false));
    closeBtn.addEventListener('click', () => close(false));
    overlay.addEventListener('click', e => {
      if (e.target === overlay) close(false);
    });
    dialog.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        e.preventDefault();
        close(false);
      }
    });

    renderList();
    searchInput.focus();
  }

  async function startPageHealthFetch() {
    if (pageHealthState.fetchStatus === 'fetching') return;
    const selectedRows = getPageHealthSelectedRows();
    if (!selectedRows.length) {
      alert('Select at least one scan before fetching page data.');
      return;
    }
    try {
      ensureMonitorApiKey();
    } catch (err) {
      alert(err?.message || 'An API key is required.');
      return;
    }
    clearPageHealthResults({ preserveSelection: true });
    pageHealthState.progress = { total: selectedRows.length, completed: 0, failed: 0 };
    selectedRows.forEach(row => {
      updatePageHealthScanStatus(row.scanId, {
        scanName: row.name,
        status: 'pending',
        message: 'Waiting to start',
        pagesFetched: 0,
        truncated: false
      });
    });
    pageHealthState.fetchStatus = 'fetching';
    pageHealthState.fetchMessage = 'Starting page requests…';
    const controller = new AbortController();
    pageHealthState.abortController = controller;
    pageHealthState.render?.();
    try {
      for (const row of selectedRows) {
        if (controller.signal.aborted) break;
        await processPageHealthScan(row, controller.signal);
        if (controller.signal.aborted) break;
        if (pageHealthFetchDelayMs) {
          await wait(pageHealthFetchDelayMs);
        }
      }
      if (controller.signal.aborted) {
        pageHealthState.fetchStatus = 'cancelled';
        pageHealthState.fetchMessage = 'Fetch cancelled.';
      } else {
        pageHealthState.fetchStatus = 'idle';
        pageHealthState.fetchMessage = 'Page data loaded.';
      }
    } catch (err) {
      if (err?.name === 'AbortError') {
        pageHealthState.fetchStatus = 'cancelled';
        pageHealthState.fetchMessage = 'Fetch cancelled.';
      } else {
        pageHealthState.fetchStatus = 'error';
        pageHealthState.fetchMessage = err?.message || 'Unable to fetch page data.';
        pageHealthState.lastError = err;
        console.error(err);
      }
    } finally {
      pageHealthState.abortController = null;
      pageHealthState.render?.();
    }
  }

  function updatePageHealthScanStatus(scanId, patch) {
    const existing = pageHealthState.perScanStatus.get(scanId) || {
      scanId,
      scanName: pageHealthState.scanLookup.get(scanId)?.name || scanId
    };
    const next = { ...existing, ...patch, updatedAt: Date.now() };
    pageHealthState.perScanStatus.set(scanId, next);
  }

  async function processPageHealthScan(row, signal) {
    const scanId = row.scanId;
    try {
      updatePageHealthScanStatus(scanId, {
        status: 'runLookup',
        message: 'Getting latest run…'
      });
      pageHealthState.render?.();
      const run = await fetchLatestCompletedRunForScan(scanId, { signal });
      const runNumber = run?.runNumber ?? run?.run ?? run?.id;
      updatePageHealthScanStatus(scanId, {
        status: 'fetchPages',
        message: `Fetching pages for run ${runNumber || ''}…`,
        runNumber
      });
      pageHealthState.render?.();
      const { records, truncated } = await fetchPagesForRun(scanId, runNumber, { signal });
      const mapped = records.map(record => mapPageHealthRecord(record, row, run));
      if (mapped.length) {
        pageHealthState.results.push(...mapped);
      }
      updatePageHealthScanStatus(scanId, {
        status: 'success',
        message: `Fetched ${mapped.length} page(s)`,
        pagesFetched: mapped.length,
        truncated
      });
      pageHealthState.progress.completed += 1;
      pageHealthState.render?.();
    } catch (err) {
      if (err?.name === 'AbortError') throw err;
      logPageHealth('Scan fetch failed', row.name, err);
      updatePageHealthScanStatus(scanId, {
        status: 'error',
        message: err?.message || 'Unable to fetch pages.',
        error: err?.message || String(err)
      });
      pageHealthState.progress.failed += 1;
      pageHealthState.render?.();
    }
  }

  async function fetchLatestCompletedRunForScan(scanId, { signal } = {}) {
    if (!scanId) throw new Error('Missing scan id.');
    const payload = await fetchWasApi(`/scans/${scanId}/runs?needsReview=false`, { signal });
    const runs = getRunsArray(payload);
    if (!runs.length) throw new Error('No runs available for this scan.');
    const completed = runs.filter(run =>
      /complete/i.test(String(run.status || run.state || ''))
    );
    if (!completed.length) {
      const latest = selectLatestRun(runs);
      const latestStatus = latest?.status || latest?.state || 'unknown status';
      throw new Error(`Latest run is ${latestStatus}. Wait for completion before fetching pages.`);
    }
    const target = selectLatestRun(completed);
    if (!target) throw new Error('Unable to locate latest completed run.');
    return target;
  }

  async function fetchPagesForRun(scanId, runNumber, { signal, limit = pageHealthMaxPagesPerScan } = {}) {
    if (!scanId || runNumber == null) throw new Error('Missing scan id or run number.');
    const records = [];
    let pageNumber = 1;
    let truncated = false;
    let nextToken = null;
    while (records.length < limit) {
      const remaining = limit - records.length;
      const pageSize = Math.max(1, Math.min(pageHealthPageSize, remaining));
      const params = new URLSearchParams();
      params.set('pageSize', String(pageSize));
      params.set('pageNumber', String(pageNumber));
      params.set('status', 'Completed');
      params.set('needsReview', 'false');
      if (nextToken) params.set('pageToken', nextToken);
      const path = `/scans/${scanId}/runs/${runNumber}/pages?${params.toString()}`;
      const payload = await fetchWasApi(path, { signal });
      const pageData = getPagesArrayFromPayload(payload);
      records.push(...pageData);
      if (!pageHealthState.discovery.verified && pageData.length) {
        recordPageHealthDiscovery(pageData[0]);
      }
      const meta = derivePaginationMeta(payload);
      if (records.length >= limit) {
        truncated = true;
        break;
      }
      if (meta.nextPageToken) {
        nextToken = meta.nextPageToken;
      } else if (meta.hasNext) {
        pageNumber += 1;
      } else {
        break;
      }
    }
    return { records, truncated };
  }

  function getPagesArrayFromPayload(payload) {
    if (!payload) return [];
    if (Array.isArray(payload.pages)) return payload.pages;
    if (Array.isArray(payload.data)) return payload.data;
    if (Array.isArray(payload.items)) return payload.items;
    if (Array.isArray(payload.results)) return payload.results;
    return [];
  }

  function derivePaginationMeta(payload) {
    const meta = payload?.pagination || payload?.meta?.pagination || {};
    const currentPage = meta.currentPage ?? meta.page ?? null;
    const totalPages = meta.totalPages ?? meta.pages ?? null;
    const derivedHasNext =
      meta.hasNext ??
      meta.hasNextPage ??
      (Number.isFinite(currentPage) && Number.isFinite(totalPages)
        ? currentPage < totalPages
        : false);
    return {
      currentPage,
      totalPages,
      hasNext: !!derivedHasNext,
      nextPageToken: payload?.nextPageToken || meta.nextPageToken || null
    };
  }

  function recordPageHealthDiscovery(sample) {
    if (!sample || pageHealthState.discovery.verified) return;
    pageHealthState.discovery = {
      verified: true,
      sampleKeys: Object.keys(sample),
      lastChecked: Date.now(),
      error: null
    };
    logPageHealth('Page details API shape confirmed', pageHealthState.discovery.sampleKeys);
  }

  function mapPageHealthRecord(record, row, runMeta) {
    const pick = (...keys) => {
      for (const key of keys) {
        if (record && record[key] != null) return record[key];
      }
      return null;
    };
    const bool = value =>
      value === true || (typeof value === 'string' && value.toLowerCase() === 'true');
    const base = {
      scanId: row.scanId,
      scanName: row.name,
      scanDomain: row.domain || '',
      scanType: row.type || '',
      runNumber: runMeta?.runNumber ?? runMeta?.run ?? runMeta?.id ?? null,
      pageId: pick('pageId','id'),
      url: pick('url','pageUrl','pageUri','href') || '',
      title: pick('title','pageTitle') || '',
      template: bool(pick('template','isTemplate','templatePage')),
      status: pick('status','pageStatus','state') || '',
      failureReason: pick('reasonForFailure','failureReason','errorMessage','error'),
      source: pick('scriptStep','scriptName','pageSource','source'),
      domainUrl: pick('domainUrl','domain'),
      health: pick('health','pageHealth'),
      criticalIssues: coerceNumber(pick('totalCriticalIssues','criticalIssues','critical'), 0),
      seriousIssues: coerceNumber(pick('totalSeriousIssues','seriousIssues','serious'), 0),
      moderateIssues: coerceNumber(pick('totalModerateIssues','moderateIssues','moderate'), 0),
      minorIssues: coerceNumber(pick('totalMinorIssues','minorIssues','minor'), 0),
      needsReview: coerceNumber(pick('totalNeedsReview','needsReview'), 0),
      openIssues: coerceNumber(pick('totalOpenIssues','openIssues','open'), 0),
      fixedIssues: coerceNumber(pick('totalFixedIssues','fixedIssues','fixed'), 0),
      scanGroup: row.domain || row.type || row.name || '',
      scanUrl: row.url || ''
    };
    const counts = getPageIssueCounts(base);
    base.issueCountExcl = counts.exclNeeds;
    base.issueCountInc = counts.inclNeeds;
    return base;
  }

  async function collectAllPageUrls() {
    if (pageContext !== 'pages') throw new Error('Copying URLs is only available on the Pages view.');
    await ensurePagesViewByUrl();
    await waitForPagesTable();
    let paginationStatus = getPaginationStatus();
    const updateOptions = {
      getSignature: getPagesTableSignature,
      waitForChange: prev => waitForPagesTableChange(prev)
    };
    const select = getPageSizeSelect();
    if (select) {
      await ensurePageSize(select, updateOptions);
      paginationStatus = await waitForPaginationAdvance(paginationStatus);
    }
    const pagination = getPaginationContainer();
    if (pagination) {
      await goToFirstPage(pagination, updateOptions);
      paginationStatus = await waitForPaginationAdvance(paginationStatus);
    }
    const seen = new Set();
    const urls = [];

    async function captureCurrentPage() {
      const table = findPagesTable();
      if (!table) throw new Error('Pages table not found.');
      const pageUrls = extractPageUrlsFromTable(table);
      pageUrls.forEach(url => {
        const trimmed = (url || '').trim();
        if (!trimmed || seen.has(trimmed)) return;
        seen.add(trimmed);
        urls.push(trimmed);
      });
    }

    await captureCurrentPage();
    if (pagination) {
      while (await goToNextPage(pagination, updateOptions)) {
        paginationStatus = await waitForPaginationAdvance(paginationStatus);
        await captureCurrentPage();
      }
      await goToFirstPage(pagination, updateOptions);
      paginationStatus = await waitForPaginationAdvance(paginationStatus);
    }
    logCopyPageUrls('Collected URLs', { count: urls.length });
    return urls;
  }

  function buildCopyPageUrlsSection() {
    if (pageContext !== 'pages') return null;
    const details = document.createElement('details');
    details.open = true;
    const summary = document.createElement('summary');
    const h2 = document.createElement('h2');
    h2.textContent = 'Copy Page URLs to Clipboard';
    summary.appendChild(h2);
    details.appendChild(summary);

    const intro = document.createElement('p');
    intro.className = 'a11y-quick-actions-note';
    intro.textContent = 'Collects every Page URL from the current table (set to 100 rows per page) and lists them so you can copy them for sharing.';
    details.appendChild(intro);

    const actions = document.createElement('div');
    actions.className = 'a11y-copy-urls-actions';
    const collectBtn = document.createElement('button');
    collectBtn.type = 'button';
    collectBtn.className = 'a11y-btn-primary';
    collectBtn.textContent = 'Collect Page URLs';
    const copyBtn = document.createElement('button');
    copyBtn.type = 'button';
    copyBtn.className = 'a11y-btn-secondary';
    copyBtn.textContent = 'Copy to clipboard';
    copyBtn.disabled = true;
    const status = document.createElement('span');
    status.className = 'a11y-quick-actions-note';
    status.textContent = 'No URLs collected yet.';
    actions.appendChild(collectBtn);
    actions.appendChild(copyBtn);
    actions.appendChild(status);
    details.appendChild(actions);

    const output = document.createElement('pre');
    output.className = 'a11y-copy-urls-output';
    output.setAttribute('tabindex','0');
    output.textContent = '';
    details.appendChild(output);

    let currentUrls = [];

    collectBtn.addEventListener('click', async () => {
      if (collectBtn.disabled) return;
      currentUrls = [];
      collectBtn.disabled = true;
      copyBtn.disabled = true;
      status.textContent = 'Collecting URLs…';
      output.textContent = '';
      try {
        const urls = await collectAllPageUrls();
        currentUrls = urls;
        if (urls.length) {
          output.textContent = urls.join('\n');
          status.textContent = `Collected ${urls.length} URL${urls.length === 1 ? '' : 's'}.`;
          copyBtn.disabled = false;
        } else {
          status.textContent = 'No URLs found for the current filters.';
        }
      } catch (err) {
        const message = err?.message || 'Unable to collect URLs. Make sure the Pages table is visible.';
        status.textContent = message;
        logCopyPageUrls('Collection failed', message);
      } finally {
        collectBtn.disabled = false;
      }
    });

    copyBtn.addEventListener('click', async () => {
      if (!currentUrls.length || copyBtn.disabled) return;
      try {
        const success = await writeTextToClipboard(currentUrls.join('\n'));
        if (success) {
          alert('Copied page URLs to clipboard.');
        } else {
          alert('Unable to use the clipboard. Copy the URLs manually from the list.');
        }
      } catch (err) {
        alert(err?.message || 'Unable to copy to clipboard.');
      }
    });

    return details;
  }

  function buildFindPdfsSection() {
    if (pageContext !== 'pages') return null;
    const wrapper = document.createElement('div');

    const downloadDetails = document.createElement('details');
    downloadDetails.open = true;
    const downloadSummary = document.createElement('summary');
    const downloadHeading = document.createElement('h2');
    downloadHeading.textContent = 'Download PDFs';
    downloadSummary.appendChild(downloadHeading);
    downloadDetails.appendChild(downloadSummary);

    const downloadIntro = document.createElement('p');
    downloadIntro.className = 'a11y-quick-actions-note';
    downloadIntro.textContent = 'Collect PDF URLs from the current Pages table and trigger browser downloads so the files are available locally.';
    downloadDetails.appendChild(downloadIntro);

    const step1Section = document.createElement('div');
    step1Section.className = 'a11y-pdf-step';
    const step1Note = document.createElement('p');
    step1Note.className = 'a11y-quick-actions-note';
    step1Note.textContent =
      'Trigger normal browser downloads for every PDF URL in the current Pages table. If PDFs open in a tab instead of downloading, enable Chrome’s “Download PDF files instead of automatically opening them” setting.';
    step1Section.appendChild(step1Note);
    const triggerBtn = document.createElement('button');
    triggerBtn.type = 'button';
    triggerBtn.className = 'a11y-btn-primary';
    triggerBtn.textContent = 'Download PDFs to Downloads folder';
    step1Section.appendChild(triggerBtn);
    const downloadStatus = document.createElement('p');
    downloadStatus.className = 'a11y-quick-actions-note';
    downloadStatus.textContent = 'Not started.';
    step1Section.appendChild(downloadStatus);
    downloadDetails.appendChild(step1Section);
    wrapper.appendChild(downloadDetails);

    const analyzeDetails = document.createElement('details');
    analyzeDetails.open = true;
    const analyzeSummary = document.createElement('summary');
    const analyzeHeading = document.createElement('h2');
    analyzeHeading.textContent = 'Find PDFs by Modified Date';
    analyzeSummary.appendChild(analyzeHeading);
    analyzeDetails.appendChild(analyzeSummary);

    const analyzeIntro = document.createElement('p');
    analyzeIntro.className = 'a11y-quick-actions-note';
    analyzeIntro.textContent = 'Choose any folder of PDFs (including ones downloaded previously) and filter them by their metadata-modified date.';
    analyzeDetails.appendChild(analyzeIntro);

    const step2Section = document.createElement('div');
    step2Section.className = 'a11y-pdf-step';
    const step2Note = document.createElement('p');
    step2Note.className = 'a11y-quick-actions-note';
    step2Note.textContent =
      'Choose the folder that contains the PDFs you want to inspect, then run the metadata filter.';
    step2Section.appendChild(step2Note);

    const destinationControls = document.createElement('div');
    destinationControls.className = 'a11y-pdf-filter';
    const chooseFolderBtn = document.createElement('button');
    chooseFolderBtn.type = 'button';
    chooseFolderBtn.className = 'a11y-btn-primary';
    chooseFolderBtn.textContent = 'Choose folder with downloaded PDFs';
    const folderStatus = document.createElement('span');
    folderStatus.className = 'a11y-quick-actions-note';
    folderStatus.textContent = 'No folder selected yet.';
    destinationControls.appendChild(chooseFolderBtn);
    destinationControls.appendChild(folderStatus);
    step2Section.appendChild(destinationControls);
    const folderError = document.createElement('p');
    folderError.className = 'a11y-quick-actions-error';
    folderError.hidden = true;
    step2Section.appendChild(folderError);

    const filterRow = document.createElement('div');
    filterRow.className = 'a11y-pdf-filter';
    const filterGroup = document.createElement('div');
    filterGroup.className = 'a11y-pdf-filter-group';
    const filterLabel = document.createElement('label');
    filterLabel.textContent = 'Filter by';
    const filterSelect = document.createElement('select');
    [
      { value: 'before', label: 'Before Date' },
      { value: 'between', label: 'Between Dates' },
      { value: 'after', label: 'After Date' }
    ].forEach(opt => {
      const option = document.createElement('option');
      option.value = opt.value;
      option.textContent = opt.label;
      filterSelect.appendChild(option);
    });
    filterGroup.appendChild(filterLabel);
    filterGroup.appendChild(filterSelect);
    filterRow.appendChild(filterGroup);

    const singleDateGroup = document.createElement('div');
    singleDateGroup.className = 'a11y-pdf-filter-group';
    const singleLabel = document.createElement('label');
    singleLabel.textContent = 'Date (MM/DD/YYYY)';
    const singleInput = document.createElement('input');
    singleInput.type = 'date';
    singleInput.placeholder = 'MM/DD/YYYY';
    singleDateGroup.appendChild(singleLabel);
    singleDateGroup.appendChild(singleInput);
    filterRow.appendChild(singleDateGroup);

    const startDateGroup = document.createElement('div');
    startDateGroup.className = 'a11y-pdf-filter-group';
    const startLabel = document.createElement('label');
    startLabel.textContent = 'Start (MM/DD/YYYY)';
    const startInput = document.createElement('input');
    startInput.type = 'date';
    startDateGroup.appendChild(startLabel);
    startDateGroup.appendChild(startInput);
    filterRow.appendChild(startDateGroup);

    const endDateGroup = document.createElement('div');
    endDateGroup.className = 'a11y-pdf-filter-group';
    const endLabel = document.createElement('label');
    endLabel.textContent = 'End (MM/DD/YYYY)';
    const endInput = document.createElement('input');
    endInput.type = 'date';
    endDateGroup.appendChild(endLabel);
    endDateGroup.appendChild(endInput);
    filterRow.appendChild(endDateGroup);

    const analyzeBtn = document.createElement('button');
    analyzeBtn.type = 'button';
    analyzeBtn.className = 'a11y-btn-primary';
    analyzeBtn.textContent = 'Analyze PDFs';
    filterRow.appendChild(analyzeBtn);
    const cancelAnalyzeBtn = document.createElement('button');
    cancelAnalyzeBtn.type = 'button';
    cancelAnalyzeBtn.className = 'a11y-btn-secondary';
    cancelAnalyzeBtn.textContent = 'Cancel';
    cancelAnalyzeBtn.hidden = true;
    cancelAnalyzeBtn.disabled = true;
    filterRow.appendChild(cancelAnalyzeBtn);

    step2Section.appendChild(filterRow);
    analyzeDetails.appendChild(step2Section);

    const statusBox = document.createElement('div');
    statusBox.className = 'a11y-pdf-status';
    statusBox.textContent = 'No PDF run yet.';
    analyzeDetails.appendChild(statusBox);

    const logTitle = document.createElement('p');
    logTitle.className = 'a11y-quick-actions-note';
    logTitle.textContent = 'Run log';
    analyzeDetails.appendChild(logTitle);

    const logList = document.createElement('ul');
    logList.className = 'a11y-pdf-log';
    analyzeDetails.appendChild(logList);

    const resultsWrap = document.createElement('div');
    resultsWrap.className = 'a11y-pdf-results';
    const matchesSection = document.createElement('div');
    const matchesTitle = document.createElement('h3');
    matchesTitle.textContent = 'Matches';
    matchesSection.appendChild(matchesTitle);
    const matchesTableWrap = document.createElement('div');
    matchesTableWrap.className = 'a11y-pdf-table-wrap';
    matchesSection.appendChild(matchesTableWrap);
    resultsWrap.appendChild(matchesSection);

    const failuresSection = document.createElement('div');
    const failuresTitle = document.createElement('h3');
    failuresTitle.textContent = 'Failed';
    failuresSection.appendChild(failuresTitle);
    const failuresTableWrap = document.createElement('div');
    failuresTableWrap.className = 'a11y-pdf-table-wrap';
    failuresSection.appendChild(failuresTableWrap);
    resultsWrap.appendChild(failuresSection);
    analyzeDetails.appendChild(resultsWrap);
    wrapper.appendChild(analyzeDetails);

    function syncDateVisibility() {
      const mode = filterSelect.value;
      if (mode === 'between') {
        singleDateGroup.style.display = 'none';
        startDateGroup.style.display = '';
        endDateGroup.style.display = '';
      } else {
        singleDateGroup.style.display = '';
        startDateGroup.style.display = 'none';
        endDateGroup.style.display = 'none';
      }
    }
    syncDateVisibility();
    filterSelect.addEventListener('change', syncDateVisibility);

    function renderPdfTable(target, rows, columns, emptyMessage, options = {}) {
      target.innerHTML = '';
      if (!rows.length) {
        const empty = document.createElement('p');
        empty.className = 'a11y-quick-actions-note';
        empty.textContent = emptyMessage;
        target.appendChild(empty);
        return;
      }
      if (options.download) {
        const toolbar = document.createElement('div');
        toolbar.className = 'a11y-table-toolbar';
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'a11y-table-download-btn';
        btn.textContent = options.download.label || 'Export CSV';
        btn.addEventListener('click', () => {
          try {
            downloadObjectCsv(
              rows,
              options.download.columns,
              options.download.filenameBase || 'pdf-table'
            );
          } catch (err) {
            console.error(err);
            alert('Unable to export CSV.');
          }
        });
        toolbar.appendChild(btn);
        target.appendChild(toolbar);
      }
      const table = document.createElement('table');
      table.className = 'a11y-pdf-table';
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      columns.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col.label;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      rows.forEach(row => {
        const tr = document.createElement('tr');
        columns.forEach(col => {
          const td = document.createElement(col.isHeader ? 'th' : 'td');
          if (col.isHeader) td.setAttribute('scope','row');
          const value = col.get ? col.get(row) : row[col.key];
          if (col.render) {
            col.render(td, row);
          } else if (value instanceof Node) {
            td.appendChild(value);
          } else {
            td.textContent = value == null ? '' : String(value);
          }
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      target.appendChild(table);
    }

    const folderPickerSupported = typeof window.showDirectoryPicker === 'function';
    if (!folderPickerSupported) {
      chooseFolderBtn.disabled = true;
      folderStatus.textContent = 'Folder selection requires a Chromium-based browser (Chrome or Edge).';
    }

    triggerBtn.addEventListener('click', () => {
      triggerBtn.disabled = true;
      startPdfDownloadSequence().finally(() => {
        triggerBtn.disabled = false;
      });
    });

    chooseFolderBtn.addEventListener('click', async () => {
      if (!folderPickerSupported) return;
      chooseFolderBtn.disabled = true;
      try {
        await choosePdfAnalysisFolder();
      } finally {
        chooseFolderBtn.disabled = false;
      }
    });

    pdfInspectorState.render = () => {
      const downloadPhase = pdfInspectorState.downloadPhase || 'idle';
      let step1Message = 'Not started.';
      if (downloadPhase === 'collecting') {
        step1Message = 'Collecting PDF URLs…';
      } else if (downloadPhase === 'downloading') {
        const { completed, total } = pdfInspectorState.progress;
        step1Message = total
          ? `Triggered download ${completed}/${total}`
          : 'Triggering downloads…';
      } else if (downloadPhase === 'ready') {
        step1Message = 'Downloads triggered. Check your browser’s Downloads list before analyzing.';
      } else if (downloadPhase === 'error') {
        step1Message = pdfInspectorState.downloadErrorMessage || 'Unable to trigger downloads.';
      }
      downloadStatus.textContent = step1Message;
      if (pdfInspectorState.analysisFolderName) {
        folderStatus.textContent = `Selected folder for analysis: ${pdfInspectorState.analysisFolderName}`;
      } else if (folderPickerSupported) {
        folderStatus.textContent = 'No folder selected yet.';
      }
      if (pdfInspectorState.analysisError) {
        folderError.hidden = false;
        folderError.textContent = pdfInspectorState.analysisError;
      } else {
        folderError.hidden = true;
        folderError.textContent = '';
      }
      const analysisDisabled =
        pdfInspectorState.status === 'analyzing' ||
        pdfInspectorState.status === 'cancelling' ||
        !pdfInspectorState.analysisFolderHandle;
      analyzeBtn.disabled = analysisDisabled;
      cancelAnalyzeBtn.hidden =
        pdfInspectorState.status !== 'analyzing' &&
        pdfInspectorState.status !== 'cancelling';
      cancelAnalyzeBtn.disabled = pdfInspectorState.status !== 'analyzing';
      let statusMessage = '';
      if (pdfInspectorState.status === 'idle') {
        statusMessage = pdfInspectorState.analysisFolderHandle
          ? 'Choose your date filter and click Analyze PDFs.'
          : 'Select the folder that contains the PDFs you want to analyze.';
        if (pdfInspectorState.urls.length) {
          statusMessage += ` (${pdfInspectorState.urls.length} URL${pdfInspectorState.urls.length === 1 ? '' : 's'} collected from the table.)`;
        }
      } else if (pdfInspectorState.status === 'collecting' || pdfInspectorState.status === 'downloading') {
        statusMessage = 'Triggering downloads…';
      } else if (pdfInspectorState.status === 'ready') {
        statusMessage = 'Downloads triggered. Choose your folder and run the analysis when ready.';
      } else if (pdfInspectorState.status === 'analyzing') {
        const { completed, total } = pdfInspectorState.progress;
        const pct = total ? Math.round((completed / total) * 100) : 0;
        statusMessage = `Analyzing PDFs (${completed}/${total}) — ${pct}% complete.`;
      } else if (pdfInspectorState.status === 'cancelling') {
        statusMessage = 'Cancelling analysis…';
      } else if (pdfInspectorState.status === 'cancelled') {
        statusMessage = 'PDF analysis cancelled.';
      } else if (pdfInspectorState.status === 'completed') {
        statusMessage = `Finished. ${pdfInspectorState.matches.length} match(es), ${pdfInspectorState.failures.length} failure(s).`;
      } else if (pdfInspectorState.status === 'error') {
        statusMessage = pdfInspectorState.lastError || 'Unable to analyze PDFs.';
      }
      statusBox.textContent = statusMessage;

      logList.innerHTML = '';
      if (!pdfInspectorState.log.length) {
        const li = document.createElement('li');
        li.textContent = 'No log entries yet.';
        logList.appendChild(li);
      } else {
        pdfInspectorState.log.slice(0, 50).forEach(entry => {
          const li = document.createElement('li');
          li.textContent = `[${new Date(entry.timestamp).toLocaleTimeString()}] ${entry.message}`;
          if (entry.type && entry.type !== 'info') {
            li.dataset.status = entry.type;
          }
          logList.appendChild(li);
        });
      }

      const matchCount = pdfInspectorState.matches?.length || 0;
      const filterSuffix = pdfInspectorState.filter ? ` – ${formatFilterShort(pdfInspectorState.filter)}` : '';
      matchesTitle.textContent = `Matches (${matchCount})${filterSuffix}`;
      const matchColumns = [
        {
          label: 'File or URL',
          render(cell, row) {
            const value = row.url || row.filename || '';
            if (/^https?:/i.test(value)) {
              const link = document.createElement('a');
              link.href = value;
              link.target = '_blank';
              link.rel = 'noopener';
              link.textContent = value;
              cell.appendChild(link);
            } else {
              cell.textContent = value || '—';
            }
          }
        },
        {
          label: 'Modified Date',
          get: row => formatPdfDateDisplay(row.date)
        },
        {
          label: 'Metadata Field',
          get: row => row.source || 'Unknown'
        },
        {
          label: 'Saved File',
          get: row => row.filename || '—'
        }
      ];
      const matchDownloadColumns = [
        {
          key: 'url',
          label: 'File or URL',
          format: (value, row) => row.url || row.filename || ''
        },
        {
          key: 'date',
          label: 'Modified Date',
          format: value => formatPdfDateDisplay(value)
        },
        { key: 'source', label: 'Metadata Field' },
        { key: 'filename', label: 'Saved File' }
      ];
      renderPdfTable(
        matchesTableWrap,
        pdfInspectorState.matches || [],
        matchColumns,
        'No matches yet.',
        {
          download: {
            label: 'Export matches CSV',
            filenameBase: 'pdf-inspector-matches',
            columns: matchDownloadColumns
          }
        }
      );

      const failureCount = pdfInspectorState.failures?.length || 0;
      failuresTitle.textContent = `Failed (${failureCount})`;
      const failureColumns = [
        {
          label: 'File or URL',
          render(cell, row) {
            cell.textContent = row.url || row.filename || '—';
          }
        },
        {
          label: 'Reason',
          get: row => row.reason || 'Unknown'
        }
      ];
      const failureDownloadColumns = [
        {
          key: 'url',
          label: 'File or URL',
          format: (value, row) => row.url || row.filename || '—'
        },
        {
          key: 'reason',
          label: 'Reason',
          format: value => value || 'Unknown'
        }
      ];
      renderPdfTable(
        failuresTableWrap,
        pdfInspectorState.failures || [],
        failureColumns,
        'No failures.',
        {
          download: {
            label: 'Export failures CSV',
            filenameBase: 'pdf-inspector-failures',
            columns: failureDownloadColumns
          }
        }
      );
    };
    pdfInspectorState.render();

    analyzeBtn.addEventListener('click', () => {
      const mode = filterSelect.value;
      let startDate = null;
      let endDate = null;
      if (mode === 'between') {
        startDate = parseUserDateInput(startInput.value);
        endDate = parseUserDateInput(endInput.value);
        if (!startDate || !endDate) {
          alert('Enter valid start and end dates (MM/DD/YYYY).');
          return;
        }
        if (endDate.getTime() < startDate.getTime()) {
          const temp = startDate;
          startDate = endDate;
          endDate = temp;
        }
      } else {
        startDate = parseUserDateInput(singleInput.value);
        if (!startDate) {
          alert('Enter a valid date (MM/DD/YYYY).');
          return;
        }
      }
      const filter = mode === 'between' ? { mode, start: startDate, end: endDate } : { mode, start: startDate };
      startPdfAnalysis(filter).catch(err => {
        alert(err?.message || 'Unable to analyze PDFs.');
      });
    });
    cancelAnalyzeBtn.addEventListener('click', () => {
      cancelPdfAnalysis();
    });

    return wrapper;
  }

  function buildMatchPdfFilesSection() {
    if (pageContext !== 'pages') return null;
    const container = document.createElement('div');
    const details = document.createElement('details');
    details.open = true;
    const summary = document.createElement('summary');
    const h2 = document.createElement('h2');
    h2.textContent = 'Match PDF Files with results URLs';
    summary.appendChild(h2);
    details.appendChild(summary);

    const intro = document.createElement('p');
    intro.className = 'a11y-quick-actions-note';
    intro.textContent = 'Select a folder of downloaded PDFs and compare each filename with the Page URLs listed in Monitor.';
    details.appendChild(intro);

    const controls = document.createElement('div');
    controls.className = 'a11y-pdf-filter';
    const chooseBtn = document.createElement('button');
    chooseBtn.type = 'button';
    chooseBtn.className = 'a11y-btn-primary';
    chooseBtn.textContent = 'Choose PDF folder';
    const folderStatus = document.createElement('span');
    folderStatus.className = 'a11y-quick-actions-note';
    folderStatus.textContent = 'No folder selected yet.';
    controls.appendChild(chooseBtn);
    controls.appendChild(folderStatus);
    details.appendChild(controls);

    const folderError = document.createElement('p');
    folderError.className = 'a11y-quick-actions-error';
    folderError.hidden = true;
    details.appendChild(folderError);

    const matchBtn = document.createElement('button');
    matchBtn.type = 'button';
    matchBtn.className = 'a11y-btn-primary';
    matchBtn.textContent = 'Match files with Page URLs';
    details.appendChild(matchBtn);

    const statusText = document.createElement('p');
    statusText.className = 'a11y-quick-actions-note';
    statusText.textContent = 'No match run yet.';
    details.appendChild(statusText);

    const resultsWrap = document.createElement('div');
    resultsWrap.className = 'a11y-pdf-results';

    const matchesSection = document.createElement('div');
    const matchesTitle = document.createElement('h3');
    matchesTitle.textContent = 'Matches (0)';
    matchesSection.appendChild(matchesTitle);
    const matchesTableWrap = document.createElement('div');
    matchesTableWrap.className = 'a11y-pdf-table-wrap';
    matchesSection.appendChild(matchesTableWrap);
    resultsWrap.appendChild(matchesSection);

    const unmatchedSection = document.createElement('div');
    const unmatchedTitle = document.createElement('h3');
    unmatchedTitle.textContent = 'No Match (0)';
    unmatchedSection.appendChild(unmatchedTitle);
    const unmatchedTableWrap = document.createElement('div');
    unmatchedTableWrap.className = 'a11y-pdf-table-wrap';
    unmatchedSection.appendChild(unmatchedTableWrap);
    resultsWrap.appendChild(unmatchedSection);

    details.appendChild(resultsWrap);

    const renderTable = (wrap, rows, columns, emptyMessage) => {
      wrap.innerHTML = '';
      if (!rows.length) {
        const empty = document.createElement('p');
        empty.className = 'a11y-quick-actions-note';
        empty.textContent = emptyMessage;
        wrap.appendChild(empty);
        return;
      }
      const table = document.createElement('table');
      table.className = 'a11y-pdf-table';
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      columns.forEach(col => {
        const th = document.createElement('th');
        th.textContent = col;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      rows.forEach(row => {
        const tr = document.createElement('tr');
        row.forEach((value, idx) => {
          const cell = document.createElement(idx === 0 ? 'th' : 'td');
          if (idx === 0) cell.setAttribute('scope','row');
          if (value instanceof Node) {
            cell.appendChild(value);
          } else {
            cell.textContent = value == null ? '' : String(value);
          }
          tr.appendChild(cell);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      wrap.appendChild(table);
    };

    const render = () => {
      folderStatus.textContent = pdfMatchState.folderName
        ? `Selected folder: ${pdfMatchState.folderName}`
        : 'No folder selected yet.';
      const busy = pdfMatchState.status === 'matching';
      const disableMatch = busy || !pdfMatchState.folderHandle || !folderPickerSupported;
      matchBtn.disabled = disableMatch;
      folderError.hidden = !pdfMatchState.lastError;
      folderError.textContent = pdfMatchState.lastError || '';
      let statusMessage = '';
      if (pdfMatchState.status === 'matching') {
        statusMessage = 'Matching files…';
      } else if (pdfMatchState.status === 'completed') {
        statusMessage = `Matched ${pdfMatchState.matches.length} of ${pdfMatchState.urlCount || '?'} PDF URLs.`;
      } else if (pdfMatchState.status === 'error') {
        statusMessage = pdfMatchState.lastError || 'Unable to match PDFs.';
      } else {
        statusMessage = 'Pick a folder and click “Match files with Page URLs”.';
      }
      statusText.textContent = statusMessage;

      matchesTitle.textContent = `Matches (${pdfMatchState.matches.length})`;
      if (!pdfMatchState.matches.length) {
        renderTable(matchesTableWrap, [], [], 'No matches yet.');
      } else {
        const rows = pdfMatchState.matches.map(entry => {
          const link = document.createElement('a');
          link.href = entry.url;
          link.target = '_blank';
          link.rel = 'noopener';
          link.textContent = entry.url;
          return [entry.filename, link];
        });
        renderTable(matchesTableWrap, rows, ['File name','Matching URL'], 'No matches yet.');
      }

      unmatchedTitle.textContent = `No Match (${pdfMatchState.unmatched.length})`;
      if (!pdfMatchState.unmatched.length) {
        renderTable(unmatchedTableWrap, [], [], 'All files matched to a URL.');
      } else {
        const rows = pdfMatchState.unmatched.map(name => [name]);
        renderTable(unmatchedTableWrap, rows, ['File name'], 'All files matched to a URL.');
      }
    };

    pdfMatchState.render = render;
    render();

    const folderPickerSupported = typeof window.showDirectoryPicker === 'function';
    if (!folderPickerSupported) {
      chooseBtn.disabled = true;
      folderStatus.textContent = 'Folder selection requires a Chromium-based browser (Chrome or Edge).';
    }

    chooseBtn.addEventListener('click', () => {
      if (!folderPickerSupported) return;
      choosePdfMatchFolder();
    });
    matchBtn.addEventListener('click', () => {
      matchPdfFilesWithUrls();
    });

    container.appendChild(details);

    const manualDetails = document.createElement('details');
    manualDetails.open = true;
    const manualSummary = document.createElement('summary');
    const manualHeading = document.createElement('h2');
    manualHeading.textContent = 'Match PDF Files with PDF file list';
    manualSummary.appendChild(manualHeading);
    manualDetails.appendChild(manualSummary);

    const manualIntro = document.createElement('p');
    manualIntro.className = 'a11y-quick-actions-note';
    manualIntro.textContent = 'Paste PDF filenames (one per line) and match them against the PDF URLs listed in the current Pages table.';
    manualDetails.appendChild(manualIntro);

    const manualEditor = document.createElement('div');
    manualEditor.className = 'a11y-pages-editor';
    const manualGutter = document.createElement('div');
    manualGutter.className = 'a11y-pages-editor-gutter';
    manualEditor.appendChild(manualGutter);
    const manualTextarea = document.createElement('textarea');
    manualTextarea.className = 'a11y-pages-editor-input';
    manualTextarea.placeholder = 'example-file.pdf';
    manualTextarea.wrap = 'off';
    manualTextarea.spellcheck = false;
    manualEditor.appendChild(manualTextarea);
    manualDetails.appendChild(manualEditor);

    const manualActions = document.createElement('div');
    manualActions.className = 'a11y-copy-urls-actions';
    const manualMatchBtn = document.createElement('button');
    manualMatchBtn.type = 'button';
    manualMatchBtn.className = 'a11y-btn-primary';
    manualMatchBtn.textContent = 'Match list';
    const manualStatus = document.createElement('span');
    manualStatus.className = 'a11y-quick-actions-note';
    manualStatus.textContent = 'No list submitted yet.';
    manualActions.appendChild(manualMatchBtn);
    manualActions.appendChild(manualStatus);
    manualDetails.appendChild(manualActions);

    const manualResultsWrap = document.createElement('div');
    manualResultsWrap.className = 'a11y-pdf-results';
    const manualMatchesSection = document.createElement('div');
    const manualMatchesTitle = document.createElement('h3');
    manualMatchesTitle.textContent = 'Matches (0)';
    manualMatchesSection.appendChild(manualMatchesTitle);
    const manualMatchesToolbar = document.createElement('div');
    manualMatchesToolbar.className = 'a11y-table-toolbar';
    const manualMatchesCsvBtn = document.createElement('button');
    manualMatchesCsvBtn.type = 'button';
    manualMatchesCsvBtn.className = 'a11y-table-download-btn';
    manualMatchesCsvBtn.textContent = 'Download CSV';
    manualMatchesCsvBtn.disabled = true;
    manualMatchesToolbar.appendChild(manualMatchesCsvBtn);
    const manualMatchesCopyBtn = document.createElement('button');
    manualMatchesCopyBtn.type = 'button';
    manualMatchesCopyBtn.className = 'a11y-table-download-btn';
    manualMatchesCopyBtn.textContent = 'Copy URLs';
    manualMatchesCopyBtn.disabled = true;
    manualMatchesToolbar.appendChild(manualMatchesCopyBtn);
    manualMatchesSection.appendChild(manualMatchesToolbar);
    const manualMatchesTableWrap = document.createElement('div');
    manualMatchesTableWrap.className = 'a11y-pdf-table-wrap';
    manualMatchesSection.appendChild(manualMatchesTableWrap);
    manualResultsWrap.appendChild(manualMatchesSection);

    const manualUnmatchedSection = document.createElement('div');
    const manualUnmatchedTitle = document.createElement('h3');
    manualUnmatchedTitle.textContent = 'No Match (0)';
    manualUnmatchedSection.appendChild(manualUnmatchedTitle);
    const manualUnmatchedToolbar = document.createElement('div');
    manualUnmatchedToolbar.className = 'a11y-table-toolbar';
    const manualUnmatchedCsvBtn = document.createElement('button');
    manualUnmatchedCsvBtn.type = 'button';
    manualUnmatchedCsvBtn.className = 'a11y-table-download-btn';
    manualUnmatchedCsvBtn.textContent = 'Download CSV';
    manualUnmatchedCsvBtn.disabled = true;
    manualUnmatchedToolbar.appendChild(manualUnmatchedCsvBtn);
    const manualUnmatchedCopyBtn = document.createElement('button');
    manualUnmatchedCopyBtn.type = 'button';
    manualUnmatchedCopyBtn.className = 'a11y-table-download-btn';
    manualUnmatchedCopyBtn.textContent = 'Copy URLs';
    manualUnmatchedCopyBtn.setAttribute('aria-label','Copy unmatched entries to clipboard');
    manualUnmatchedCopyBtn.disabled = true;
    manualUnmatchedToolbar.appendChild(manualUnmatchedCopyBtn);
    manualUnmatchedSection.appendChild(manualUnmatchedToolbar);
    const manualUnmatchedTableWrap = document.createElement('div');
    manualUnmatchedTableWrap.className = 'a11y-pdf-table-wrap';
    manualUnmatchedSection.appendChild(manualUnmatchedTableWrap);
    manualResultsWrap.appendChild(manualUnmatchedSection);
    manualDetails.appendChild(manualResultsWrap);

    const manualState = {
      status: 'idle',
      matches: [],
      unmatched: [],
      urlCount: 0,
      lastError: ''
    };

    manualMatchesCsvBtn.addEventListener('click', () => {
      if (!manualState.matches.length) {
        alert('No matches to export yet.');
        return;
      }
      try {
        downloadObjectCsv(
          manualState.matches,
          [
            { key: 'filename', label: 'File name' },
            { key: 'url', label: 'Matching URL' }
          ],
          'pdf-file-list-matches'
        );
      } catch (err) {
        console.error(err);
        alert('Unable to export matches.');
      }
    });
    manualMatchesCopyBtn.addEventListener('click', async () => {
      const urls = manualState.matches.map(entry => entry.url).filter(Boolean);
      if (!urls.length) {
        alert('No URLs available to copy yet.');
        return;
      }
      try {
        const success = await writeTextToClipboard(urls.join('\n'));
        if (success) {
          alert('Copied match URLs to clipboard.');
        } else {
          alert('Unable to use the clipboard. Copy the URLs manually.');
        }
      } catch (err) {
        alert(err?.message || 'Unable to copy to clipboard.');
      }
    });
    manualUnmatchedCsvBtn.addEventListener('click', () => {
      if (!manualState.unmatched.length) {
        alert('No unmatched entries to export yet.');
        return;
      }
      try {
        const rows = manualState.unmatched.map(name => ({ filename: name }));
        downloadObjectCsv(
          rows,
          [{ key: 'filename', label: 'File name' }],
          'pdf-file-list-unmatched'
        );
      } catch (err) {
        console.error(err);
        alert('Unable to export unmatched entries.');
      }
    });
    manualUnmatchedCopyBtn.addEventListener('click', async () => {
      if (!manualState.unmatched.length) {
        alert('No unmatched entries to copy.');
        return;
      }
      try {
        const success = await writeTextToClipboard(manualState.unmatched.join('\n'));
        if (success) {
          alert('Copied unmatched entries to clipboard.');
        } else {
          alert('Unable to use the clipboard. Copy the entries manually.');
        }
      } catch (err) {
        alert(err?.message || 'Unable to copy to clipboard.');
      }
    });

    function updateManualLineNumbers() {
      const lines = manualTextarea.value.split('\n').length || 1;
      const styles = window.getComputedStyle(manualTextarea);
      const parsedLineHeight = parseFloat(styles.lineHeight);
      const parsedFontSize = parseFloat(styles.fontSize);
      const resolvedLineHeight = Number.isFinite(parsedLineHeight)
        ? parsedLineHeight
        : Number.isFinite(parsedFontSize)
          ? parsedFontSize * 1.4
          : 18;
      manualGutter.style.lineHeight = styles.lineHeight;
      manualGutter.style.fontSize = styles.fontSize;
      manualGutter.style.fontFamily = styles.fontFamily;
      manualGutter.innerHTML = '';
      for (let i = 1; i <= lines; i++) {
        const line = document.createElement('div');
        line.textContent = i;
        line.style.height = `${resolvedLineHeight}px`;
        line.style.lineHeight = `${resolvedLineHeight}px`;
        manualGutter.appendChild(line);
      }
    }
    manualTextarea.addEventListener('input', () => {
      updateManualLineNumbers();
      manualGutter.scrollTop = manualTextarea.scrollTop;
    });
    manualTextarea.addEventListener('scroll', () => {
      manualGutter.scrollTop = manualTextarea.scrollTop;
    });
    updateManualLineNumbers();

    function parseManualEntries() {
      return manualTextarea.value
        .split(/\r?\n/)
        .map(line => line.trim())
        .filter(Boolean);
    }

    function renderManualState() {
      if (manualState.status === 'matching') {
        manualStatus.textContent = 'Matching…';
      } else if (manualState.status === 'completed') {
        manualStatus.textContent = `Matched ${manualState.matches.length} of ${manualState.urlCount || '?'} PDF URLs.`;
      } else if (manualState.status === 'error') {
        manualStatus.textContent = manualState.lastError || 'Unable to match PDFs.';
      } else {
        manualStatus.textContent = 'No list submitted yet.';
      }
      manualMatchBtn.disabled = manualState.status === 'matching';
      manualMatchesTitle.textContent = `Matches (${manualState.matches.length})`;
      manualUnmatchedTitle.textContent = `No Match (${manualState.unmatched.length})`;
      const hasMatches = manualState.matches.length > 0;
      const hasCopyableMatches = manualState.matches.some(entry => !!entry.url);
      manualMatchesCsvBtn.disabled = !hasMatches;
      manualMatchesCopyBtn.disabled = !hasCopyableMatches;
      const hasUnmatched = manualState.unmatched.length > 0;
      manualUnmatchedCsvBtn.disabled = !hasUnmatched;
      manualUnmatchedCopyBtn.disabled = !hasUnmatched;
      const manualMatchRows = manualState.matches.map(entry => {
        const link = document.createElement('a');
        link.href = entry.url;
        link.target = '_blank';
        link.rel = 'noopener';
        link.textContent = entry.url;
        return [entry.filename, link];
      });
      renderTable(
        manualMatchesTableWrap,
        manualMatchRows,
        ['File name','Matching URL'],
        'No matches yet.'
      );
      const manualUnmatchedRows = manualState.unmatched.map(name => [name]);
      renderTable(
        manualUnmatchedTableWrap,
        manualUnmatchedRows,
        ['File name'],
        'All file names matched to a URL.'
      );
    }
    renderManualState();

    async function matchManualList() {
      const entries = parseManualEntries();
      if (!entries.length) {
        manualState.status = 'error';
        manualState.lastError = 'Enter at least one PDF filename.';
        manualState.matches = [];
        manualState.unmatched = [];
        renderManualState();
        return;
      }
      manualState.status = 'matching';
      manualState.lastError = '';
      manualState.matches = [];
      manualState.unmatched = [];
      renderManualState();
      try {
        const urls = await collectAllPageUrls();
        const pdfUrls = filterPdfUrls(urls);
        if (!pdfUrls.length) {
          throw new Error('No PDF URLs found in the current table.');
        }
        manualState.urlCount = pdfUrls.length;
        const urlMap = new Map();
        pdfUrls.forEach(url => {
          const key = getUrlMatchKey(url);
          if (!key) return;
          if (!urlMap.has(key)) urlMap.set(key, []);
          urlMap.get(key).push(url);
        });
        const matches = [];
        const unmatched = [];
        entries.forEach(name => {
          const matchKey = getFileMatchKey(name);
          if (matchKey && urlMap.has(matchKey) && urlMap.get(matchKey).length) {
            const matchedUrl = urlMap.get(matchKey).shift();
            matches.push({ filename: name, url: matchedUrl });
          } else {
            unmatched.push(name);
          }
        });
        manualState.matches = matches;
        manualState.unmatched = unmatched;
        manualState.status = 'completed';
      } catch (err) {
        manualState.status = 'error';
        manualState.lastError = err?.message || 'Unable to match PDFs.';
      } finally {
        renderManualState();
      }
    }

    manualMatchBtn.addEventListener('click', () => {
      if (manualState.status === 'matching') return;
      matchManualList();
    });

    container.appendChild(manualDetails);
    return container;
  }

  function buildPageAutomationSection(config) {
    if (pageContext !== 'issues') return null;
    const {
      id,
      title,
      introText,
      automationNote,
      storagePrefix,
      runStateStorageKey,
      requiresTargetSelection = false,
      targetSelectId,
      targetLabel,
      targetOptionsLoader,
      targetHint,
      runButtonLabel,
      busyButtonLabel,
      logActionVerb,
      successPastTense,
      bulkActionMatcher,
      applyButtonKeyword,
      logLabel = 'Run log',
      afterBulkActionSelected
    } = config;

    const actionVerb = (logActionVerb || 'Run').trim();
    const actionProgress = config.actionProgress || (actionVerb.endsWith('e') ? `${actionVerb.slice(0, -1)}ing` : `${actionVerb}ing`);
    const completedVerb = successPastTense || 'Completed';
    const idleButtonLabel = runButtonLabel || 'Run';
    const activeButtonLabel = busyButtonLabel || `${actionProgress}…`;
    const applyKeyword = (applyButtonKeyword || actionVerb).toLowerCase();

    const details = document.createElement('details');
    const summary = document.createElement('summary');
    const h2 = document.createElement('h2');
    h2.textContent = title;
    summary.appendChild(h2);
    details.appendChild(summary);

    const container = document.createElement('div');
    container.className = 'a11y-quick-actions-container';

    const intro = document.createElement('p');
    intro.className = 'a11y-quick-actions-intro';
    intro.textContent = introText;
    container.appendChild(intro);

    if (automationNote) {
      const infoNote = document.createElement('p');
      infoNote.className = 'a11y-quick-actions-note';
      infoNote.textContent = automationNote;
      container.appendChild(infoNote);
    }

    const btnRow = document.createElement('div');
    btnRow.className = 'a11y-quick-actions-btn-row';
    const addBtn = document.createElement('button');
    addBtn.type = 'button';
    addBtn.className = 'a11y-btn-primary';
    addBtn.textContent = 'Add pages';
    btnRow.appendChild(addBtn);
    const savedChip = document.createElement('span');
    savedChip.className = 'a11y-quick-actions-chip';
    btnRow.appendChild(savedChip);
    const clearBtn = document.createElement('button');
    clearBtn.type = 'button';
    clearBtn.className = 'a11y-btn-secondary';
    clearBtn.textContent = 'Clear saved pages';
    btnRow.appendChild(clearBtn);
    container.appendChild(btnRow);

    const savedList = document.createElement('ol');
    savedList.className = 'a11y-quick-actions-saved';
    container.appendChild(savedList);

    let targetSelect = null;
    const syncTargetSelectionFromState = () => {
      if (!targetSelect || !activeRunState?.target?.value) return;
      const targetValue = activeRunState.target.value;
      const optionExists = Array.from(targetSelect.options || []).some(opt => opt.value === targetValue);
      if (optionExists) {
        targetSelect.value = targetValue;
      }
    };
    const hasPendingEntries = state =>
      !!state && Array.isArray(state.queue) && state.currentIndex < state.queue.length;

    if (requiresTargetSelection) {
      const selectWrap = document.createElement('div');
      selectWrap.className = 'a11y-quick-actions-select-wrap';
      const label = document.createElement('label');
      label.textContent = targetLabel || 'Select option';
      if (targetSelectId) label.setAttribute('for', targetSelectId);
      targetSelect = document.createElement('select');
      if (targetSelectId) targetSelect.id = targetSelectId;
      targetSelect.disabled = true;
      targetSelect.innerHTML = '<option value="">Loading…</option>';
      selectWrap.appendChild(label);
      selectWrap.appendChild(targetSelect);
      container.appendChild(selectWrap);
      if (targetHint) {
        const hint = document.createElement('p');
        hint.className = 'a11y-quick-actions-note';
        hint.textContent = targetHint;
        container.appendChild(hint);
      }
    }

    const actionsRow = document.createElement('div');
    actionsRow.className = 'a11y-quick-actions-btn-row';
    const runBtn = document.createElement('button');
    runBtn.type = 'button';
    runBtn.className = 'a11y-btn-primary';
    runBtn.textContent = idleButtonLabel;
    runBtn.disabled = true;
    actionsRow.appendChild(runBtn);
    const cancelRunBtn = document.createElement('button');
    cancelRunBtn.type = 'button';
    cancelRunBtn.className = 'a11y-btn-secondary';
    cancelRunBtn.textContent = 'Cancel run';
    cancelRunBtn.hidden = true;
    actionsRow.appendChild(cancelRunBtn);
    container.appendChild(actionsRow);

    const logDetails = document.createElement('details');
    logDetails.className = 'a11y-quick-actions-log';
    const logSummary = document.createElement('summary');
    const logTitle = document.createElement('span');
    logTitle.textContent = logLabel;
    logSummary.appendChild(logTitle);
    const summaryText = document.createElement('span');
    summaryText.className = 'a11y-quick-actions-summary';
    summaryText.textContent = 'No runs yet';
    logSummary.appendChild(summaryText);
    logDetails.appendChild(logSummary);
    const statusRegion = document.createElement('div');
    statusRegion.className = 'a11y-quick-actions-status';
    const statusList = document.createElement('ul');
    statusRegion.appendChild(statusList);
    logDetails.appendChild(statusRegion);
    container.appendChild(logDetails);

    details.appendChild(container);

    const syncLogLiveRegion = () => {
      if (logDetails.open) {
        statusRegion.setAttribute('aria-live','polite');
      } else {
        statusRegion.removeAttribute('aria-live');
      }
    };
    logDetails.addEventListener('toggle', syncLogLiveRegion);
    syncLogLiveRegion();

    const storageKey = () => getQuickActionStorageKey(storagePrefix);
    let savedEntriesCache = null;
    const loadSavedEntries = () => {
      if (savedEntriesCache) return savedEntriesCache.slice();
      try {
        const raw = localStorage.getItem(storageKey());
        const parsed = raw ? JSON.parse(raw) : [];
        savedEntriesCache = Array.isArray(parsed) ? parsed.filter(Boolean) : [];
      } catch (err) {
        console.warn('Quick Actions: unable to read saved pages', err);
        savedEntriesCache = [];
      }
      return savedEntriesCache.slice();
    };

    const saveSavedEntries = entries => {
      savedEntriesCache = entries.slice();
      try {
        localStorage.setItem(storageKey(), JSON.stringify(savedEntriesCache));
      } catch (err) {
        console.warn('Quick Actions: unable to save pages', err);
      }
    };

    const clearSavedEntries = () => {
      savedEntriesCache = [];
      try {
        localStorage.removeItem(storageKey());
      } catch (err) {
        console.warn('Quick Actions: unable to clear saved pages', err);
      }
    };

    const loadStoredRunState = () => {
      try {
        const raw = localStorage.getItem(runStateStorageKey);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : null;
      } catch (err) {
        console.warn('Quick Actions: unable to read run state', err);
        return null;
      }
    };

    const writeRunStateToStorage = state => {
      if (!state) {
        try {
          localStorage.removeItem(runStateStorageKey);
        } catch (err) {
          console.warn('Quick Actions: unable to clear run state', err);
        }
        return;
      }
      try {
        localStorage.setItem(runStateStorageKey, JSON.stringify(state));
      } catch (err) {
        console.warn('Quick Actions: unable to persist run state', err);
      }
    };

    let optionsLoaded = !requiresTargetSelection;
    let activeRunState = null;
    let resumeRunInFlight = false;

    const runStatusesInFlight = new Set(['pending','navigating','applying','cleanup']);
    const isRunActive = state => !!state && runStatusesInFlight.has(state.status);

    const waitBeforeStep = async label => {
      if (!quickActionsStepDelayMs) return;
      logQuickActions('waitBeforeQuickActionsStep', { id, label, delay: quickActionsStepDelayMs });
      await wait(quickActionsStepDelayMs);
    };

    const logStatus = (message, type = 'info') => {
      const li = document.createElement('li');
      li.textContent = message;
      if (type !== 'info') li.dataset.status = type;
      statusList.prepend(li);
    };

    const renderSavedLogs = state => {
      statusList.innerHTML = '';
      if (!state || !Array.isArray(state.logs)) return;
      state.logs.forEach(entry => {
        const li = document.createElement('li');
        li.textContent = entry.message;
        if (entry.type && entry.type !== 'info') li.dataset.status = entry.type;
        statusList.appendChild(li);
      });
    };

    const formatRunSummary = state => {
      if (!state || !Array.isArray(state.queue) || !state.queue.length) return 'No runs yet';
      const total = state.queue.length;
      const stats = state.stats || { success: 0, skipped: 0, failed: 0 };
      const completedFromStats = (stats.success || 0) + (stats.skipped || 0) + (stats.failed || 0);
      const cursor = Number.isFinite(state.currentIndex) ? state.currentIndex : 0;
      const processed = Math.min(Math.max(cursor, completedFromStats), total);
      return `${processed}/${total} processed — Success: ${stats.success || 0}, Skipped: ${stats.skipped || 0}, Failed: ${stats.failed || 0}`;
    };

    const setSummary = text => {
      summaryText.textContent = text || 'No runs yet';
      if (activeRunState) {
        activeRunState.summary = text || '';
        persistRunState();
      }
    };

    const persistRunState = () => {
      if (activeRunState) {
        activeRunState.updatedAt = Date.now();
        writeRunStateToStorage(activeRunState);
      } else {
        writeRunStateToStorage(null);
      }
    };

    const setActiveRunState = state => {
      activeRunState = state;
      persistRunState();
      syncRunButtonState();
    };

    const logRunStatus = (state, message, type = 'info') => {
      logStatus(message, type);
      if (!state) return;
      state.logs = Array.isArray(state.logs) ? state.logs : [];
      state.logs.push({ message, type, timestamp: Date.now() });
      persistRunState();
    };

    const logOutcomeBreakdown = state => {
      if (!state) return;
      const results = Array.isArray(state.results) ? state.results : [];
      if (!results.length) return;
      const buckets = { skipped: [], failed: [] };
      results.forEach(entry => {
        const label = formatEntryLabel(entry?.entry);
        if (entry?.outcome === 'skipped') buckets.skipped.push(label);
        if (entry?.outcome === 'failed') buckets.failed.push(label);
      });
      if (buckets.skipped.length) {
        logRunStatus(state, `Skipped (${buckets.skipped.length}): ${buckets.skipped.join(', ')}`, 'info');
      }
      if (buckets.failed.length) {
        logRunStatus(state, `Failed (${buckets.failed.length}): ${buckets.failed.join(', ')}`, 'error');
      }
    };

    const updateSavedDisplay = () => {
      const saved = loadSavedEntries();
      savedChip.textContent = saved.length ? `${saved.length} saved` : 'No pages saved yet';
      clearBtn.hidden = saved.length === 0;
      savedList.innerHTML = '';
      if (!saved.length) {
        const item = document.createElement('li');
        item.textContent = 'Add pages to get started. Each line becomes an individual filter run.';
        savedList.appendChild(item);
      } else {
        const limit = 5;
        saved.slice(0, limit).forEach(value => {
          const li = document.createElement('li');
          const code = document.createElement('code');
          code.textContent = value;
          li.appendChild(code);
          savedList.appendChild(li);
        });
        if (saved.length > limit) {
          const li = document.createElement('li');
          li.textContent = `+${saved.length - limit} more`;
          savedList.appendChild(li);
        }
      }
      syncRunButtonState();
    };

    const syncRunButtonState = () => {
      const saved = loadSavedEntries();
      const hasPages = saved.length > 0 || hasPendingEntries(activeRunState);
      const runActive = isRunActive(activeRunState);
      const isPaused = !runActive && hasPendingEntries(activeRunState) && activeRunState?.status === 'paused';
      const hasTarget = !requiresTargetSelection || !!(targetSelect && targetSelect.value) || isPaused;
      runBtn.disabled = runActive || !hasPages || !hasTarget;
      runBtn.textContent = runActive
        ? activeButtonLabel
        : isPaused
          ? `Resume ${actionVerb}`
          : idleButtonLabel;
      cancelRunBtn.hidden = !runActive;
      cancelRunBtn.disabled = !runActive;
    };

    const formatEntryLabel = entry => entry || '(entry)';

    const ensureRunStateShape = state => {
      if (!state || typeof state !== 'object') return null;
      if (!Array.isArray(state.queue)) return null;
      state.logs = Array.isArray(state.logs) ? state.logs : [];
      state.stats = state.stats && typeof state.stats === 'object'
        ? { success: state.stats.success || 0, skipped: state.stats.skipped || 0, failed: state.stats.failed || 0 }
        : { success: 0, skipped: 0, failed: 0 };
      state.results = Array.isArray(state.results) ? state.results : [];
      state.currentIndex = Number.isFinite(state.currentIndex) ? state.currentIndex : 0;
      state.currentIndex = Math.max(0, Math.min(state.currentIndex, state.queue.length));
      state.status = state.status || 'pending';
      if (state.target) {
        state.target = {
          value: state.target.value || '',
          label: state.target.label || '',
          labelLower: (state.target.labelLower || state.target.label || '').toLowerCase()
        };
      }
      return state;
    };

    const handleEntryResult = (state, entryValue, outcome, note, { fatal = false } = {}) => {
      if (!state) return 'stop';
      const statsKey = outcome === 'success' ? 'success' : outcome === 'skipped' ? 'skipped' : 'failed';
      state.stats[statsKey] = (state.stats[statsKey] || 0) + 1;
      state.results.push({ entry: entryValue, outcome, note, timestamp: Date.now() });
      persistRunState();
      setSummary(formatRunSummary(state));
      if (fatal) {
        state.status = 'error';
        persistRunState();
        logRunStatus(state, note || 'Run stopped.', 'error');
        logOutcomeBreakdown(state);
        setActiveRunState(null);
        return 'stop';
      }
      state.currentIndex += 1;
      persistRunState();
      if (state.currentIndex >= state.queue.length) {
        state.status = 'cleanup';
        persistRunState();
        logRunStatus(state, 'All entries processed. Removing filters…', 'success');
        return 'cleanup';
      }
      state.status = 'pending';
      persistRunState();
      return 'next';
    };

    const applyFilterForEntry = async (state, entryValue) => {
      if (!state) return false;
      const label = formatEntryLabel(entryValue);
      const normalized = normalizeFilterValue(entryValue) || '';
      try {
        state.status = 'navigating';
        persistRunState();
        logRunStatus(state, `Applying Page URL filter for ${label}…`);
        await waitBeforeStep('apply-filter');
        await applyIssuesPageUrlFilter(normalized, { matchType: 'contains' });
        state.currentFilterValue = normalized;
        persistRunState();
        return true;
      } catch (err) {
        const message = err?.message || 'Unable to set Page URL filter.';
        logRunStatus(state, `${message} (${label})`, 'error');
        handleEntryResult(state, entryValue, 'failed', message, { fatal: true });
        return false;
      }
    };

    const clearRunFilters = async () => {
      try {
        await clearIssuesPageUrlFilter();
      } catch (err) {
        logQuickActions(`${id || 'QuickActions'}: unable to clear Page URL filter`, err);
      }
      try {
        await clearAllIssuesFilters();
      } catch (err) {
        logQuickActions(`${id || 'QuickActions'}: unable to clear all filters`, err);
      }
    };

    const runBulkActionForCurrentFilter = async (state, entryValue) => {
      const label = formatEntryLabel(entryValue);
      try {
        logRunStatus(state, `${actionProgress} issues for ${label}…`);
        await waitBeforeStep('before-action');
        await ensureIssuesViewByPage();
        await ensureSelectAllUnchecked().catch(() => {});
        const matchingCount = await getMatchingIssuesCount().catch(() => null);
        if (matchingCount === 0) {
          logRunStatus(state, `No matching issues for ${label}; skipping.`, 'success');
          return handleEntryResult(state, entryValue, 'skipped', 'No matching issues');
        }
        const selectAll = await waitForElement(issuesSelectAllSelector, { timeout: 8000 }).catch(() => null);
        if (!selectAll) {
          logRunStatus(state, `Select All checkbox not found for ${label}.`, 'error');
          return handleEntryResult(state, entryValue, 'failed', 'Select All not found', { fatal: true });
        }
        if (selectAll.disabled) {
          logRunStatus(state, `No issues found for ${label}; skipping.`, 'success');
          return handleEntryResult(state, entryValue, 'skipped', 'No selectable issues');
        }
        const toggled = await ensureCheckboxState(selectAll, true, { context: `${id || 'quick-action'}:select-all` });
        if (!toggled) {
          logRunStatus(state, `Unable to select issues for ${label}.`, 'error');
          return handleEntryResult(state, entryValue, 'failed', 'Unable to toggle Select All', { fatal: true });
        }
        let bulkSelect = await waitForBulkActionsEnabled();
        if (!bulkSelect) {
          logRunStatus(state, `Bulk Actions dropdown not available for ${label}.`, 'error');
          return handleEntryResult(state, entryValue, 'failed', 'Bulk actions unavailable', { fatal: true });
        }
        bulkSelect = await waitForBulkOptions({ timeout: 6000 }) || bulkSelect;
        const actionOption = bulkActionMatcher ? bulkActionMatcher(bulkSelect) : null;
        if (!actionOption) {
          logRunStatus(state, `Required bulk action missing for ${label}.`, 'error');
          return handleEntryResult(state, entryValue, 'failed', 'Bulk action option missing', { fatal: true });
        }
        bulkSelect.value = actionOption.value;
        bulkSelect.dispatchEvent(new Event('change', { bubbles: true }));
        if (typeof afterBulkActionSelected === 'function') {
          await afterBulkActionSelected({
            state,
            entryLabel: label,
            targetSelect,
            logRunStatus,
            waitBeforeStep
          });
        }
        const applyBtn = findBulkApplyButton(applyKeyword);
        if (!applyBtn) {
          logRunStatus(state, `Apply button missing for ${label}.`, 'error');
          return handleEntryResult(state, entryValue, 'failed', 'Apply button missing', { fatal: true });
        }
        triggerClick(applyBtn);
        const confirmModal = await waitForElement(assignConfirmModalSelector, { timeout: 5000 }).catch(() => null);
        if (confirmModal) {
          const confirmBtn =
            confirmModal.querySelector(assignConfirmButtonSelector) ||
            Array.from(confirmModal.querySelectorAll('button')).find(btn => /confirm/i.test(btn.textContent || ''));
          if (confirmBtn) triggerClick(confirmBtn);
        }
        await waitForIssuesResultsIdle();
        await waitForCondition(() => {
          const toast = document.querySelector(toastSelector);
          if (!toast) return false;
          const text = (toast.textContent || '').toLowerCase();
          if (!text.includes('apply')) return false;
          return !applyKeyword || text.includes(applyKeyword);
        }, { timeout: 8000 }).catch(() => null);
        await ensureSelectAllUnchecked().catch(() => {});
        logRunStatus(state, `${completedVerb} issues for ${label}.`, 'success');
        return handleEntryResult(state, entryValue, 'success', `${completedVerb} successfully`);
      } catch (err) {
        console.error(err);
        logRunStatus(state, `Error while processing ${label}: ${err?.message || err}`, 'error');
        return handleEntryResult(state, entryValue, 'failed', err?.message || 'Unexpected error', { fatal: true });
      }
    };

    const finalizeRun = async (state, { cancelled = false } = {}) => {
      if (!state) return;
      state.status = 'cleanup';
      persistRunState();
      await clearRunFilters();
      logOutcomeBreakdown(state);
      if (!cancelled) {
        logRunStatus(state, 'Run complete.', 'success');
        setSummary(formatRunSummary(state) || 'Run complete.');
      }
      setActiveRunState(null);
    };

    const cancelActiveRun = async reason => {
      if (!activeRunState) return;
      const message = reason || 'Run cancelled.';
      logRunStatus(activeRunState, message, 'error');
      setSummary(message);
      const state = activeRunState;
      logOutcomeBreakdown(state);
      setActiveRunState(null);
      await clearRunFilters();
      renderSavedLogs(state);
    };

    const resumeRun = async state => {
      const hydrated = ensureRunStateShape(state);
      if (!hydrated) {
        setActiveRunState(null);
        return;
      }
      if (!Array.isArray(hydrated.queue) || !hydrated.queue.length) {
        await cancelActiveRun('No saved pages to process.');
        return;
      }
      while (activeRunState && hydrated === activeRunState) {
        if (hydrated.status === 'cleanup' || hydrated.currentIndex >= hydrated.queue.length) {
          await finalizeRun(hydrated);
          return;
        }
        const entry = hydrated.queue[hydrated.currentIndex];
        const applied = await applyFilterForEntry(hydrated, entry);
        if (!applied || !activeRunState || hydrated !== activeRunState) return;
        hydrated.status = 'applying';
        persistRunState();
        const outcome = await runBulkActionForCurrentFilter(hydrated, entry);
        if (!activeRunState || hydrated !== activeRunState) return;
        if (outcome === 'stop') return;
        if (outcome === 'cleanup' || hydrated.status === 'cleanup') {
          await finalizeRun(hydrated);
          return;
        }
      }
    };

    const scheduleRunResume = () => {
      if (resumeRunInFlight || !activeRunState) return;
      resumeRunInFlight = true;
      Promise.resolve()
        .then(() => resumeRun(activeRunState))
        .catch(err => {
          console.error(err);
          if (activeRunState) {
            logRunStatus(activeRunState, err?.message || 'Unexpected error while resuming run.', 'error');
          }
        })
        .finally(() => {
          resumeRunInFlight = false;
        });
    };

    const maybeResumeRun = () => {
      const stored = ensureRunStateShape(loadStoredRunState());
      if (!stored) {
        setActiveRunState(null);
        renderSavedLogs(null);
        summaryText.textContent = 'No runs yet';
        return;
      }
      if (isRunActive(stored)) {
        stored.status = 'paused';
      }
      setActiveRunState(stored);
      syncTargetSelectionFromState();
      renderSavedLogs(stored);
      const summaryLabel = stored.summary || formatRunSummary(stored);
      setSummary(summaryLabel);
      if (hasPendingEntries(stored) && stored.status === 'paused') {
        const lastLog = stored.logs?.[stored.logs.length - 1]?.message || '';
        if (!/run paused/i.test(lastLog)) {
          logRunStatus(stored, 'Run paused. Press Resume to continue.');
        }
        persistRunState();
      }
    };

    addBtn.addEventListener('click', () => {
      const saved = loadSavedEntries();
      openQuickAssignPagesModal(saved, {
        onSave(entries) {
          saveSavedEntries(entries);
          updateSavedDisplay();
        }
      });
    });

    clearBtn.addEventListener('click', () => {
      if (isRunActive(activeRunState)) {
        alert('Stop the current run before clearing saved pages.');
        return;
      }
      if (!confirm('Clear all saved pages for this automation?')) return;
      clearSavedEntries();
      updateSavedDisplay();
    });

    if (requiresTargetSelection && targetSelect) {
      targetSelect.addEventListener('change', () => {
        syncRunButtonState();
      });
      const hydrateTargetOptions = async () => {
        if (!requiresTargetSelection || optionsLoaded) return;
        try {
          const options = await targetOptionsLoader();
          targetSelect.innerHTML = '<option value="">Select…</option>';
          options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.textContent = opt.label;
            targetSelect.appendChild(option);
          });
          optionsLoaded = true;
        } catch (err) {
          targetSelect.innerHTML = `<option value="">${err.message || 'Unable to load options'}</option>`;
        } finally {
          targetSelect.disabled = false;
          syncTargetSelectionFromState();
          syncRunButtonState();
        }
      };
      details.addEventListener('toggle', () => {
        if (details.open) hydrateTargetOptions();
      });
      setTimeout(hydrateTargetOptions, 200);
    }

    runBtn.addEventListener('click', () => {
      if (isRunActive(activeRunState)) {
        alert('Automation is already running. Please wait or cancel the current run.');
        return;
      }
      const saved = loadSavedEntries();
      if (!saved.length) {
        alert('Add at least one page before running.');
        return;
      }
      if (activeRunState && hasPendingEntries(activeRunState) && activeRunState.status === 'paused') {
        logRunStatus(activeRunState, 'Resuming run…');
        activeRunState.status = 'pending';
        persistRunState();
        scheduleRunResume();
        return;
      }
      if (requiresTargetSelection && (!targetSelect || !targetSelect.value)) {
        alert('Select an option before running.');
        return;
      }
      const targetValue = targetSelect ? targetSelect.value : '';
      const targetLabel = targetSelect ? (targetSelect.options[targetSelect.selectedIndex]?.textContent || '').trim() : '';
      const newState = {
        version: 1,
        queue: saved.slice(),
        currentIndex: 0,
        status: 'pending',
        logs: [],
        stats: { success: 0, skipped: 0, failed: 0 },
        results: [],
        target: targetSelect ? {
          value: targetValue,
          label: targetLabel,
          labelLower: targetLabel.toLowerCase()
        } : null
      };
      setActiveRunState(newState);
      renderSavedLogs(activeRunState);
      logRunStatus(activeRunState, `Starting run for ${saved.length} page(s)…`);
      setSummary('Preparing run…');
      scheduleRunResume();
    });

    cancelRunBtn.addEventListener('click', () => {
      cancelActiveRun('Run cancelled by user.').catch(err => console.error(err));
    });

    updateSavedDisplay();
    maybeResumeRun();
    return details;
  }

  function buildAssignIssuesSection() {
    return buildPageAutomationSection({
      id: 'assign',
      title: 'Assign Issues by Page',
      introText: 'Save individual page URLs (or partial paths) and run them in sequence to assign matching issues.',
      automationNote: 'Automation keeps this page open and updates the Filters dialog for each saved URL.',
      storagePrefix: quickAssignStoragePrefix,
      runStateStorageKey: quickAssignRunStateStorageKey,
      requiresTargetSelection: true,
      targetSelectId: 'a11y-quick-assign-select',
      targetLabel: 'Assign to',
      targetOptionsLoader: ensureQuickAssignOptions,
      targetHint: 'Assignees are sourced from the page’s Filters → Assigned To list.',
      runButtonLabel: 'Assign Issues',
      busyButtonLabel: 'Assigning…',
      logActionVerb: 'Assign',
      logLabel: 'Log of Assign Issues',
      successPastTense: 'Assigned',
      bulkActionMatcher: select => findAssignOption(select),
      applyButtonKeyword: 'assign',
      afterBulkActionSelected: async ({ state, entryLabel, targetSelect, logRunStatus, waitBeforeStep }) => {
        if (!state?.target || (!state.target.value && !state.target.labelLower)) {
          throw new Error('Assignee not specified');
        }
        const assignHost = await waitForElement(issuesBulkAssignSelectSelector, { timeout: 6000 }).catch(() => null);
        if (!assignHost) {
          throw new Error('"Assign to" dropdown did not appear.');
        }
        await waitBeforeStep('before-assign-options');
        let assignOptionsResult = await waitForAssignSelectOptions({ timeout: 20000, minOptions: 1 }).catch(() => null);
        if (!assignOptionsResult) {
          logRunStatus(state, `Assignee options still loading, retrying for ${entryLabel}…`);
          await waitBeforeStep('retry-assign-options');
          assignOptionsResult = await waitForAssignSelectOptions({ timeout: 10000, minOptions: 1 }).catch(() => null);
        }
        if (!assignOptionsResult) {
          throw new Error('Assignee options unavailable');
        }
        const desiredOption = (assignOptionsResult.options || []).find(opt => {
          if (!opt || opt.disabled) return false;
          if (state.target.value && opt.value === state.target.value) return true;
          if (state.target.labelLower) {
            const optLabel = (opt.label || '').trim().toLowerCase();
            if (optLabel === state.target.labelLower) return true;
          }
          return false;
        });
        if (!desiredOption) {
          throw new Error(`Assignee "${state.target.label || state.target.value}" not available.`);
        }
        if (assignOptionsResult.select && assignOptionsResult.select.tagName === 'SELECT') {
          assignOptionsResult.select.value = desiredOption.value;
          assignOptionsResult.select.dispatchEvent(new Event('input', { bubbles: true }));
          assignOptionsResult.select.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
          const optionNode = (assignOptionsResult.optionNodes || []).find(node => {
            if (!node) return false;
            const nodeValue = getOptionValue(node);
            const nodeLabel = (node.textContent || '').trim().toLowerCase();
            if (state.target.value && nodeValue === state.target.value) return true;
            if (state.target.labelLower && nodeLabel === state.target.labelLower) return true;
            return false;
          });
          if (!optionNode) {
            throw new Error('Assignee option not found in dropdown.');
          }
          triggerClick(optionNode);
        }
      }
    });
  }

  function buildIgnoreIssuesSection() {
    return buildPageAutomationSection({
      id: 'ignore',
      title: 'Ignore Issues by Page',
      introText: 'Save individual page URLs (or partial paths) and run them in sequence to ignore matching issues.',
      automationNote: 'Automation keeps this page open and updates the Filters dialog for each saved URL.',
      storagePrefix: ignorePagesStoragePrefix,
      runStateStorageKey: ignoreRunStateStorageKey,
      runButtonLabel: 'Ignore Issues',
      busyButtonLabel: 'Ignoring…',
      logActionVerb: 'Ignore',
      successPastTense: 'Ignored',
      bulkActionMatcher: select => findBulkActionOptionByText(select, /set status.*ignored/i),
      applyButtonKeyword: 'ignore'
    });
  }

  function buildMarkIssuesSection() {
    return buildPageAutomationSection({
      id: 'mark-open',
      title: 'Mark as Issues by Page',
      introText: 'Save individual page URLs (or partial paths) and run them in sequence to mark matching issues as Open.',
      automationNote: 'Automation keeps this page open and updates the Filters dialog for each saved URL.',
      storagePrefix: markOpenPagesStoragePrefix,
      runStateStorageKey: markOpenRunStateStorageKey,
      runButtonLabel: 'Mark as Open',
      busyButtonLabel: 'Marking…',
      logActionVerb: 'Mark as Open',
      successPastTense: 'Marked as Open',
      logLabel: 'Log of Mark as Issues',
      bulkActionMatcher: select => findBulkActionOptionByText(select, /set status.*open/i),
      applyButtonKeyword: 'open'
    });
  }

  async function handleWasLoad(rowLookup, container, button) {
    if (wasDataCache.status === 'loading') {
      logWas('Load request ignored because a previous load is still running');
      return;
    }
    const proceed = await openSimpleDialog({
      title: 'Load WAS metrics?',
      message: 'This will call the Deque Monitor API for each selected WAS report. Depending on the number of scans, it may take a few minutes. Continue?',
      primaryLabel: 'Proceed',
      secondaryLabel: 'Cancel'
    });
    if (!proceed) {
      logWas('User cancelled WAS load at confirmation step');
      return;
    }
    const progress = openProgressDialog({
      title: 'Loading WAS metrics',
      initialMessage: 'Preparing requests...'
    });
    wasLoadAbortController?.abort();
    wasLoadAbortController = new AbortController();
    progress.onCancel(() => {
      wasLoadAbortController?.abort();
    });
    wasDataCache = { status: 'loading', data: null, timestamp: null };
    button.disabled = true;
    container.innerHTML = '';
    const placeholder = document.createElement('p');
    placeholder.textContent = 'Loading...';
    container.appendChild(placeholder);
    try {
      const activeRows = getEnabledWasRows();
      logWas('Loading metrics for', activeRows.length, 'reports');
      const data = await loadWasMetrics(rowLookup, activeRows, {
        signal: wasLoadAbortController.signal,
        onProgress: ({ current, total, name, status }) => {
          const displayIndex = status === 'start' ? current + 1 : current;
          const capped = Math.min(displayIndex, total);
          const text = status === 'start'
            ? `Loading ${name} (${displayIndex}/${total})...`
            : `Finished ${name} (${capped}/${total})`;
          progress.update(text);
        }
      });
      wasDataCache = { status: 'ready', data, timestamp: Date.now() };
      logWas('WAS metrics loaded successfully');
      progress.close();
      renderWasTable(container, data, wasDataCache.timestamp);
      button.disabled = false;
      button.textContent = 'Reload numbers';
    } catch (err) {
      progress.close();
      button.disabled = false;
      if (err && err.name === 'AbortError') {
        wasDataCache = { status: 'idle', data: wasDataCache.data || null, timestamp: wasDataCache.timestamp || null };
        logWas('WAS load aborted by user');
        alert('Loading cancelled.');
        return;
      }
      console.error(err);
      logWas('WAS load failed:', err?.message || err);
      wasDataCache = { status: 'error', data: null, timestamp: null, error: err?.message };
      container.innerHTML = '';
      const p = document.createElement('p');
      p.textContent = err?.message || 'Unable to load WAS metrics.';
      container.appendChild(p);
    } finally {
      wasLoadAbortController = null;
      if (wasDataCache.status !== 'ready') {
        button.textContent = 'Load numbers (may take some time)';
      }
    }
  }

  function renderWasTable(container, data, timestamp) {
    container.innerHTML = '';
    if (!Array.isArray(data) || !data.length) {
      const p = document.createElement('p');
      p.textContent = 'No WAS metrics available.';
      container.appendChild(p);
      return;
    }
    const table = document.createElement('table');
    table.className = 'a11y-scan-report-table';
    const columns = [
      { key: 'desktopCritical', label: 'Critical Issues (Desktop)', accessor: record => formatWasCell(record.desktop, 'critical') },
      { key: 'desktopSerious', label: 'Serious Issues (Desktop)', accessor: record => formatWasCell(record.desktop, 'serious') },
      { key: 'desktopNeeds', label: 'Needs Review (Desktop)', accessor: record => formatWasCell(record.desktop, 'needsReview') },
      { key: 'mobileCritical', label: 'Critical Issues (Mobile)', accessor: record => formatWasCell(record.mobile, 'critical') },
      { key: 'mobileSerious', label: 'Serious Issues (Mobile)', accessor: record => formatWasCell(record.mobile, 'serious') },
      { key: 'pdfCritical', label: 'PDFs with Critical Issues', accessor: record => formatPdfCell(record.pdf) },
      { key: 'statusNotes', label: 'Status note', accessor: record => buildWasStatusNotes(record) }
    ];
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    headerRow.appendChild(document.createElement('th')).textContent = 'WAS Report Name';
    columns.forEach(col => {
      const th = document.createElement('th');
      th.textContent = col.label;
      headerRow.appendChild(th);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    data.forEach(record => {
      const tr = document.createElement('tr');
      const nameCell = document.createElement('th');
      nameCell.setAttribute('scope','row');
      nameCell.textContent = record.name;
      tr.appendChild(nameCell);
      columns.forEach(col => {
        const td = document.createElement('td');
        const value = col.accessor(record);
        if (value instanceof Node) {
          td.appendChild(value);
        } else if (value != null) {
          td.textContent = String(value);
        } else {
          td.textContent = '—';
        }
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    appendTableWithDownload(container, table, { filenameBase: 'was-metrics' });

    if (timestamp) {
      const status = document.createElement('p');
      status.className = 'a11y-was-status';
      status.textContent = `Last updated: ${new Date(timestamp).toLocaleString()}`;
      container.appendChild(status);
    }
  }

  function formatWasCell(group, key) {
    if (!group) return '—';
    if (group.error) return group.error;
    const value = group[key];
    return Number.isFinite(value) ? String(value) : '—';
  }

  function formatPdfCell(group) {
    if (!group) return '—';
    if (group.error) return group.error;
    const value = group.criticalPages;
    return Number.isFinite(value) ? String(value) : '—';
  }

  const wasWaitStatusTokens = ['queued','queue','pending','inprogress','progress','running'];
  const wasRerunStatusTokens = ['cancel','initial','notstarted','stopped'];

  function buildWasStatusNotes(record) {
    const fragment = document.createDocumentFragment();
    let found = false;
    ['desktop','mobile','pdf'].forEach(key => {
      const data = record[key];
      const statusRaw = (data?.status || '').trim();
      if (!statusRaw) return;
      const slug = statusRaw.toLowerCase().replace(/\s+/g,'');
      let noteText = null;
      let needsLink = false;
      if (wasWaitStatusTokens.some(token => slug.includes(token))) {
        noteText = `${capitalize(key)} run ${statusRaw} – waiting for completion.`;
      } else if (wasRerunStatusTokens.some(token => slug.includes(token))) {
        noteText = `${capitalize(key)} run ${statusRaw}. `;
        needsLink = true;
      }
      if (!noteText) return;
      found = true;
      const note = document.createElement('div');
      note.className = 'a11y-was-status-note';
      note.appendChild(document.createTextNode(noteText));
      if (needsLink) {
        if (data?.scanUrl) {
          const link = createExternalLink(data.scanUrl, 'Open scan');
          if (link) {
            link.style.marginLeft = '4px';
            note.appendChild(link);
          }
        } else {
          const em = document.createElement('em');
          em.textContent = 'Run the scan again.';
          note.appendChild(em);
        }
      }
      fragment.appendChild(note);
    });
    if (!found) return '—';
    return fragment;
  }

  function openSimpleDialog({ title, message, primaryLabel = 'OK', secondaryLabel = 'Cancel' }) {
    return new Promise(resolve => {
      const overlay = document.createElement('div');
      overlay.className = 'a11y-filter-overlay';
      const dialog = document.createElement('div');
      dialog.className = 'a11y-filter-dialog';
      dialog.setAttribute('role','dialog');
      dialog.setAttribute('aria-modal','true');

      const header = document.createElement('div');
      header.className = 'a11y-filter-header';
      const h2 = document.createElement('h2');
      h2.textContent = title;
      header.appendChild(h2);
      dialog.appendChild(header);

      const content = document.createElement('div');
      content.className = 'a11y-filter-content';
      const p = document.createElement('p');
      p.textContent = message;
      content.appendChild(p);
      dialog.appendChild(content);

      const footer = document.createElement('div');
      footer.className = 'a11y-filter-footer';
      const primaryBtn = document.createElement('button');
      primaryBtn.type = 'button';
      primaryBtn.className = 'a11y-btn-primary';
      primaryBtn.textContent = primaryLabel;
      const secondaryBtn = document.createElement('button');
      secondaryBtn.type = 'button';
      secondaryBtn.className = 'a11y-btn-secondary';
      secondaryBtn.textContent = secondaryLabel;
      footer.appendChild(primaryBtn);
      footer.appendChild(secondaryBtn);
      dialog.appendChild(footer);

      overlay.appendChild(dialog);
      appendOverlayAfterFooter(overlay);

      const cleanup = result => {
        overlay.remove();
        resolve(result);
      };

      primaryBtn.addEventListener('click', () => cleanup(true));
      secondaryBtn.addEventListener('click', () => cleanup(false));
      overlay.addEventListener('click', e => {
        if (e.target === overlay) cleanup(false);
      });
      dialog.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
          e.preventDefault();
          cleanup(false);
        }
      });
      primaryBtn.focus();
    });
  }

  function openSettingsDialog({ focusField = 'apiKey' } = {}) {
    return new Promise((resolve, reject) => {
      try {
        const overlay = document.createElement('div');
        overlay.className = 'a11y-filter-overlay';
        const dialog = document.createElement('div');
        dialog.className = 'a11y-filter-dialog';
        dialog.setAttribute('role','dialog');
        dialog.setAttribute('aria-modal','true');

        const header = document.createElement('div');
        header.className = 'a11y-filter-header';
        const h2 = document.createElement('h2');
        h2.textContent = 'Settings';
        header.appendChild(h2);
        dialog.appendChild(header);

        const content = document.createElement('div');
        content.className = 'a11y-filter-content';
        const instructions = document.createElement('p');
        instructions.textContent = 'Update settings for this accessibility helper. Values are stored locally in this browser.';
        content.appendChild(instructions);

        const apiLabel = document.createElement('label');
        apiLabel.textContent = 'Deque Monitor API key';
        apiLabel.setAttribute('for','a11y-settings-api-key');
        content.appendChild(apiLabel);
        const apiInput = document.createElement('input');
        apiInput.type = 'password';
        apiInput.id = 'a11y-settings-api-key';
        apiInput.value = getStoredMonitorApiKey();
        apiInput.style.width = '100%';
        apiInput.autocomplete = 'off';
        content.appendChild(apiInput);

        const footer = document.createElement('div');
        footer.className = 'a11y-filter-footer';
        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.className = 'a11y-btn-primary';
        saveBtn.textContent = 'Save';
        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'a11y-btn-secondary';
        cancelBtn.textContent = 'Cancel';
        footer.appendChild(saveBtn);
        footer.appendChild(cancelBtn);

        dialog.appendChild(content);
        dialog.appendChild(footer);
        overlay.appendChild(dialog);
        appendOverlayAfterFooter(overlay);

        let closed = false;
        const close = saved => {
          if (closed) return;
          closed = true;
          overlay.remove();
          resolve(!!saved);
        };

        saveBtn.addEventListener('click', () => {
          setStoredMonitorApiKey(apiInput.value || '');
          close(true);
        });
        cancelBtn.addEventListener('click', () => close(false));
        overlay.addEventListener('click', e => { if (e.target === overlay) close(false); });
        dialog.addEventListener('keydown', e => {
          if (e.key === 'Escape') {
            e.preventDefault();
            close(false);
          }
        });
        apiInput.addEventListener('keydown', e => {
          if (e.key === 'Enter') {
            e.preventDefault();
            setStoredMonitorApiKey(apiInput.value || '');
            close(true);
          }
        });

        // Manage initial focus
        if (focusField === 'apiKey') {
          apiInput.focus();
        } else {
          saveBtn.focus();
        }
      } catch (err) {
        reject(err);
      }
    });
  }

  function openRankingDialog(triggerButton) {
    if (rankingState.dialog) {
      rankingState.dialog.focus();
      return;
    }
    const overlay = document.createElement('div');
    overlay.className = 'a11y-filter-overlay';
    const dialog = document.createElement('div');
    dialog.className = 'a11y-filter-dialog a11y-ranking-dialog';
    dialog.setAttribute('role','dialog');
    dialog.setAttribute('aria-modal','true');
    dialog.setAttribute('aria-labelledby', rankingState.dialogTitleId);

    rankingState.dialog = dialog;
    rankingState.lastTrigger = triggerButton || document.activeElement;

    const header = document.createElement('div');
    header.className = 'a11y-filter-header';
    const h2 = document.createElement('h2');
    h2.id = rankingState.dialogTitleId;
    h2.textContent = 'Ranking order';
    h2.setAttribute('tabindex','-1');
    header.appendChild(h2);
    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'a11y-filter-close';
    closeBtn.setAttribute('aria-label','Close ranking order dialog');
    closeBtn.innerHTML = '×';
    header.appendChild(closeBtn);
    dialog.appendChild(header);

    const content = document.createElement('div');
    content.className = 'a11y-filter-content a11y-ranking-content';
    const intro = document.createElement('p');
    intro.textContent = 'Choose the order of ranking priorities. The first row is applied before the next, so place your most important criteria at the top.';
    content.appendChild(intro);

    const chipsRow = document.createElement('div');
    chipsRow.className = 'a11y-ranking-chip-row';
    const appliedChip = document.createElement('div');
    appliedChip.className = 'a11y-ranking-chip';
    const appliedChipLabel = document.createElement('span');
    appliedChipLabel.className = 'a11y-ranking-chip-label';
    appliedChipLabel.textContent = 'Priorities';
    const appliedChipValue = document.createElement('span');
    appliedChipValue.className = 'a11y-ranking-chip-value';
    appliedChip.appendChild(appliedChipLabel);
    appliedChip.appendChild(appliedChipValue);
    const apiChip = document.createElement('div');
    apiChip.className = 'a11y-ranking-chip';
    const apiChipLabel = document.createElement('span');
    apiChipLabel.className = 'a11y-ranking-chip-label';
    apiChipLabel.textContent = 'Monitor API';
    const apiChipValue = document.createElement('span');
    apiChipValue.className = 'a11y-ranking-chip-value';
    apiChip.appendChild(apiChipLabel);
    apiChip.appendChild(apiChipValue);
    chipsRow.appendChild(appliedChip);
    chipsRow.appendChild(apiChip);
    content.appendChild(chipsRow);

    const rowsContainer = document.createElement('div');
    rowsContainer.className = 'a11y-ranking-rows';
    content.appendChild(rowsContainer);

    const errorSummary = document.createElement('div');
    errorSummary.className = 'a11y-ranking-error-summary';
    errorSummary.setAttribute('aria-live','polite');
    content.appendChild(errorSummary);

    const actionRow = document.createElement('div');
    actionRow.className = 'a11y-ranking-inline-actions';
    const addRowBtn = document.createElement('button');
    addRowBtn.type = 'button';
    addRowBtn.className = 'a11y-btn-secondary a11y-ranking-add-btn';
    addRowBtn.textContent = 'Add priority';
    const clearBtn = document.createElement('button');
    clearBtn.type = 'button';
    clearBtn.className = 'a11y-btn-tertiary a11y-ranking-clear-btn';
    clearBtn.textContent = 'Clear all';
    const resetBtn = document.createElement('button');
    resetBtn.type = 'button';
    resetBtn.className = 'a11y-btn-tertiary a11y-ranking-reset-btn';
    resetBtn.textContent = 'Restore defaults';
    actionRow.appendChild(addRowBtn);
    actionRow.appendChild(clearBtn);
    actionRow.appendChild(resetBtn);
    content.appendChild(actionRow);

    dialog.appendChild(content);

    const footer = document.createElement('div');
    footer.className = 'a11y-filter-footer';
    const applyBtn = document.createElement('button');
    applyBtn.type = 'button';
    applyBtn.className = 'a11y-btn-primary';
    applyBtn.textContent = 'Apply ranking';
    const cancelBtn = document.createElement('button');
    cancelBtn.type = 'button';
    cancelBtn.className = 'a11y-btn-secondary';
    cancelBtn.textContent = 'Cancel';
    footer.appendChild(applyBtn);
    footer.appendChild(cancelBtn);
    dialog.appendChild(footer);

    overlay.appendChild(dialog);
    appendOverlayAfterFooter(overlay);

    const baseValues = getRankingCriteria();
    setRowsFromValues(baseValues.length ? baseValues : ['']);
    updateChips();

    function setRowsFromValues(values) {
      rowsContainer.innerHTML = '';
      const entries = values && values.length ? values : [''];
      entries.forEach(value => rowsContainer.appendChild(createRow(value)));
      syncRowOrder();
      refreshOptionStates();
      setErrorSummary('');
      updateChips();
    }

    function createRow(initialValue = '') {
      const rowEl = document.createElement('div');
      rowEl.className = 'a11y-ranking-row';
      const headerEl = document.createElement('div');
      headerEl.className = 'a11y-ranking-row-header';
      const label = document.createElement('label');
      label.className = 'a11y-ranking-row-label';
      const selectId = `a11y-ranking-select-${Math.random().toString(36).slice(2)}`;
      label.setAttribute('for', selectId);
      headerEl.appendChild(label);
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'a11y-ranking-row-remove';
      removeBtn.textContent = 'Remove';
      removeBtn.addEventListener('click', () => {
        rowEl.remove();
        if (!rowsContainer.children.length) {
          rowsContainer.appendChild(createRow(''));
        }
        syncRowOrder();
        refreshOptionStates();
        setErrorSummary('');
        updateChips();
      });
      headerEl.appendChild(removeBtn);
      rowEl.appendChild(headerEl);

      const select = document.createElement('select');
      select.id = selectId;
      select.className = 'a11y-ranking-row-select';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select a ranking field';
      select.appendChild(placeholder);
      rankingFieldOptions.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.requiresApi ? `${option.label} (Monitor API)` : option.label;
        select.appendChild(opt);
      });
      if (initialValue && rankingFieldLookup.has(initialValue)) {
        select.value = initialValue;
      }
      select.addEventListener('change', () => {
        clearRowError(rowEl);
        updateRowHint(rowEl, select.value);
        refreshOptionStates();
        updateChips();
      });
      rowEl.appendChild(select);

      const hint = document.createElement('div');
      hint.className = 'a11y-ranking-row-hint';
      rowEl.appendChild(hint);

      const error = document.createElement('div');
      error.className = 'a11y-ranking-row-error';
      error.id = `${selectId}-error`;
      error.setAttribute('aria-live','polite');
      rowEl.appendChild(error);

      updateRowHint(rowEl, select.value);
      return rowEl;
    }

    function updateRowHint(rowEl, value) {
      const hint = rowEl.querySelector('.a11y-ranking-row-hint');
      const option = getRankingFieldOption(value);
      if (option?.requiresApi && !isMonitorApiReadyForRanking()) {
        hint.textContent = 'Requires Monitor API data. Switch sources and load data to enable this priority.';
      } else {
        hint.textContent = option?.description || 'Select a ranking priority to break ties.';
      }
    }

    function syncRowOrder() {
      const rows = Array.from(rowsContainer.querySelectorAll('.a11y-ranking-row'));
      const disableRemove = rows.length <= 1;
      rows.forEach((row, index) => {
        const label = row.querySelector('.a11y-ranking-row-label');
        const removeBtn = row.querySelector('.a11y-ranking-row-remove');
        label.textContent = `Priority ${index + 1}`;
        removeBtn.setAttribute('aria-label', `Remove priority ${index + 1}`);
        removeBtn.disabled = disableRemove;
      });
    }

    function refreshOptionStates() {
      const selects = Array.from(rowsContainer.querySelectorAll('select'));
      const selectedValues = new Map();
      selects.forEach(select => {
        if (!select.value) return;
        if (!selectedValues.has(select.value)) selectedValues.set(select.value, []);
        selectedValues.get(select.value).push(select);
      });
      selects.forEach(select => {
        const currentValue = select.value;
        Array.from(select.options).forEach(option => {
          const value = option.value;
          if (!value) return;
          const meta = getRankingFieldOption(value);
          const takenElsewhere = value !== currentValue && selectedValues.has(value);
          const gated = meta?.requiresApi && !isMonitorApiReadyForRanking();
          option.disabled = takenElsewhere || (gated && value !== currentValue);
        });
      });
      addRowBtn.disabled = selects.length >= rankingFieldOptions.length;
    }

    function setErrorSummary(message) {
      errorSummary.textContent = message || '';
    }

    function clearRowError(rowEl) {
      const select = rowEl.querySelector('select');
      const error = rowEl.querySelector('.a11y-ranking-row-error');
      rowEl.classList.remove('a11y-ranking-row--error');
      if (select) {
        select.removeAttribute('aria-invalid');
        select.removeAttribute('aria-describedby');
      }
      if (error) error.textContent = '';
    }

    function setRowError(rowEl, message) {
      const select = rowEl.querySelector('select');
      const error = rowEl.querySelector('.a11y-ranking-row-error');
      if (!select || !error) return;
      const errorId = error.id || `${select.id}-error`;
      error.id = errorId;
      rowEl.classList.add('a11y-ranking-row--error');
      error.textContent = message;
      select.setAttribute('aria-invalid','true');
      select.setAttribute('aria-describedby', errorId);
    }

    function updateChips() {
      const selects = Array.from(rowsContainer.querySelectorAll('select'));
      const activeCount = selects.filter(select => select.value).length;
      appliedChipValue.textContent = `${activeCount} applied`;
      const needsApi = selects.some(select => {
        const option = getRankingFieldOption(select.value);
        return Boolean(option?.requiresApi);
      });
      if (needsApi && !isMonitorApiReadyForRanking()) {
        apiChipValue.textContent = 'Load data';
        apiChip.classList.add('a11y-ranking-chip--alert');
      } else if (needsApi && isMonitorApiReadyForRanking()) {
        apiChipValue.textContent = 'Ready';
        apiChip.classList.remove('a11y-ranking-chip--alert');
      } else if (!needsApi && isMonitorApiReadyForRanking()) {
        apiChipValue.textContent = 'Optional';
        apiChip.classList.remove('a11y-ranking-chip--alert');
      } else {
        apiChipValue.textContent = 'Unavailable';
        apiChip.classList.remove('a11y-ranking-chip--alert');
      }
    }

    function getSelectedValues() {
      return Array.from(rowsContainer.querySelectorAll('select')).map(select => select.value).filter(Boolean);
    }

    function validateRows() {
      setErrorSummary('');
      const selects = Array.from(rowsContainer.querySelectorAll('select'));
      const used = new Set();
      const values = [];
      let firstInvalid = null;
      selects.forEach(select => {
        const rowEl = select.closest('.a11y-ranking-row');
        clearRowError(rowEl);
        const value = select.value;
        if (!value) {
          setRowError(rowEl, 'Select a ranking field for this priority.');
          firstInvalid = firstInvalid || select;
          return;
        }
        if (used.has(value)) {
          setRowError(rowEl, 'Each ranking field can only be used once.');
          firstInvalid = firstInvalid || select;
          return;
        }
        if (!isRankingFieldAvailable(value)) {
          setRowError(rowEl, 'Switch to the Monitor API to use this priority.');
          firstInvalid = firstInvalid || select;
          return;
        }
        used.add(value);
        values.push(value);
      });
      if (firstInvalid) return { values: null, firstInvalid };
      if (!values.length) {
        setErrorSummary('Add at least one ranking priority before applying changes.');
        return { values: null, firstInvalid: selects[0] || null };
      }
      return { values, firstInvalid: null };
    }

    function closeDialog({ applied = false, changed = false } = {}) {
      document.removeEventListener('keydown', handleKeydown, true);
      overlay.remove();
      rankingState.dialog = null;
      const focusTarget = rankingState.lastTrigger;
      rankingState.lastTrigger = null;
      if (focusTarget && typeof focusTarget.focus === 'function') {
        focusTarget.focus();
      }
      if (applied && changed) {
        refreshMainView({ preserveState: true, targetTabKey: 'ranking' }).catch(err => console.error(err));
      }
    }

    function handleKeydown(event) {
      if (event.key === 'Escape') {
        event.preventDefault();
        closeDialog();
        return;
      }
      if (event.key === 'Tab') {
        const focusable = getFocusable(dialog);
        if (!focusable.length) return;
        const first = focusable[0];
        const last = focusable[focusable.length - 1];
        if (event.shiftKey) {
          if (document.activeElement === first) {
            event.preventDefault();
            last.focus();
          }
        } else if (document.activeElement === last) {
          event.preventDefault();
          first.focus();
        }
      }
    }

    addRowBtn.addEventListener('click', () => {
      rowsContainer.appendChild(createRow(''));
      syncRowOrder();
      refreshOptionStates();
      setErrorSummary('');
      updateChips();
      const lastSelect = rowsContainer.querySelector('.a11y-ranking-row:last-child select');
      lastSelect?.focus();
    });

    clearBtn.addEventListener('click', () => {
      setRowsFromValues(['']);
      rowsContainer.querySelector('select')?.focus();
    });

    resetBtn.addEventListener('click', () => {
      setRowsFromValues(getDefaultRankingCriteria());
      rowsContainer.querySelector('select')?.focus();
    });

    applyBtn.addEventListener('click', () => {
      const { values, firstInvalid } = validateRows();
      if (!values) {
        firstInvalid?.focus();
        return;
      }
      const previous = getRankingCriteria();
      const changed = values.length !== previous.length || values.some((value, idx) => value !== previous[idx]);
      setRankingCriteria(values);
      closeDialog({ applied: true, changed });
    });

    cancelBtn.addEventListener('click', () => closeDialog());
    closeBtn.addEventListener('click', () => closeDialog());
    overlay.addEventListener('click', e => { if (e.target === overlay) closeDialog(); });
    document.addEventListener('keydown', handleKeydown, true);

    requestAnimationFrame(() => {
      h2.focus();
    });
  }

  function openProgressDialog({ title, initialMessage = '' }) {
    const overlay = document.createElement('div');
    overlay.className = 'a11y-filter-overlay';
    const dialog = document.createElement('div');
    dialog.className = 'a11y-filter-dialog';
    dialog.setAttribute('role','dialog');
    dialog.setAttribute('aria-modal','true');

    const header = document.createElement('div');
    header.className = 'a11y-filter-header';
    const h2 = document.createElement('h2');
    h2.textContent = title;
    header.appendChild(h2);
    dialog.appendChild(header);

    const content = document.createElement('div');
    content.className = 'a11y-filter-content';
    const status = document.createElement('p');
    status.textContent = initialMessage;
    content.appendChild(status);
    dialog.appendChild(content);

    const footer = document.createElement('div');
    footer.className = 'a11y-filter-footer';
    const cancelBtn = document.createElement('button');
    cancelBtn.type = 'button';
    cancelBtn.className = 'a11y-btn-secondary';
    cancelBtn.textContent = 'Cancel';
    footer.appendChild(cancelBtn);
    dialog.appendChild(footer);

    overlay.appendChild(dialog);
    appendOverlayAfterFooter(overlay);

    let closed = false;
    let cancelHandler = null;
    const closeOverlay = () => {
      if (closed) return;
      closed = true;
      overlay.remove();
    };

    cancelBtn.addEventListener('click', () => {
      try {
        cancelHandler?.();
      } finally {
        closeOverlay();
      }
    });

    cancelBtn.focus();
    return {
      update(message) {
        status.textContent = message;
      },
      onCancel(handler) {
        cancelHandler = handler;
      },
      close() {
        closeOverlay();
      }
    };
  }

  function openWasConfigModal(rowLookup) {
    return new Promise(resolve => {
      const overlay = document.createElement('div');
      overlay.className = 'a11y-filter-overlay';
      const dialog = document.createElement('div');
      dialog.className = 'a11y-filter-dialog a11y-was-config-dialog';
      dialog.setAttribute('role','dialog');
      dialog.setAttribute('aria-modal','true');

      const header = document.createElement('div');
      header.className = 'a11y-filter-header';
      const h2 = document.createElement('h2');
      h2.textContent = 'Edit WAS Domains';
      header.appendChild(h2);
      dialog.appendChild(header);

      const content = document.createElement('div');
      content.className = 'a11y-filter-content';

      const selectAllWrap = document.createElement('div');
      selectAllWrap.className = 'a11y-was-config-select-all';
      const selectAll = document.createElement('input');
      selectAll.type = 'checkbox';
      selectAll.id = 'a11y-was-config-select-all';
      const selectAllLabel = document.createElement('label');
      selectAllLabel.setAttribute('for','a11y-was-config-select-all');
      selectAllLabel.textContent = 'Select all WAS domains';
      selectAllWrap.appendChild(selectAll);
      selectAllWrap.appendChild(selectAllLabel);
      content.appendChild(selectAllWrap);

      const table = document.createElement('table');
      table.className = 'a11y-scan-report-table';
      const thead = document.createElement('thead');
      const hr = document.createElement('tr');
      ['Select','WAS Report Name','Desktop scan','Mobile scan','PDF scan'].forEach(label => {
        const th = document.createElement('th');
        th.textContent = label;
        th.setAttribute('scope','col');
        hr.appendChild(th);
      });
      thead.appendChild(hr);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const scanOptions = getScanOptions(rowLookup);
      const rowContexts = wasConfig.map(row => {
        const tr = document.createElement('tr');
        const selectCell = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = row.enabled !== false;
        selectCell.appendChild(checkbox);
        tr.appendChild(selectCell);

        const nameCell = document.createElement('th');
        nameCell.setAttribute('scope','row');
        nameCell.textContent = row.name;
        tr.appendChild(nameCell);

        const desktopCell = document.createElement('td');
        const desktopSelect = createScanSelect(scanOptions, row.desktop);
        desktopCell.appendChild(desktopSelect);
        tr.appendChild(desktopCell);

        const mobileCell = document.createElement('td');
        const mobileSelect = createScanSelect(scanOptions, row.mobile);
        mobileCell.appendChild(mobileSelect);
        tr.appendChild(mobileCell);

        const pdfCell = document.createElement('td');
        const pdfSelect = createScanSelect(scanOptions, row.pdf);
        pdfCell.appendChild(pdfSelect);
        tr.appendChild(pdfCell);

        tbody.appendChild(tr);
        return { row, checkbox, desktopSelect, mobileSelect, pdfSelect };
      });
      table.appendChild(tbody);
      appendTableWithDownload(content, table, { filenameBase: 'was-config' });
      dialog.appendChild(content);

      const footer = document.createElement('div');
      footer.className = 'a11y-filter-footer';
      const saveBtn = document.createElement('button');
      saveBtn.type = 'button';
      saveBtn.className = 'a11y-btn-primary';
      saveBtn.textContent = 'Save';
      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.className = 'a11y-btn-secondary';
      cancelBtn.textContent = 'Cancel';
      footer.appendChild(saveBtn);
      footer.appendChild(cancelBtn);
      dialog.appendChild(footer);

      overlay.appendChild(dialog);
      appendOverlayAfterFooter(overlay);

      function updateSelectAllState() {
        const total = rowContexts.length;
        const checked = rowContexts.filter(ctx => ctx.checkbox.checked).length;
        selectAll.checked = checked === total && total > 0;
        selectAll.indeterminate = checked > 0 && checked < total;
      }
      updateSelectAllState();

      selectAll.addEventListener('change', () => {
        rowContexts.forEach(ctx => { ctx.checkbox.checked = selectAll.checked; });
        updateSelectAllState();
      });
      rowContexts.forEach(ctx => {
        ctx.checkbox.addEventListener('change', updateSelectAllState);
      });

      const close = result => {
        overlay.remove();
        resolve(result);
      };

      cancelBtn.addEventListener('click', () => close(false));
      overlay.addEventListener('click', e => {
        if (e.target === overlay) close(false);
      });
      dialog.addEventListener('keydown', e => {
        if (e.key === 'Escape') {
          e.preventDefault();
          close(false);
        }
      });

      saveBtn.addEventListener('click', () => {
        wasConfig = rowContexts.map(ctx => ({
          name: ctx.row.name,
          enabled: ctx.checkbox.checked,
          desktop: ctx.desktopSelect.value,
          mobile: ctx.mobileSelect.value,
          pdf: ctx.pdfSelect.value
        }));
        close(true);
      });

      saveBtn.focus();
    });
  }

  function renderRefreshFooter(footer, now, body, updateFilterButtonLabel) {
    if (!footer) return;
    footer.innerHTML = '';
    pageImpactFilterState.footerChipContainer = null;
    pageImpactFilterState.footerApiChip = null;
    pageImpactFilterState.footerInfoEl = null;

    const statusRow = document.createElement('div');
    statusRow.className = 'a11y-refresh-status-row';

    const chipsWrap = document.createElement('div');
    chipsWrap.className = 'a11y-footer-chip-wrap';
    const footerChip = createMonitorApiChipElement();
    chipsWrap.appendChild(footerChip);
    statusRow.appendChild(chipsWrap);

    const info = document.createElement('div');
    info.className = 'a11y-scan-report-refresh-info';
    info.id = 'a11y-scan-refresh-info';
    info.setAttribute('tabindex','-1');
    statusRow.appendChild(info);

    footer.appendChild(statusRow);

    pageImpactFilterState.footerChipContainer = chipsWrap;
    pageImpactFilterState.footerApiChip = footerChip;
    pageImpactFilterState.footerInfoEl = info;

    const refreshDate = now instanceof Date ? now : new Date(now || Date.now());
    setFooterBaseTimestamp(refreshDate.toLocaleString());
    setFooterRefreshMessage();

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'a11y-scan-report-refresh-btn';
    btn.textContent = 'Refresh data';
    btn.addEventListener('click', async () => {
      try {
        if (getPageImpactSource() === 'api') {
          await requestPageImpactApiData({ mode: 'reload' });
        }
        await refreshMainView({ preserveState: true });
        const focusTarget = footer.querySelector('#a11y-scan-refresh-info');
        if (focusTarget) focusTarget.focus();
      } catch (e) {
        alert(e.message);
      }
    });

    footer.appendChild(btn);
    updatePageImpactApiControls();
  }

  // --- Filter modal ---

  function openFilterModal(parentDialog, bodyEl, footerEl, data, updateFilterButtonLabel) {
    const { typeOptions, domainOptions, statusOptions } = data;
    logWidget('openFilterModal start', {
      typeOptions: typeOptions?.length || 0,
      domainOptions: domainOptions?.length || 0,
      statusOptions: statusOptions?.length || 0
    });
    let domIdCounter = 0;
    const makeDomId = (label, scope = 'domain') => {
      domIdCounter += 1;
      const safe = String(label || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '') || 'option';
      return `a11y-filter-${scope}-${safe}-${domIdCounter}`;
    };

    const domainHierarchy = buildDomainHierarchy(domainOptions);

    const overlay = document.createElement('div');
    overlay.className = 'a11y-filter-overlay';

    const dialog = document.createElement('div');
    dialog.className = 'a11y-filter-dialog';
    dialog.setAttribute('role','dialog');
    dialog.setAttribute('aria-modal','true');
    dialog.setAttribute('aria-labelledby','a11y-filter-title');

    const header = document.createElement('div');
    header.className = 'a11y-filter-header';

    const h2 = document.createElement('h2');
    h2.id = 'a11y-filter-title';
    h2.textContent = 'Filters';
    header.appendChild(h2);

    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'Dialog__close';
    closeBtn.innerHTML = '<span aria-hidden="true" class="Icon Icon--close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" height="24" width="24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" fill="currentColor"></path></svg></span><span class="Offscreen">Close</span>';
    header.appendChild(closeBtn);
    dialog.appendChild(header);

    const content = document.createElement('div');
    content.className = 'a11y-filter-content';

    // Type accordion
    const typeDetails = document.createElement('details');
    typeDetails.className = 'a11y-filter-type-details';
    typeDetails.open = true;
    const typeSummary = document.createElement('summary');
    typeSummary.textContent = 'Type';
    typeDetails.appendChild(typeSummary);

    const typeFs = document.createElement('fieldset');
    typeFs.className = 'a11y-filter-fieldset';
    const typeLegend = document.createElement('legend');
    typeLegend.className = 'sr-only';
    typeLegend.textContent = 'Filter by type';
    typeFs.appendChild(typeLegend);

    const typeAllWrap = document.createElement('div');
    typeAllWrap.className = 'a11y-filter-checkbox-wrap';
    const typeAll = document.createElement('input');
    typeAll.type = 'checkbox';
    typeAll.id = 'a11y-filter-type-all';
    const typeAllLabel = document.createElement('label');
    typeAllLabel.setAttribute('for','a11y-filter-type-all');
    typeAllLabel.textContent = 'Select all types';
    typeAllWrap.appendChild(typeAll);
    typeAllWrap.appendChild(typeAllLabel);
    typeFs.appendChild(typeAllWrap);

    typeOptions.forEach(type => {
      const id = `a11y-filter-type-${type.replace(/\s+/g,'_')}`;
      const wrap = document.createElement('div');
      wrap.className = 'a11y-filter-checkbox-wrap';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.id = id;
      cb.value = type;
      const label = document.createElement('label');
      label.setAttribute('for', id);
      label.textContent = type;
      wrap.appendChild(cb);
      wrap.appendChild(label);
      typeFs.appendChild(wrap);
    });

    typeDetails.appendChild(typeFs);
    content.appendChild(typeDetails);

    // Status accordion
    const statusDetails = document.createElement('details');
    statusDetails.className = 'a11y-filter-status-details';
    statusDetails.open = true;
    const statusSummary = document.createElement('summary');
    statusSummary.textContent = 'Status';
    statusDetails.appendChild(statusSummary);

    const statusFs = document.createElement('fieldset');
    statusFs.className = 'a11y-filter-fieldset';
    const statusLegend = document.createElement('legend');
    statusLegend.className = 'sr-only';
    statusLegend.textContent = 'Filter by status';
    statusFs.appendChild(statusLegend);

    const statusAllWrap = document.createElement('div');
    statusAllWrap.className = 'a11y-filter-checkbox-wrap';
    const statusAll = document.createElement('input');
    statusAll.type = 'checkbox';
    statusAll.id = 'a11y-filter-status-all';
    const statusAllLabel = document.createElement('label');
    statusAllLabel.setAttribute('for','a11y-filter-status-all');
    statusAllLabel.textContent = 'Select all statuses';
    statusAllWrap.appendChild(statusAll);
    statusAllWrap.appendChild(statusAllLabel);
    statusFs.appendChild(statusAllWrap);

    statusOptions.forEach(status => {
      const id = `a11y-filter-status-${status.replace(/\s+/g,'_')}`;
      const wrap = document.createElement('div');
      wrap.className = 'a11y-filter-checkbox-wrap';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.id = id;
      cb.value = status;
      const label = document.createElement('label');
      label.setAttribute('for', id);
      label.textContent = status;
      wrap.appendChild(cb);
      wrap.appendChild(label);
      statusFs.appendChild(wrap);
    });

    statusDetails.appendChild(statusFs);
    content.appendChild(statusDetails);

    // Domains accordion
    const domDetails = document.createElement('details');
    domDetails.className = 'a11y-filter-domain-details';
    const domSummary = document.createElement('summary');
    domSummary.textContent = 'Domain';
    domDetails.appendChild(domSummary);

    const domFs = document.createElement('fieldset');
    domFs.className = 'a11y-filter-fieldset';
    const domLegend = document.createElement('legend');
    domLegend.className = 'sr-only';
    domLegend.textContent = 'Filter by domain';
    domFs.appendChild(domLegend);

    const domAllWrap = document.createElement('div');
    domAllWrap.className = 'a11y-filter-checkbox-wrap';
    const domAll = document.createElement('input');
    domAll.type = 'checkbox';
    domAll.id = 'a11y-filter-domain-all';
    const domAllLabel = document.createElement('label');
    domAllLabel.setAttribute('for','a11y-filter-domain-all');
    domAllLabel.textContent = 'Select all domains';
    domAllWrap.appendChild(domAll);
    domAllWrap.appendChild(domAllLabel);
    domFs.appendChild(domAllWrap);

    const domSpecialWrap = document.createElement('div');
    domSpecialWrap.className = 'a11y-filter-domain-special';
    const domMainWrap = document.createElement('div');
    domMainWrap.className = 'a11y-filter-checkbox-wrap';
    const domAllMain = document.createElement('input');
    domAllMain.type = 'checkbox';
    domAllMain.id = 'a11y-filter-domain-main';
    const domAllMainLabel = document.createElement('label');
    domAllMainLabel.setAttribute('for','a11y-filter-domain-main');
    domAllMainLabel.textContent = 'All main NYU';
    domMainWrap.appendChild(domAllMain);
    domMainWrap.appendChild(domAllMainLabel);
    domSpecialWrap.appendChild(domMainWrap);

    const domLangWrap = document.createElement('div');
    domLangWrap.className = 'a11y-filter-checkbox-wrap';
    const domAllLang = document.createElement('input');
    domAllLang.type = 'checkbox';
    domAllLang.id = 'a11y-filter-domain-langone';
    const domAllLangLabel = document.createElement('label');
    domAllLangLabel.setAttribute('for','a11y-filter-domain-langone');
    domAllLangLabel.textContent = 'All Langone/Med';
    domLangWrap.appendChild(domAllLang);
    domLangWrap.appendChild(domAllLangLabel);
    domSpecialWrap.appendChild(domLangWrap);
    domFs.appendChild(domSpecialWrap);

    const domGroupsWrap = document.createElement('div');
    domGroupsWrap.className = 'a11y-filter-domain-groups';
    domFs.appendChild(domGroupsWrap);

    const domChildBoxes = [];
    const domParentGroups = [];

    domainHierarchy.forEach(item => {
      if (item.type === 'group') {
        const groupWrap = document.createElement('div');
        groupWrap.className = 'a11y-filter-domain-group';

        const parentWrap = document.createElement('div');
        parentWrap.className = 'a11y-filter-checkbox-wrap a11y-filter-checkbox-parent';
        const parentId = makeDomId(item.label, 'domain-parent');
        const parentCb = document.createElement('input');
        parentCb.type = 'checkbox';
        parentCb.id = parentId;
        parentCb.dataset.role = 'domain-parent';
        const childContainerId = makeDomId(item.label, 'domain-children');
        parentCb.setAttribute('aria-controls', childContainerId);
        const parentLabel = document.createElement('label');
        const parentLabelId = `${parentId}-label`;
        parentLabel.id = parentLabelId;
        parentLabel.setAttribute('for', parentId);
        parentLabel.textContent = item.label;
        parentWrap.appendChild(parentCb);
        parentWrap.appendChild(parentLabel);
        groupWrap.appendChild(parentWrap);

        const childList = document.createElement('div');
        childList.className = 'a11y-filter-domain-children';
        childList.id = childContainerId;
        childList.setAttribute('role','group');
        childList.setAttribute('aria-labelledby', parentLabelId);

        const childBoxes = [];

        item.children.forEach(child => {
          const childWrap = document.createElement('div');
          childWrap.className = 'a11y-filter-checkbox-wrap';
          const childId = makeDomId(child.value, 'domain');
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.id = childId;
          cb.value = child.value;
          const label = document.createElement('label');
          label.setAttribute('for', childId);
          label.textContent = child.label;
          childWrap.appendChild(cb);
          childWrap.appendChild(label);
          childList.appendChild(childWrap);
          childBoxes.push(cb);
          domChildBoxes.push(cb);
        });

        groupWrap.appendChild(childList);
        domGroupsWrap.appendChild(groupWrap);
        domParentGroups.push({ parent: parentCb, children: childBoxes });
      } else {
        const wrap = document.createElement('div');
        wrap.className = 'a11y-filter-checkbox-wrap';
        const childId = makeDomId(item.value, 'domain');
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = childId;
        cb.value = item.value;
        const label = document.createElement('label');
        label.setAttribute('for', childId);
        label.textContent = item.label;
        wrap.appendChild(cb);
        wrap.appendChild(label);
        domGroupsWrap.appendChild(wrap);
        domChildBoxes.push(cb);
      }
    });

    domDetails.appendChild(domFs);
    content.appendChild(domDetails);

    // Reset filters
    const resetBtn = document.createElement('button');
    resetBtn.type = 'button';
    resetBtn.className = 'a11y-btn-reset';
    resetBtn.textContent = 'Reset filters';
    content.appendChild(resetBtn);

    dialog.appendChild(content);

    const footer = document.createElement('div');
    footer.className = 'a11y-filter-footer';
    const saveBtn = document.createElement('button');
    saveBtn.type = 'button';
    saveBtn.className = 'a11y-btn-primary';
    saveBtn.textContent = 'Save';
    const cancelBtn = document.createElement('button');
    cancelBtn.type = 'button';
    cancelBtn.className = 'a11y-btn-secondary';
    cancelBtn.textContent = 'Cancel';
    footer.appendChild(saveBtn);
    footer.appendChild(cancelBtn);
    dialog.appendChild(footer);

    overlay.appendChild(dialog);
    appendOverlayAfterFooter(overlay);

    const typeBoxes = Array.from(typeFs.querySelectorAll('input[type="checkbox"]'))
      .filter(cb => cb !== typeAll);
    const statusBoxes = Array.from(statusFs.querySelectorAll('input[type="checkbox"]'))
      .filter(cb => cb !== statusAll);
    const domBoxes = domChildBoxes.slice();
    if (!domBoxes.length) {
      domAll.checked = true;
      domAll.disabled = true;
    }

    const isLangoneMedDomain = value => {
      const text = String(value || '').toLowerCase();
      if (!text) return false;
      if (text.includes('langone')) return true;
      const normalized = text.replace(/[-_]/g,' ');
      return /\bmed\b/.test(normalized);
    };
    const langoneBoxes = domBoxes.filter(cb => isLangoneMedDomain(cb.value || cb.id));
    const mainBoxes = domBoxes.filter(cb => !isLangoneMedDomain(cb.value || cb.id));

    // Initialize checkbox states based on existing filters
    function updateGroupAllState(groupAll, boxes) {
      if (!groupAll) return;
      const total = boxes.length;
      if (!total) {
        groupAll.checked = true;
        groupAll.indeterminate = false;
        return;
      }
      const checkedCount = boxes.reduce((count, cb) => count + (cb.checked ? 1 : 0), 0);
      groupAll.checked = checkedCount === total;
      groupAll.indeterminate = checkedCount > 0 && checkedCount < total;
    }

    function setBoxesState(boxes, checked) {
      boxes.forEach(cb => { cb.checked = checked; });
    }

    function updateSpecialGroupState(control, boxes) {
      if (!control) return;
      const total = boxes.length;
      if (!total) {
        control.checked = true;
        control.indeterminate = false;
        control.disabled = true;
        return;
      }
      control.disabled = false;
      const checkedCount = boxes.reduce((sum, cb) => sum + (cb.checked ? 1 : 0), 0);
      control.checked = checkedCount === total;
      control.indeterminate = checkedCount > 0 && checkedCount < total;
    }

    function refreshSpecialDomainStates() {
      updateSpecialGroupState(domAllMain, mainBoxes);
      updateSpecialGroupState(domAllLang, langoneBoxes);
    }

    function initChecks(groupAll, boxes, selectedSet) {
      const hasFilter = selectedSet.size > 0;
      if (!hasFilter) {
        boxes.forEach(cb => { cb.checked = true; });
      } else {
        boxes.forEach(cb => {
          cb.checked = selectedSet.has(cb.value);
        });
      }
      updateGroupAllState(groupAll, boxes);
    }

    function hookSelectAll(groupAll, boxes, { onBoxChange } = {}) {
      groupAll.addEventListener('change', () => {
        boxes.forEach(cb => { cb.checked = groupAll.checked; });
        if (onBoxChange) onBoxChange();
        updateGroupAllState(groupAll, boxes);
      });
      boxes.forEach(cb => {
        cb.addEventListener('change', () => {
          updateGroupAllState(groupAll, boxes);
          if (onBoxChange) onBoxChange();
        });
      });
      updateGroupAllState(groupAll, boxes);
    }

    function syncAllDomainParents() {
      domParentGroups.forEach(({ parent, children }) => {
        const total = children.length;
        const checkedCount = children.reduce((count, child) => count + (child.checked ? 1 : 0), 0);
        parent.checked = total > 0 && checkedCount === total;
        parent.indeterminate = checkedCount > 0 && checkedCount < total;
      });
    }

    initChecks(typeAll, typeBoxes, currentFilters.types);
    initChecks(statusAll, statusBoxes, currentFilters.statuses);
    initChecks(domAll, domBoxes, currentFilters.domains);
    syncAllDomainParents();
    refreshSpecialDomainStates();

    hookSelectAll(typeAll, typeBoxes);
    hookSelectAll(statusAll, statusBoxes);
    hookSelectAll(domAll, domBoxes, { onBoxChange: () => {
      syncAllDomainParents();
      refreshSpecialDomainStates();
    } });

    if (domAllMain) {
      domAllMain.addEventListener('change', () => {
        setBoxesState(mainBoxes, domAllMain.checked);
        if (domAllMain.checked) {
          setBoxesState(langoneBoxes, false);
        }
        syncAllDomainParents();
        updateGroupAllState(domAll, domBoxes);
        refreshSpecialDomainStates();
      });
    }
    if (domAllLang) {
      domAllLang.addEventListener('change', () => {
        setBoxesState(langoneBoxes, domAllLang.checked);
        if (domAllLang.checked) {
          setBoxesState(mainBoxes, false);
        }
        syncAllDomainParents();
        updateGroupAllState(domAll, domBoxes);
        refreshSpecialDomainStates();
      });
    }
    domBoxes.forEach(cb => {
      cb.addEventListener('change', refreshSpecialDomainStates);
    });

    domParentGroups.forEach(group => {
      group.parent.addEventListener('change', () => {
        const checked = group.parent.checked;
        group.parent.indeterminate = false;
        group.children.forEach(child => {
          child.checked = checked;
        });
        syncAllDomainParents();
        updateGroupAllState(domAll, domBoxes);
        refreshSpecialDomainStates();
      });
    });

    resetBtn.addEventListener('click', () => {
      content.querySelectorAll('input[type="checkbox"]').forEach(cb => {
        cb.checked = true;
        cb.indeterminate = false;
      });
      syncAllDomainParents();
      updateGroupAllState(typeAll, typeBoxes);
      updateGroupAllState(statusAll, statusBoxes);
      updateGroupAllState(domAll, domBoxes);
      refreshSpecialDomainStates();
    });

    parentDialog.setAttribute('aria-hidden','true');
    const lastFocused = document.activeElement;

    function applyFilters() {
      logWidget('openFilterModal applyFilters invoked');
      const newTypes = new Set(
        typeBoxes.filter(cb => cb.checked).map(cb => cb.value)
      );
      const newStatuses = new Set(
        statusBoxes.filter(cb => cb.checked).map(cb => cb.value)
      );
      const newDomains = new Set(
        domBoxes.filter(cb => cb.checked).map(cb => cb.value)
      );
      // if all checked, treat as no filter
      if (typeBoxes.length && newTypes.size === typeBoxes.length) newTypes.clear();
      if (statusBoxes.length && newStatuses.size === statusBoxes.length) newStatuses.clear();
      if (domBoxes.length && newDomains.size === domBoxes.length) newDomains.clear();
      currentFilters = { types: newTypes, domains: newDomains, statuses: newStatuses };
      logWidget('Filters updated', {
        types: currentFilters.types.size,
        domains: currentFilters.domains.size,
        statuses: currentFilters.statuses.size
      });
    }

    async function close({ apply }) {
      logWidget('openFilterModal close requested', { apply });
      document.removeEventListener('keydown', onKeydown, true);
      overlay.remove();
      parentDialog.removeAttribute('aria-hidden');

      const prevState = captureAccordionState(bodyEl) || getDefaultAccordionState(currentTabKey);
      try {
        const fresh = await buildData();
        accordionStateByTab[currentTabKey] = prevState || {};
        renderBody(bodyEl, fresh, updateFilterButtonLabel, footerEl, prevState);
        const activePanel = getActivePanelElement(bodyEl);
        accordionStateByTab[currentTabKey] = captureAccordionState(activePanel || bodyEl) || {};
        if (updateFilterButtonLabel) updateFilterButtonLabel(fresh);
        logWidget('openFilterModal close complete', { apply, tab: currentTabKey });
      } catch (e) {
        alert(e.message);
      } finally {
        if (lastFocused && lastFocused.focus) lastFocused.focus();
      }
    }

    function onKeydown(e) {
      if (e.key === 'Escape') {
        e.preventDefault();
        close({ apply:false }).catch(console.error);
      } else if (e.key === 'Tab') {
        const f = getFocusable(dialog);
        if (!f.length) return;
        const first = f[0];
        const last = f[f.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault(); last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault(); first.focus();
        }
      }
    }

    document.addEventListener('keydown', onKeydown, true);
    closeBtn.addEventListener('click', () => { close({ apply:false }).catch(console.error); });
    cancelBtn.addEventListener('click', () => { close({ apply:false }).catch(console.error); });
    saveBtn.addEventListener('click', () => {
      applyFilters();
      close({ apply:true }).catch(console.error);
    });
    overlay.addEventListener('click', e => {
      if (e.target === overlay) close({ apply:false }).catch(console.error);
    });

    h2.setAttribute('tabindex','-1');
    h2.focus();
  }

  // --- Main modal ---

  async function openModal(triggerButton, { mode = pageContext } = {}) {
    const dialogMode = mode || pageContext;
    const isScansDialog = dialogMode === 'scans';
    logWidget('openModal requested', { dialogMode, isScansDialog });
    const minimizeAriaLabel = isScansDialog ? 'Hide scan summary dialog' : 'Hide quick actions dialog';
    const restoreLabel = isScansDialog ? 'Show scan summary' : 'Show quick actions';
    let isMinimized = false;
    let restoreButton = null;
    let data = null;
    if (isScansDialog) {
      if (lastRenderedData) {
        data = lastRenderedData;
        logWidget('openModal data ready (cached)', { rowCount: data?.rows?.length || 0 });
      } else {
        try {
          data = await getBuildDataPromise();
          lastRenderedData = data;
          logWidget('openModal data ready', { rowCount: data?.rows?.length || 0 });
        } catch (e) {
          alert(e.message);
          logWidget('openModal data load failed', e?.message || e);
          return;
        }
      }
    }

    const existing = document.querySelector('.a11y-scan-report-overlay');
    if (existing) existing.remove();

    const overlay = document.createElement('div');
    overlay.className = 'a11y-scan-report-overlay';
    try {
      // Debug helper: make overlay transparent when localStorage flag is set; remove when no longer needed.
      if (localStorage.getItem('a11y-overlay-transparent') === 'true') {
        overlay.classList.add('a11y-overlay-transparent');
      }
    } catch (err) {
      // ignore storage errors
    }

    const dialog = document.createElement('div');
    dialog.className = 'a11y-scan-report-dialog';
    dialog.setAttribute('role','dialog');
    dialog.setAttribute('aria-modal','true');
    dialog.setAttribute('aria-labelledby','a11y-scan-report-title');

    const header = document.createElement('div');
    header.className = 'a11y-scan-report-header';

    const left = document.createElement('div');
    left.className = 'a11y-scan-report-header-left';
    const h1 = document.createElement('h1');
    h1.id = 'a11y-scan-report-title';
    h1.textContent = isScansDialog ? 'Accessibility Scan Summary' : 'Quick Actions';
    left.appendChild(h1);
    header.appendChild(left);

    const actions = document.createElement('div');
    actions.className = 'a11y-scan-report-header-actions';
    let updateFilterButtonLabel = null;
    if (isScansDialog) {
      const filterBtn = document.createElement('button');
      filterBtn.type = 'button';
      filterBtn.className = 'a11y-filter-button';
      filterBtn.innerHTML = `
        <span aria-hidden="true">
          <svg overflow="visible" viewBox="0 0 24 24" height="16" width="16">
            <path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z" fill="currentColor"></path>
          </svg>
        </span>
        <span class="a11y-filter-label">Filters (0)</span>
      `;
      filterBtn.setAttribute('aria-label','Filters (0)');
      updateFilterButtonLabel = () => {
        const activeCount =
          (currentFilters.types.size || 0) +
          (currentFilters.domains.size || 0) +
          (currentFilters.statuses.size || 0);
        const label = `Filters (${activeCount})`;
        const span = filterBtn.querySelector('.a11y-filter-label');
        if (span) span.textContent = label;
        filterBtn.setAttribute('aria-label', label);
      };
      filterBtn.addEventListener('click', () => {
        logWidget('Filter button clicked', {
          activeFilterCounts: {
            types: currentFilters.types.size,
            domains: currentFilters.domains.size,
            statuses: currentFilters.statuses.size
          }
        });
        const openWithData = data => {
          if (!data) {
            alert('Unable to load filter data.');
            return;
          }
          openFilterModal(dialog, body, footer, data, updateFilterButtonLabel);
        };
        if (lastRenderedData) {
          openWithData(lastRenderedData);
          refreshMainView({ preserveState: true }).catch(err => {
            logWidget('Filter button background refresh failed', err?.message || err);
          });
          return;
        }
        refreshMainView({ preserveState: true })
          .then(openWithData)
          .catch(err => alert(err.message));
      });
      const filterHolder = document.createElement('div');
      filterHolder.className = 'a11y-header-filter-holder';
      filterHolder.appendChild(filterBtn);
      const sourceToggle = buildPageImpactSourceToggleControl();
      if (sourceToggle) {
        filterHolder.appendChild(sourceToggle);
      }
      left.appendChild(filterHolder);
    }

    const body = document.createElement('div');
    body.className = 'a11y-scan-report-body';
    const footer = document.createElement('div');
    footer.className = 'a11y-scan-report-footer';

    const minimizeBtn = document.createElement('button');
    minimizeBtn.type = 'button';
    minimizeBtn.className = 'a11y-scan-report-minimize';
    minimizeBtn.textContent = 'Minimize';
    minimizeBtn.setAttribute('aria-label', minimizeAriaLabel);

    const settingsBtn = document.createElement('button');
    settingsBtn.type = 'button';
    settingsBtn.className = 'a11y-scan-report-settings';
    settingsBtn.textContent = 'Settings';
    settingsBtn.setAttribute('aria-label','Open settings dialog');

    settingsBtn.addEventListener('click', () => {
      openSettingsDialog().catch(err => {
        console.error(err);
        alert(err?.message || 'Unable to open settings.');
      });
    });

    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'Dialog__close';
    closeBtn.innerHTML = '<span aria-hidden="true" class="Icon Icon--close"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" height="24" width="24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" fill="currentColor"></path></svg></span><span class="Offscreen">Close</span>';
  minimizeBtn.addEventListener('click', () => minimizeModal());
  actions.appendChild(minimizeBtn);
  actions.appendChild(settingsBtn);
  actions.appendChild(closeBtn);

    header.appendChild(actions);
    dialog.appendChild(header);
    dialog.appendChild(body);
    dialog.appendChild(footer);
    overlay.appendChild(dialog);
    appendOverlayAfterFooter(overlay);

    // The scans summary dialog only reads data, so we can safely inert the page.
    // Quick Actions needs to interact with the underlying Monitor UI (click
    // filters, bulk actions, etc.), so we must leave the page interactive while
    // that dialog is open.
    if (isScansDialog) {
      setBackgroundInert(dialog);
    }
    modalContext = isScansDialog
      ? { body, footer, updateFilterButtonLabel, mode: dialogMode }
      : { body, footer, mode: dialogMode };

    const lastFocused = triggerButton || document.activeElement;

    function close() {
      closePageImpactFilterPopover({ focusButton: false });
      removeRestoreButton();
      isMinimized = false;
      dialog.removeAttribute('hidden');
      dialog.removeAttribute('aria-hidden');
      overlay.style.display = '';
      document.removeEventListener('keydown', onKeydown, true);
      clearBackgroundInert();
      overlay.remove();
      modalContext = null;
      pageImpactFilterState.button = null;
      pageImpactFilterState.summaryEl = null;
      pageImpactFilterState.sourceSegment = null;
      pageImpactFilterState.sourceButtons = null;
      if (isScansDialog) {
        setPageImpactSource(defaultPageImpactSource);
      }
      logWidget('openModal closed', { dialogMode });
      if (lastFocused && lastFocused.focus) lastFocused.focus();
    }

    function handleRestoreButtonClick() {
      restoreModal();
    }

    function ensureRestoreButton() {
      if (restoreButton) return;
      restoreButton = document.createElement('button');
      restoreButton.type = 'button';
      restoreButton.className = 'a11y-scan-report-restore';
      restoreButton.textContent = restoreLabel;
      restoreButton.setAttribute('aria-label', restoreLabel);
      restoreButton.addEventListener('click', handleRestoreButtonClick);
      document.body.appendChild(restoreButton);
      restoreButton.focus();
    }

    function removeRestoreButton() {
      if (!restoreButton) return;
      restoreButton.removeEventListener('click', handleRestoreButtonClick);
      restoreButton.remove();
      restoreButton = null;
    }

    function minimizeModal() {
      if (isMinimized) return;
      isMinimized = true;
      dialog.setAttribute('hidden','');
      dialog.setAttribute('aria-hidden','true');
      overlay.style.display = 'none';
      clearBackgroundInert();
      ensureRestoreButton();
      logWidget('Modal minimized');
    }

    function restoreModal({ focus = true } = {}) {
      if (!isMinimized) return;
      isMinimized = false;
      dialog.removeAttribute('hidden');
      dialog.removeAttribute('aria-hidden');
      overlay.style.display = '';
      if (isScansDialog) {
        setBackgroundInert(dialog);
      }
      removeRestoreButton();
      if (focus) {
        closeBtn.focus();
      }
      logWidget('Modal restored');
    }

    function onKeydown(e) {
      if (isMinimized) return;
      if (e.key === 'Escape') {
        e.preventDefault();
        close();
      } else if (e.key === 'Tab') {
        const f = getFocusable(dialog);
        if (!f.length) return;
        const first = f[0];
        const last = f[f.length - 1];
        if (e.shiftKey && document.activeElement === first) {
          e.preventDefault(); last.focus();
        } else if (!e.shiftKey && document.activeElement === last) {
          e.preventDefault(); first.focus();
        }
      }
    }

    closeBtn.addEventListener('click', close);
    overlay.addEventListener('click', e => { if (e.target === overlay) close(); });
    document.addEventListener('keydown', onKeydown, true);

    Object.keys(accordionStateByTab).forEach(key => { delete accordionStateByTab[key]; });
    currentTabKey = isScansDialog ? 'status' : 'quick';
    if (isScansDialog) {
      pageImpactFilterState.initialSourceEvaluated = false;
    }
    const initialState = getDefaultAccordionState(currentTabKey);
    renderBody(body, data, updateFilterButtonLabel, footer, initialState);
    const activePanel = getActivePanelElement(body);
    accordionStateByTab[currentTabKey] = captureAccordionState(activePanel || body) || initialState;
    closeBtn.focus();
  }

  // --- Launcher button ---

  const launcherButton = document.createElement('button');
  launcherButton.type = 'button';
  launcherButton.className = 'a11y-scan-report-button';
  launcherButton.textContent = pageContext === 'scans' ? 'Scan summary' : 'Quick Actions';
  launcherButton.addEventListener('click', () => {
    openModal(launcherButton, { mode: pageContext }).catch(err => alert(err.message));
  });
  root.appendChild(launcherButton);

  console.log(
    pageContext === 'scans'
      ? 'Accessibility Scan Summary widget injected on scans list.'
      : 'Quick Actions widget injected on issues list.'
  );
})();
